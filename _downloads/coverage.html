<html>
  <head>
    <title>pycobertura report</title>
    <meta charset="UTF-8">
    <style>
/*! normalize.css v3.0.2 | MIT License | git.io/normalize */

/**
 * 1. Set default font family to sans-serif.
 * 2. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
  font-family: sans-serif; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
}

/**
 * Remove default margin.
 */

body {
  margin: 0;
}

/* HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined for any HTML5 element in IE 8/9.
 * Correct `block` display not defined for `details` or `summary` in IE 10/11
 * and Firefox.
 * Correct `block` display not defined for `main` in IE 11.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}

/**
 * 1. Correct `inline-block` display not defined in IE 8/9.
 * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.
 */

audio,
canvas,
progress,
video {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
  display: none;
  height: 0;
}

/**
 * Address `[hidden]` styling not present in IE 8/9/10.
 * Hide the `template` element in IE 8/9/11, Safari, and Firefox < 22.
 */

[hidden],
template {
  display: none;
}

/* Links
   ========================================================================== */

/**
 * Remove the gray background color from active links in IE 10.
 */

a {
  background-color: transparent;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
  outline: 0;
}

/* Text-level semantics
   ========================================================================== */

/**
 * Address styling not present in IE 8/9/10/11, Safari, and Chrome.
 */

abbr[title] {
  border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.
 */

b,
strong {
  font-weight: bold;
}

/**
 * Address styling not present in Safari and Chrome.
 */

dfn {
  font-style: italic;
}

/**
 * Address variable `h1` font-size and margin within `section` and `article`
 * contexts in Firefox 4+, Safari, and Chrome.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/**
 * Address styling not present in IE 8/9.
 */

mark {
  background: #ff0;
  color: #000;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

/* Embedded content
   ========================================================================== */

/**
 * Remove border when inside `a` element in IE 8/9/10.
 */

img {
  border: 0;
}

/**
 * Correct overflow not hidden in IE 9/10/11.
 */

svg:not(:root) {
  overflow: hidden;
}

/* Grouping content
   ========================================================================== */

/**
 * Address margin not present in IE 8/9 and Safari.
 */

figure {
  margin: 1em 40px;
}

/**
 * Address differences between Firefox and other browsers.
 */

hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

/**
 * Contain overflow in all browsers.
 */

pre {
  overflow: auto;
}

/**
 * Address odd `em`-unit font size rendering in all browsers.
 */

code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

/* Forms
   ========================================================================== */

/**
 * Known limitation: by default, Chrome and Safari on OS X allow very limited
 * styling of `select`, unless a `border` property is set.
 */

/**
 * 1. Correct color not being inherited.
 *    Known issue: affects color of disabled elements.
 * 2. Correct font properties not being inherited.
 * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.
 */

button,
input,
optgroup,
select,
textarea {
  color: inherit; /* 1 */
  font: inherit; /* 2 */
  margin: 0; /* 3 */
}

/**
 * Address `overflow` set to `hidden` in IE 8/9/10/11.
 */

button {
  overflow: visible;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.
 * Correct `select` style inheritance in Firefox.
 */

button,
select {
  text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button; /* 2 */
  cursor: pointer; /* 3 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
  cursor: default;
}

/**
 * Remove inner padding and border in Firefox 4+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}

/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

input {
  line-height: normal;
}

/**
 * It's recommended that you don't attempt to style these elements.
 * Firefox's implementation doesn't respect box-sizing, padding, or width.
 *
 * 1. Address box sizing set to `content-box` in IE 8/9/10.
 * 2. Remove excess padding in IE 8/9/10.
 */

input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Fix the cursor style for Chrome's increment/decrement buttons. For certain
 * `font-size` values of the `input`, it causes the cursor style of the
 * decrement button to change from `default` to `text`.
 */

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box; /* 2 */
  box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari and Chrome on OS X.
 * Safari (but not Chrome) clips the cancel button when the search input has
 * padding (and `textfield` appearance).
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct `color` not being inherited in IE 8/9/10/11.
 * 2. Remove padding so people aren't caught out if they zero out fieldsets.
 */

legend {
  border: 0; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Remove default vertical scrollbar in IE 8/9/10/11.
 */

textarea {
  overflow: auto;
}

/**
 * Don't inherit the `font-weight` (applied by a rule above).
 * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.
 */

optgroup {
  font-weight: bold;
}

/* Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
  border-collapse: collapse;
  border-spacing: 0;
}

td,
th {
  padding: 0;
}
/*
* Skeleton V2.0.4
* Copyright 2014, Dave Gamache
* www.getskeleton.com
* Free to use under the MIT license.
* http://www.opensource.org/licenses/mit-license.php
* 12/29/2014
*/


/* Table of contents
––––––––––––––––––––––––––––––––––––––––––––––––––
- Grid
- Base Styles
- Typography
- Links
- Buttons
- Forms
- Lists
- Code
- Tables
- Spacing
- Utilities
- Clearing
- Media Queries
*/


/* Grid
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }
.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 85%;
    padding: 0; }
}

/* For devices larger than 550px */
@media (min-width: 550px) {
  .container {
    width: 80%; }
  .column,
  .columns {
    margin-left: 4%; }
  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns                    { width: 4.66666666667%; }
  .two.columns                    { width: 13.3333333333%; }
  .three.columns                  { width: 22%;            }
  .four.columns                   { width: 30.6666666667%; }
  .five.columns                   { width: 39.3333333333%; }
  .six.columns                    { width: 48%;            }
  .seven.columns                  { width: 56.6666666667%; }
  .eight.columns                  { width: 65.3333333333%; }
  .nine.columns                   { width: 74.0%;          }
  .ten.columns                    { width: 82.6666666667%; }
  .eleven.columns                 { width: 91.3333333333%; }
  .twelve.columns                 { width: 100%; margin-left: 0; }

  .one-third.column               { width: 30.6666666667%; }
  .two-thirds.column              { width: 65.3333333333%; }

  .one-half.column                { width: 48%; }

  /* Offsets */
  .offset-by-one.column,
  .offset-by-one.columns          { margin-left: 8.66666666667%; }
  .offset-by-two.column,
  .offset-by-two.columns          { margin-left: 17.3333333333%; }
  .offset-by-three.column,
  .offset-by-three.columns        { margin-left: 26%;            }
  .offset-by-four.column,
  .offset-by-four.columns         { margin-left: 34.6666666667%; }
  .offset-by-five.column,
  .offset-by-five.columns         { margin-left: 43.3333333333%; }
  .offset-by-six.column,
  .offset-by-six.columns          { margin-left: 52%;            }
  .offset-by-seven.column,
  .offset-by-seven.columns        { margin-left: 60.6666666667%; }
  .offset-by-eight.column,
  .offset-by-eight.columns        { margin-left: 69.3333333333%; }
  .offset-by-nine.column,
  .offset-by-nine.columns         { margin-left: 78.0%;          }
  .offset-by-ten.column,
  .offset-by-ten.columns          { margin-left: 86.6666666667%; }
  .offset-by-eleven.column,
  .offset-by-eleven.columns       { margin-left: 95.3333333333%; }

  .offset-by-one-third.column,
  .offset-by-one-third.columns    { margin-left: 34.6666666667%; }
  .offset-by-two-thirds.column,
  .offset-by-two-thirds.columns   { margin-left: 69.3333333333%; }

  .offset-by-one-half.column,
  .offset-by-one-half.columns     { margin-left: 52%; }

}


/* Base Styles
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/* NOTE
html is set to 62.5% so that all the REM measurements throughout Skeleton
are based on 10px sizing. So basically 1.5rem = 15px :) */
html {
  font-size: 62.5%; }
body {
  font-size: 1.5em; /* currently ems cause chrome bug misinterpreting rems on body element */
  line-height: 1.6;
  font-weight: 400;
  font-family: "Raleway", "HelveticaNeue", "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #222; }


/* Typography
–––––––––––––––––––––––––––––––––––––––––––––––––– */
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 2rem;
  font-weight: 300; }
h1 { font-size: 4.0rem; line-height: 1.2;  letter-spacing: -.1rem;}
h2 { font-size: 3.6rem; line-height: 1.25; letter-spacing: -.1rem; }
h3 { font-size: 3.0rem; line-height: 1.3;  letter-spacing: -.1rem; }
h4 { font-size: 2.4rem; line-height: 1.35; letter-spacing: -.08rem; }
h5 { font-size: 1.8rem; line-height: 1.5;  letter-spacing: -.05rem; }
h6 { font-size: 1.5rem; line-height: 1.6;  letter-spacing: 0; }

/* Larger than phablet */
@media (min-width: 550px) {
  h1 { font-size: 5.0rem; }
  h2 { font-size: 4.2rem; }
  h3 { font-size: 3.6rem; }
  h4 { font-size: 3.0rem; }
  h5 { font-size: 2.4rem; }
  h6 { font-size: 1.5rem; }
}

p {
  margin-top: 0; }


/* Links
–––––––––––––––––––––––––––––––––––––––––––––––––– */
a {
  color: #1EAEDB; }
a:hover {
  color: #0FA0CE; }


/* Buttons
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.button,
button,
input[type="submit"],
input[type="reset"],
input[type="button"] {
  display: inline-block;
  height: 38px;
  padding: 0 30px;
  color: #555;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  line-height: 38px;
  letter-spacing: .1rem;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  background-color: transparent;
  border-radius: 4px;
  border: 1px solid #bbb;
  cursor: pointer;
  box-sizing: border-box; }
.button:hover,
button:hover,
input[type="submit"]:hover,
input[type="reset"]:hover,
input[type="button"]:hover,
.button:focus,
button:focus,
input[type="submit"]:focus,
input[type="reset"]:focus,
input[type="button"]:focus {
  color: #333;
  border-color: #888;
  outline: 0; }
.button.button-primary,
button.button-primary,
input[type="submit"].button-primary,
input[type="reset"].button-primary,
input[type="button"].button-primary {
  color: #FFF;
  background-color: #33C3F0;
  border-color: #33C3F0; }
.button.button-primary:hover,
button.button-primary:hover,
input[type="submit"].button-primary:hover,
input[type="reset"].button-primary:hover,
input[type="button"].button-primary:hover,
.button.button-primary:focus,
button.button-primary:focus,
input[type="submit"].button-primary:focus,
input[type="reset"].button-primary:focus,
input[type="button"].button-primary:focus {
  color: #FFF;
  background-color: #1EAEDB;
  border-color: #1EAEDB; }


/* Forms
–––––––––––––––––––––––––––––––––––––––––––––––––– */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea,
select {
  height: 38px;
  padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
  background-color: #fff;
  border: 1px solid #D1D1D1;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box; }
/* Removes awkward default styles on some inputs for iOS */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none; }
textarea {
  min-height: 65px;
  padding-top: 6px;
  padding-bottom: 6px; }
input[type="email"]:focus,
input[type="number"]:focus,
input[type="search"]:focus,
input[type="text"]:focus,
input[type="tel"]:focus,
input[type="url"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  border: 1px solid #33C3F0;
  outline: 0; }
label,
legend {
  display: block;
  margin-bottom: .5rem;
  font-weight: 600; }
fieldset {
  padding: 0;
  border-width: 0; }
input[type="checkbox"],
input[type="radio"] {
  display: inline; }
label > .label-body {
  display: inline-block;
  margin-left: .5rem;
  font-weight: normal; }


/* Lists
–––––––––––––––––––––––––––––––––––––––––––––––––– */
ul {
  list-style: circle inside; }
ol {
  list-style: decimal inside; }
ol, ul {
  padding-left: 0;
  margin-top: 0; }
ul ul,
ul ol,
ol ol,
ol ul {
  margin: 1.5rem 0 1.5rem 3rem;
  font-size: 90%; }
li {
  margin-bottom: 1rem; }


/* Code
–––––––––––––––––––––––––––––––––––––––––––––––––– */
code {
  padding: .2rem .5rem;
  margin: 0 .2rem;
  font-size: 90%;
  white-space: nowrap;
  background: #F1F1F1;
  border: 1px solid #E1E1E1;
  border-radius: 4px; }
pre > code {
  display: block;
  padding: 1rem 1.5rem;
  white-space: pre; }


/* Tables
–––––––––––––––––––––––––––––––––––––––––––––––––– */
th,
td {
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #E1E1E1; }
th:first-child,
td:first-child {
  padding-left: 0; }
th:last-child,
td:last-child {
  padding-right: 0; }


/* Spacing
–––––––––––––––––––––––––––––––––––––––––––––––––– */
button,
.button {
  margin-bottom: 1rem; }
input,
textarea,
select,
fieldset {
  margin-bottom: 1.5rem; }
pre,
blockquote,
dl,
figure,
table,
p,
ul,
ol,
form {
  margin-bottom: 2.5rem; }


/* Utilities
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.u-full-width {
  width: 100%;
  box-sizing: border-box; }
.u-max-full-width {
  max-width: 100%;
  box-sizing: border-box; }
.u-pull-right {
  float: right; }
.u-pull-left {
  float: left; }


/* Misc
–––––––––––––––––––––––––––––––––––––––––––––––––– */
hr {
  margin-top: 3rem;
  margin-bottom: 3.5rem;
  border-width: 0;
  border-top: 1px solid #E1E1E1; }


/* Clearing
–––––––––––––––––––––––––––––––––––––––––––––––––– */

/* Self Clearing Goodness */
.container:after,
.row:after,
.u-cf {
  content: "";
  display: table;
  clear: both; }


/* Media Queries
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/*
Note: The best way to structure the use of media queries is to create the queries
near the relevant code. For example, if you wanted to change the styles for buttons
on small devices, paste the mobile query code up in the buttons section and style it
there.
*/


/* Larger than mobile */
@media (min-width: 400px) {}

/* Larger than phablet (also point when grid becomes active) */
@media (min-width: 550px) {}

/* Larger than tablet */
@media (min-width: 750px) {}

/* Larger than desktop */
@media (min-width: 1000px) {}

/* Larger than Desktop HD */
@media (min-width: 1200px) {}
.hit {background-color: #EAFFEA}
.miss {background-color: #FFECEC}
.container .code {margin-left: 0}
pre {line-height: 1.3}
    </style>
  </head>
  <body>
    <div class="container">
      <table class="u-full-width">
        <thead>
          <tr>
            <th>Filename</th>
            <th>Stmts</th>
            <th>Miss</th>
            <th>Cover</th>
            <th>Missing</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><a href="#__init__.py">__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_01_pointer.py">unittests_01_pointer.py</a></td>
            <td>191</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_02_timetools.py">unittests_02_timetools.py</a></td>
            <td>405</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_03_filetools.py">unittests_03_filetools.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_04_devicetools.py">unittests_04_devicetools.py</a></td>
            <td>320</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_05_connectiontools.py">unittests_05_connectiontools.py</a></td>
            <td>53</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_06_selectiontools.py">unittests_06_selectiontools.py</a></td>
            <td>133</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_07_parametertools.py">unittests_07_parametertools.py</a></td>
            <td>1</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_08_indextools.py">unittests_08_indextools.py</a></td>
            <td>67</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py</a></td>
            <td>24</td>
            <td>1</td>
            <td>95.83%</td>
            <td>30</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py</a></td>
            <td>33</td>
            <td>4</td>
            <td>87.88%</td>
            <td>17, 35, 43, 57</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py</a></td>
            <td>322</td>
            <td>102</td>
            <td>68.32%</td>
            <td>47, 60-62, 68, 122, 135-137, 146-153, 164, 170, 173, 176-181, 184-189, 192-197, 200-210, 299-301, 304-307, 311-313, 316-319, 322-332, 335, 338, 341, 355-360, 446, 449, 455, 458, 461, 464-467, 470-482, 485</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py</a></td>
            <td>565</td>
            <td>388</td>
            <td>31.33%</td>
            <td>20-29, 32, 36-37, 42-49, 52, 55-56, 59-67, 70-83, 86, 93-94, 98, 103, 105-110, 115, 120, 126-127, 137-165, 174-187, 194-204, 207, 218-220, 224, 229, 231-236, 241, 246-252, 257-260, 265-281, 286-291, 295, 301, 312-324, 342-354, 362-365, 368-373, 378, 381, 384, 387-399, 402, 415, 419, 423, 427, 431, 435, 439, 443, 447, 457, 462, 464-469, 474, 479-485, 490-493, 498-515, 521-526, 530, 536-553, 559-564, 568, 574-591, 597-602, 606, 613-630, 636-641, 645, 651, 656, 661, 666, 671, 673-677, 685, 689, 699, 701-705, 712, 714, 718, 720, 724, 726, 730, 732, 736, 743-746, 750, 757, 759-764, 769, 776-782, 787-809, 815-820, 824, 830-852, 858-863, 867, 873, 878, 882-892</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py</a></td>
            <td>268</td>
            <td>216</td>
            <td>19.40%</td>
            <td>25-50, 53-55, 58-66, 70-82, 87, 92, 97-124, 127-128, 131-132, 135-136, 140-144, 148-163, 166-169, 172-180, 183-190, 194-202, 206-209, 213, 217-220, 223-226, 229-232, 236-257, 260-278, 281-283, 286, 289, 292, 295-302, 305-306, 309, 312, 315-320, 323-325, 328, 331, 334, 337-345, 351-352, 355, 358, 361-367</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py</a></td>
            <td>46</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py</a></td>
            <td>166</td>
            <td>84</td>
            <td>49.40%</td>
            <td>32-35, 39, 43-79, 94, 100-103, 106-107, 110-118, 121, 124-125, 128, 184-186, 208, 219-246</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py</a></td>
            <td>49</td>
            <td>17</td>
            <td>65.31%</td>
            <td>21-38, 63, 85, 89, 102</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py</a></td>
            <td>272</td>
            <td>85</td>
            <td>68.75%</td>
            <td>46, 95, 140, 232, 234, 306, 320, 323-326, 335, 401, 408-409, 413-414, 417-420, 424-425, 427-428, 433-434, 436, 438-439, 444-445, 449-450, 456-459, 461-464, 466-467, 470-473, 475-478, 480-481, 484-487, 489-492, 494-495, 498, 501, 504, 507, 512-513, 518-519, 524-525, 530-531, 534-537, 542-543, 549, 558, 561</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py</a></td>
            <td>395</td>
            <td>110</td>
            <td>72.15%</td>
            <td>51-74, 78-89, 93-96, 104, 107, 154, 158-159, 173, 199, 204, 208-210, 228-248, 255, 260-263, 285, 308, 354, 357, 367, 373, 375, 387, 393, 401-402, 415-416, 435-438, 468-469, 475, 487, 498-499, 515, 525-530, 553-554, 558, 573, 593-594, 604, 607-618, 651, 663, 669, 717</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py</a></td>
            <td>210</td>
            <td>104</td>
            <td>50.48%</td>
            <td>19-20, 24, 29, 33, 36, 39, 42-45, 48-49, 52, 65-76, 85-89, 92-95, 98-105, 108-114, 117, 125-135, 138, 198-201, 249-251, 261-263, 273-282, 382, 386, 390, 394, 398, 402, 406, 409, 417-441, 444</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py</a></td>
            <td>844</td>
            <td>395</td>
            <td>53.20%</td>
            <td>42, 45-47, 50-52, 55-57, 60-62, 65-67, 70-72, 77, 85-87, 99-101, 108-110, 114-125, 131-142, 147-166, 169-170, 173, 253-254, 268, 273-276, 281-282, 286, 291, 294, 297-298, 301-302, 305-306, 309-310, 313-314, 317-318, 325, 359, 362-363, 370-371, 410, 432, 444, 455-456, 468-469, 488-495, 500-504, 508-520, 524-527, 532-533, 536-540, 555, 558-570, 575, 592-604, 613, 615, 621-624, 626, 628, 634, 639-650, 658, 660, 665-671, 679, 681, 686-689, 691, 693, 699-702, 704, 706, 713, 729, 736-740, 747, 751-755, 758-759, 763-765, 788-793, 797-804, 808-811, 818-836, 842-852, 858-871, 874-879, 883-886, 890-896, 901, 905-912, 916-918, 922-929, 933-935, 939-943, 947-951, 963-972, 979, 981, 1001, 1008-1009, 1058, 1068-1072, 1077-1078, 1088-1089, 1111-1113, 1160, 1165, 1173, 1177-1178, 1193-1202, 1209, 1211, 1222-1226, 1249-1254, 1259-1264, 1270, 1282, 1285, 1320-1330, 1334-1337, 1342-1367, 1378-1388, 1390-1391</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py</a></td>
            <td>474</td>
            <td>115</td>
            <td>75.74%</td>
            <td>368, 402-405, 411, 445-446, 547-548, 589, 592, 613, 620, 633-634, 640, 658-662, 677, 713-714, 723, 775-780, 786, 825-830, 838-842, 910, 930, 947-966, 970, 972-974, 981-1013, 1023, 1032, 1036, 1039-1040, 1043, 1046-1053, 1056, 1077, 1081, 1088-1090, 1098, 1104, 1110, 1116, 1122, 1127, 1132, 1135, 1145, 1158, 1161-1162, 1165, 1168, 1176-1187, 1190</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py</a></td>
            <td>1</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py</a></td>
            <td>455</td>
            <td>26</td>
            <td>94.29%</td>
            <td>30-31, 79-80, 83-84, 169, 208-222, 230, 398, 404-410, 572, 589, 660, 664, 672, 676</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py</a></td>
            <td>35</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch.py</a></td>
            <td>142</td>
            <td>26</td>
            <td>81.69%</td>
            <td>86, 93-100, 220, 226, 244-245, 255, 262, 270, 274-283, 288-297</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream.py</a></td>
            <td>80</td>
            <td>15</td>
            <td>81.25%</td>
            <td>129-131, 136-139, 188-189, 297-302</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py</a></td>
            <td>24</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py</a></td>
            <td>7</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py</a></td>
            <td>122</td>
            <td>4</td>
            <td>96.72%</td>
            <td>268, 272, 281-282</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py</a></td>
            <td>25</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py</a></td>
            <td>66</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_links.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_links.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py</a></td>
            <td>17</td>
            <td>7</td>
            <td>58.82%</td>
            <td>19-29</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py</a></td>
            <td>295</td>
            <td>30</td>
            <td>89.83%</td>
            <td>62-88, 1833, 2243-2246</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py</a></td>
            <td>101</td>
            <td>7</td>
            <td>93.07%</td>
            <td>179-185</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_sequences.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_sequences.py</a></td>
            <td>3</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py</a></td>
            <td>38</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
        </tbody>
        <tfoot>
          <tr>
            <td>TOTAL</td>
            <td>6287</td>
            <td>1736</td>
            <td>72.39%</td>
            <td></td>
          </tr>
        </tfoot>
      </table>
<h4 id="__init__.py">__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_01_pointer.py">unittests_01_pointer.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.cythons import pointer
</span><span class="noop">
</span><span class="hit">class Test1Initialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.test_1_init_double()
</span><span class="hit">        self.test_2_init_p_double()
</span><span class="hit">        self.test_3_change_double()
</span><span class="hit">        self.test_4_change_p_double()
</span><span class="noop">
</span><span class="hit">    def test_1_init_double(self):
</span><span class="hit">        self.d = pointer.Double(2.)
</span><span class="hit">    def test_2_init_p_double(self):
</span><span class="hit">        self.p = pointer.PDouble(self.d)
</span><span class="hit">    def test_3_change_double(self):
</span><span class="hit">        self.d.setvalue(4.)
</span><span class="hit">        self.assertEqual(self.d, self.p)
</span><span class="hit">    def test_4_change_p_double(self):
</span><span class="hit">        self.p.setvalue(-3.)
</span><span class="hit">        self.assertEqual(self.d, self.p)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test2InputConversion(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.6
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_y = pointer.Double(self.f_y)
</span><span class="hit">        self.p_x = pointer.PDouble(self.d_x)
</span><span class="hit">        self.p_y = pointer.PDouble(self.d_y)
</span><span class="noop">
</span><span class="hit">    def test_double_add_float(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.f_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_float_add_double(self):
</span><span class="hit">        self.assertEqual(self.f_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_p_double_add_float(self):
</span><span class="hit">        self.assertEqual(self.p_x + self.f_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_float_add_p_double(self):
</span><span class="hit">        self.assertEqual(self.f_x + self.p_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_double_add_p_double(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.p_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_p_double_add_double(self):
</span><span class="hit">        self.assertEqual(self.p_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestRhichCompare(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_small = 2.1
</span><span class="hit">        self.f_large = 5.3
</span><span class="noop">
</span><span class="hit">    def test_small_lt_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_large,
</span><span class="noop">                         self.f_large &gt; self.f_large)
</span><span class="hit">    def test_large_lt_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &lt; self.d_small,
</span><span class="noop">                         self.f_large &lt; self.f_small)
</span><span class="hit">    def test_small_lt_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt; self.d_small,
</span><span class="noop">                         self.f_small &lt; self.f_small)
</span><span class="hit">    def test_small_le_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt;= self.d_large,
</span><span class="noop">                         self.f_small &lt;= self.f_large)
</span><span class="hit">    def test_large_le_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &lt;= self.d_small,
</span><span class="noop">                         self.f_large &lt;= self.f_small)
</span><span class="hit">    def test_small_le_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt;= self.d_small,
</span><span class="noop">                         self.f_small &lt;= self.f_small)
</span><span class="hit">    def test_small_eq_large(self):
</span><span class="hit">        self.assertEqual(self.d_small == self.d_large,
</span><span class="noop">                         self.f_small == self.f_large)
</span><span class="hit">    def test_large_eq_small(self):
</span><span class="hit">        self.assertEqual(self.d_large == self.d_small,
</span><span class="noop">                         self.f_large == self.f_small)
</span><span class="hit">    def test_small_eq_small(self):
</span><span class="hit">        self.assertEqual(self.d_small == self.d_small,
</span><span class="noop">                         self.f_small == self.f_small)
</span><span class="hit">    def test_small_gt_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_large,
</span><span class="noop">                         self.f_small &gt; self.f_large)
</span><span class="hit">    def test_large_gt_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &gt; self.d_small,
</span><span class="noop">                         self.f_large &gt; self.f_small)
</span><span class="hit">    def test_small_gt_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_small,
</span><span class="noop">                         self.f_small &gt; self.f_small)
</span><span class="hit">    def test_small_ge_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt;= self.d_large,
</span><span class="noop">                         self.f_small &gt;= self.f_large)
</span><span class="hit">    def test_large_ge_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &gt;= self.d_small,
</span><span class="noop">                         self.f_large &gt;= self.f_small)
</span><span class="hit">    def test_small_ge_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt;= self.d_small,
</span><span class="noop">                         self.f_small &gt;= self.f_small)
</span><span class="hit">    def test_small_ne_large(self):
</span><span class="hit">        self.assertEqual(self.d_small != self.d_large,
</span><span class="noop">                         self.f_small != self.f_large)
</span><span class="hit">    def test_large_ne_small(self):
</span><span class="hit">        self.assertEqual(self.d_large != self.d_small,
</span><span class="noop">                         self.f_large != self.f_small)
</span><span class="hit">    def test_small_ne_small(self):
</span><span class="hit">        self.assertEqual(self.d_small != self.d_small,
</span><span class="noop">                         self.f_small != self.f_small)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test3RhichCompareDouble(unittest.TestCase, TestRhichCompare):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestRhichCompare.setUp(self)
</span><span class="hit">        self.d_small = pointer.Double(self.f_small)
</span><span class="hit">        self.d_large = pointer.Double(self.f_large)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test4RhichComparePDouble(unittest.TestCase, TestRhichCompare):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestRhichCompare.setUp(self)
</span><span class="hit">        self._small = pointer.Double(self.f_small)
</span><span class="hit">        self._large = pointer.Double(self.f_large)
</span><span class="hit">        self.d_small = pointer.PDouble(self._small)
</span><span class="hit">        self.d_large = pointer.PDouble(self._large)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestArithmetic(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.3
</span><span class="noop">
</span><span class="hit">    def test_add(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_sub(self):
</span><span class="hit">        self.assertEqual(self.d_x - self.d_y,
</span><span class="noop">                         self.f_x - self.f_y)
</span><span class="hit">    def test_mul(self):
</span><span class="hit">        self.assertEqual(self.d_x * self.d_y,
</span><span class="noop">                         self.f_x * self.f_y)
</span><span class="hit">    def test_div(self):
</span><span class="hit">        self.assertEqual(self.d_x / self.d_y,
</span><span class="noop">                         self.f_x / self.f_y)
</span><span class="hit">    def test_floordiv(self):
</span><span class="hit">        self.assertEqual(self.d_x // self.d_y,
</span><span class="noop">                         self.f_x // self.f_y)
</span><span class="hit">    def test_truediv(self):
</span><span class="hit">        self.assertEqual(self.d_x / self.d_y,
</span><span class="noop">                         self.f_x / self.f_y)
</span><span class="hit">    def test_mod(self):
</span><span class="hit">        self.assertEqual(self.d_x % self.d_y,
</span><span class="noop">                         self.f_x % self.f_y)
</span><span class="hit">    def test_pow(self):
</span><span class="hit">        self.assertEqual(self.d_x ** self.d_y,
</span><span class="noop">                         self.f_x ** self.f_y)
</span><span class="hit">    def test_neg(self):
</span><span class="hit">        self.assertEqual(-self.d_x,
</span><span class="noop">                         -self.f_x)
</span><span class="hit">    def test_pos(self):
</span><span class="hit">        self.assertEqual(+self.d_x,
</span><span class="noop">                         +self.f_x)
</span><span class="hit">    def test_nonzero(self):
</span><span class="hit">        self.assertEqual(bool(self.d_x),
</span><span class="noop">                         bool(self.f_x))
</span><span class="hit">    def test_invert(self):
</span><span class="hit">        self.assertEqual(~self.d_x,
</span><span class="noop">                         1./self.f_x)
</span><span class="noop">
</span><span class="hit">class Test5ArithmeticDouble(unittest.TestCase, TestArithmetic):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestArithmetic.setUp(self)
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_y = pointer.Double(self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test6ArithmeticPDouble(unittest.TestCase, TestArithmetic):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestArithmetic.setUp(self)
</span><span class="hit">        self._d_x = pointer.Double(self.f_x)
</span><span class="hit">        self._d_y = pointer.Double(self.f_y)
</span><span class="hit">        self.d_x = pointer.PDouble(self._d_x)
</span><span class="hit">        self.d_y = pointer.PDouble(self._d_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestNumericConversion(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="noop">
</span><span class="hit">    def test_int(self):
</span><span class="hit">        self.assertEqual(int(self.d_x),
</span><span class="noop">                         int(self.f_x))
</span><span class="noop">
</span><span class="hit">    def test_float(self):
</span><span class="hit">        self.assertEqual(float(self.d_x),
</span><span class="noop">                         float(self.f_x))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test7NumericConversionDouble(unittest.TestCase, TestNumericConversion):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestNumericConversion.setUp(self)
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test8NumericConversionPDouble(unittest.TestCase, TestNumericConversion):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestNumericConversion.setUp(self)
</span><span class="hit">        self._d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_x = pointer.PDouble(self._d_x)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestInPlaceOperators(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.3
</span><span class="noop">
</span><span class="hit">    def test_iadd(self):
</span><span class="hit">        self.d_x += self.d_y
</span><span class="hit">        self.f_x += self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_isub(self):
</span><span class="hit">        self.d_x -= self.d_y
</span><span class="hit">        self.f_x -= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_imul(self):
</span><span class="hit">        self.d_x *= self.d_y
</span><span class="hit">        self.f_x *= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_idiv(self):
</span><span class="hit">        self.d_x /= self.d_y
</span><span class="hit">        self.f_x /= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_ifloordiv(self):
</span><span class="hit">        self.d_x //= self.d_y
</span><span class="hit">        self.f_x //= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_itruediv(self):
</span><span class="hit">        self.d_x /= self.d_y
</span><span class="hit">        self.f_x /= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_imod(self):
</span><span class="hit">        self.d_x %= self.d_y
</span><span class="hit">        self.f_x %= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="noop">
</span><span class="hit">class Test9InPlaceOperatorsDouble(unittest.TestCase, TestInPlaceOperators):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestInPlaceOperators.setUp(self)
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_y = pointer.Double(self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test10InPlaceOperatorsPDouble(unittest.TestCase, TestInPlaceOperators):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestInPlaceOperators.setUp(self)
</span><span class="hit">        self._d_x = pointer.Double(self.f_x)
</span><span class="hit">        self._d_y = pointer.Double(self.f_y)
</span><span class="hit">        self.d_x = pointer.PDouble(self._d_x)
</span><span class="hit">        self.d_y = pointer.PDouble(self._d_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_02_timetools.py">unittests_02_timetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="hit">import datetime
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="hit">class Test01DateInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.refdate_day = datetime.datetime(1996, 11, 1)
</span><span class="hit">        self.refdate_hour = datetime.datetime(1996, 11, 1, 12)
</span><span class="hit">        self.refdate_minute = datetime.datetime(1996, 11, 1, 12, 30)
</span><span class="hit">        self.refdate_second = datetime.datetime(1996, 11, 1, 12, 30, 5)
</span><span class="noop">
</span><span class="hit">    def test_01_os_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01&#39;).datetime)
</span><span class="hit">    def test_02_os_style_hour(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12&#39;).datetime)
</span><span class="hit">    def test_03_os_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12_30&#39;).datetime)
</span><span class="hit">    def test_03_os_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12_30_05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_04_iso_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01&#39;).datetime)
</span><span class="hit">    def test_05_iso_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12&#39;).datetime)
</span><span class="hit">    def test_06_iso_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12:30&#39;).datetime)
</span><span class="hit">    def test_07_iso_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12:30:05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_08_din_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996&#39;).datetime)
</span><span class="hit">    def test_09_din_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12&#39;).datetime)
</span><span class="hit">    def test_10_din_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12:30&#39;).datetime)
</span><span class="hit">    def test_11_din_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12:30:05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_11_datetime_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(self.refdate_second).datetime)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02DateProperties(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.refdate = datetime.datetime(1996, 11, 1, 12, 30, 5)
</span><span class="hit">        self.testdate = timetools.Date(self.refdate)
</span><span class="noop">
</span><span class="hit">    def test_01_get_year(self):
</span><span class="hit">        self.assertEqual(self.refdate.year, self.testdate.year)
</span><span class="hit">    def test_02_get_month(self):
</span><span class="hit">        self.assertEqual(self.refdate.month, self.testdate.month)
</span><span class="hit">    def test_03_get_day(self):
</span><span class="hit">        self.assertEqual(self.refdate.day, self.testdate.day)
</span><span class="hit">    def test_04_get_hour(self):
</span><span class="hit">        self.assertEqual(self.refdate.hour, self.testdate.hour)
</span><span class="hit">    def test_05_get_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate.minute, self.testdate.minute)
</span><span class="hit">    def test_06_get_second(self):
</span><span class="hit">        self.assertEqual(self.refdate.second, self.testdate.second)
</span><span class="noop">
</span><span class="hit">    def test_07_set_year(self):
</span><span class="hit">        self.testdate.year = 2000
</span><span class="hit">        refdate = datetime.datetime(2000, 11, 1, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.year, self.testdate.datetime.year)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.year = &#39;wrong&#39;
</span><span class="hit">    def test_08_set_month(self):
</span><span class="hit">        self.testdate.month = 5
</span><span class="hit">        refdate = datetime.datetime(1996, 5, 1, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.month, self.testdate.datetime.month)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.month = &#39;wrong&#39;
</span><span class="hit">    def test_09_set_day(self):
</span><span class="hit">        self.testdate.day = 30
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 30, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.day, self.testdate.datetime.day)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.day = &#39;wrong&#39;
</span><span class="hit">    def test_10_set_hour(self):
</span><span class="hit">        self.testdate.hour = 0
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 0, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.hour, self.testdate.datetime.hour)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.hour = &#39;wrong&#39;
</span><span class="hit">    def test_11_set_minute(self):
</span><span class="hit">        self.testdate.minute = 59
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 12, 59, 5)
</span><span class="hit">        self.assertEqual(refdate.minute, self.testdate.datetime.minute)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.minute = &#39;wrong&#39;
</span><span class="hit">    def test_12_set_second(self):
</span><span class="hit">        self.testdate.second = 7
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 12, 30, 7)
</span><span class="hit">        self.assertEqual(refdate.second, self.testdate.datetime.second)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.second = &#39;wrong&#39;
</span><span class="hit">    def test_13_get_wateryear(self):
</span><span class="hit">        self.assertEqual(self.testdate.wateryear, self.testdate.year+1)
</span><span class="hit">        self.testdate.month = 10
</span><span class="hit">        self.assertEqual(self.testdate.wateryear, self.testdate.year)
</span><span class="hit">    def test_14_set_refmonth(self):
</span><span class="hit">        self.testdate.refmonth = 3
</span><span class="hit">        self.assertEqual(self.testdate.refmonth, 3)
</span><span class="hit">        self.testdate.refmonth = &#39;July&#39;
</span><span class="hit">        self.assertEqual(self.testdate.refmonth, 7)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.refmonth = &#39;Ju&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03DateStyle(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.date = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_remember_style(self):
</span><span class="hit">        self.assertEqual(self.date.style, &#39;din&#39;)
</span><span class="hit">    def test_02_dontforget_style(self):
</span><span class="hit">        self.date.string(&#39;iso&#39;)
</span><span class="hit">        self.assertEqual(self.date.style, &#39;din&#39;)
</span><span class="hit">    def test_03_change_style(self):
</span><span class="hit">        self.date.style = &#39;iso&#39;
</span><span class="hit">        self.assertEqual(self.date.style, &#39;iso&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test04DateCopy(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.date = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_ids(self):
</span><span class="hit">        testdate = self.date.copy()
</span><span class="hit">        self.assertNotEqual(id(testdate), id(self.date))
</span><span class="hit">    def test_02_values(self):
</span><span class="hit">        testdate = self.date.copy()
</span><span class="hit">        testdate.year = 2000
</span><span class="hit">        self.assertNotEqual(testdate.datetime.year, self.date.datetime.year)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test05DateComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.early1 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.early2 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.late = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_lt(self):
</span><span class="hit">        self.assertTrue(self.early1 &lt; self.late)
</span><span class="hit">        self.assertFalse(self.early1 &lt; self.early2)
</span><span class="hit">        self.assertFalse(self.late &lt; self.early2)
</span><span class="hit">    def test_021_le(self):
</span><span class="hit">        self.assertTrue(self.early1 &lt;= self.late)
</span><span class="hit">        self.assertTrue(self.early1 &lt;= self.early2)
</span><span class="hit">        self.assertFalse(self.late &lt;= self.early2)
</span><span class="hit">    def test_03_eq(self):
</span><span class="hit">        self.assertFalse(self.early1 == self.late)
</span><span class="hit">        self.assertTrue(self.early1 == self.early2)
</span><span class="hit">        self.assertFalse(self.late == self.early2)
</span><span class="hit">    def test_04_ne(self):
</span><span class="hit">        self.assertTrue(self.early1 != self.late)
</span><span class="hit">        self.assertFalse(self.early1 != self.early2)
</span><span class="hit">        self.assertTrue(self.late != self.early2)
</span><span class="hit">    def test_05_gt(self):
</span><span class="hit">        self.assertFalse(self.early1 &gt; self.late)
</span><span class="hit">        self.assertFalse(self.early1 &gt; self.early2)
</span><span class="hit">        self.assertTrue(self.late &gt; self.early2)
</span><span class="hit">    def test_06_ge(self):
</span><span class="hit">        self.assertFalse(self.early1 &gt;= self.late)
</span><span class="hit">        self.assertTrue(self.early1 &gt;= self.early2)
</span><span class="hit">        self.assertTrue(self.late &gt;= self.early2)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test06DateArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.earlydate = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.latedate = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.period = timetools.Period(&#39;365d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_add(self):
</span><span class="hit">        testdate = self.earlydate + self.period
</span><span class="hit">        self.assertEqual(self.latedate, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        self.earlydate += self.period
</span><span class="hit">        self.assertEqual(self.earlydate, self.latedate)
</span><span class="hit">        self.assertEqual(self.earlydate.style, &#39;din&#39;)
</span><span class="hit">    def test_03_sub(self):
</span><span class="hit">        testdate = self.latedate - self.period
</span><span class="hit">        self.assertEqual(self.earlydate, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">    def test_04_isub(self):
</span><span class="hit">        self.latedate -= self.period
</span><span class="hit">        self.assertEqual(self.latedate, self.earlydate)
</span><span class="hit">        self.assertEqual(self.latedate.style, &#39;din&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test07PeriodInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def test_01_string_day(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(1),
</span><span class="noop">                         timetools.Period(&#39;1d&#39;).timedelta)
</span><span class="hit">        self.assertEqual(datetime.timedelta(365),
</span><span class="noop">                         timetools.Period(&#39;365d&#39;).timedelta)
</span><span class="hit">    def test_02_string_hour(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 60*60),
</span><span class="noop">                         timetools.Period(&#39;1h&#39;).timedelta)
</span><span class="hit">    def test_03_string_minute(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 60),
</span><span class="noop">                         timetools.Period(&#39;1m&#39;).timedelta)
</span><span class="hit">    def test_04_string_second(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 1),
</span><span class="noop">                         timetools.Period(&#39;1s&#39;).timedelta)
</span><span class="hit">    def test_05_timedelta(self):
</span><span class="hit">        timedelta = datetime.timedelta(365)
</span><span class="hit">        self.assertEqual(timedelta, timetools.Period(timedelta).timedelta)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test08PeriodProperties(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        seconds = int(60*60*24*365*3.2)
</span><span class="hit">        self.refperiod = datetime.timedelta(0, seconds)
</span><span class="hit">        self.testperiod = timetools.Period(&#39;%ds&#39; % seconds)
</span><span class="noop">
</span><span class="hit">    def test_01_get_days(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60/60/24,
</span><span class="noop">                         self.testperiod.days)
</span><span class="hit">    def test_02_get_hours(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60/60,
</span><span class="noop">                         self.testperiod.hours)
</span><span class="hit">    def test_03_get_minutes(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60,
</span><span class="noop">                         self.testperiod.minutes)
</span><span class="hit">    def test_04_get_seconds(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds(),
</span><span class="noop">                         self.testperiod.seconds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test09PeriodUnit(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def test_01_day(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;365d&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1d&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;24h&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1440m&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;86400m&#39;).unit, &#39;d&#39;)
</span><span class="hit">    def test_02_hour(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;25h&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1h&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;60m&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;3600s&#39;).unit, &#39;h&#39;)
</span><span class="hit">    def test_03_minute(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;777m&#39;).unit, &#39;m&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1m&#39;).unit, &#39;m&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;60s&#39;).unit, &#39;m&#39;)
</span><span class="hit">    def test_04_second(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;999s&#39;).unit, &#39;s&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1s&#39;).unit, &#39;s&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test10PeriodCopy(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.period = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_ids(self):
</span><span class="hit">        testperiod = self.period.copy()
</span><span class="hit">        self.assertNotEqual(id(testperiod), id(self.period))
</span><span class="hit">    def test_02_values(self):
</span><span class="hit">        testperiod = self.period.copy()
</span><span class="hit">        testperiod += &#39;1d&#39;
</span><span class="hit">        self.assertNotEqual(testperiod.timedelta,
</span><span class="noop">                            self.period.timedelta)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test11PeriodComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.short1 = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.short2 = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.long = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_lt(self):
</span><span class="hit">        self.assertTrue(self.short1 &lt; self.long)
</span><span class="hit">        self.assertFalse(self.short1 &lt; self.short2)
</span><span class="hit">        self.assertFalse(self.long &lt; self.short2)
</span><span class="hit">    def test_021_le(self):
</span><span class="hit">        self.assertTrue(self.short1 &lt;= self.long)
</span><span class="hit">        self.assertTrue(self.short1 &lt;= self.short2)
</span><span class="hit">        self.assertFalse(self.long &lt;= self.short2)
</span><span class="hit">    def test_03_eq(self):
</span><span class="hit">        self.assertFalse(self.short1 == self.long)
</span><span class="hit">        self.assertTrue(self.short1 == self.short2)
</span><span class="hit">        self.assertFalse(self.long == self.short2)
</span><span class="hit">    def test_04_ne(self):
</span><span class="hit">        self.assertTrue(self.short1 != self.long)
</span><span class="hit">        self.assertFalse(self.short1 != self.short2)
</span><span class="hit">        self.assertTrue(self.long != self.short2)
</span><span class="hit">    def test_05_gt(self):
</span><span class="hit">        self.assertFalse(self.short1 &gt; self.long)
</span><span class="hit">        self.assertFalse(self.short1 &gt; self.short2)
</span><span class="hit">        self.assertTrue(self.long &gt; self.short2)
</span><span class="hit">    def test_06_ge(self):
</span><span class="hit">        self.assertFalse(self.short1 &gt;= self.long)
</span><span class="hit">        self.assertTrue(self.short1 &gt;= self.short2)
</span><span class="hit">        self.assertTrue(self.long &gt;= self.short2)
</span><span class="noop">#    def test_07_true(self):
</span><span class="noop">#        self.assertTrue(self.short1)
</span><span class="noop">#        self.assertTrue(self.long)
</span><span class="noop">#        self.assertFalse(timetools.Period(&#39;0d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test12PeriodArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneyear = timetools.Period(&#39;365d&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_add(self):
</span><span class="hit">        testdate = self.oneyear + self.year97
</span><span class="hit">        self.assertEqual(self.year98, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">        self.assertEqual(self.oneyear + self.oneday, timetools.Period(&#39;366d&#39;))
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        self.oneyear += self.oneday
</span><span class="hit">        self.assertEqual(self.oneyear, timetools.Period(&#39;366d&#39;))
</span><span class="hit">    def test_03_sub(self):
</span><span class="hit">        testdate = self.year98 - self.oneyear
</span><span class="hit">        self.assertEqual(self.year97, testdate)
</span><span class="hit">    def test_04_isub(self):
</span><span class="hit">        self.oneyear -= self.oneday
</span><span class="hit">        self.assertEqual(self.oneyear, timetools.Period(&#39;364d&#39;))
</span><span class="hit">    def test_05_mul(self):
</span><span class="hit">        testperiod = self.oneday * 365
</span><span class="hit">        self.assertEqual(testperiod, self.oneyear)
</span><span class="hit">    def test_06_rmul(self):
</span><span class="hit">        testperiod = 365 * self.oneday
</span><span class="hit">        self.assertEqual(testperiod, self.oneyear)
</span><span class="hit">    def test_07_imul(self):
</span><span class="hit">        self.oneday *= 365
</span><span class="hit">        self.assertEqual(self.oneday, self.oneyear)
</span><span class="hit">    def test_08_div(self):
</span><span class="hit">        testperiod = self.oneyear / self.oneday
</span><span class="hit">        self.assertEqual(testperiod, 365)
</span><span class="hit">        testinteger = self.oneyear / 365
</span><span class="hit">        self.assertEqual(testinteger, self.oneday)
</span><span class="hit">    def test_09_idiv(self):
</span><span class="hit">        self.oneyear /= 365
</span><span class="hit">        self.assertEqual(self.oneyear,  self.oneday)
</span><span class="hit">    def test_10_mod(self):
</span><span class="hit">        self.assertFalse(self.oneyear % self.oneday)
</span><span class="hit">        self.assertTrue(self.oneyear % timetools.Period(&#39;360d&#39;))
</span><span class="hit">    def test_11_floordiv(self):
</span><span class="hit">        self.assertTrue(self.oneyear // self.oneday)
</span><span class="hit">        self.assertFalse(self.oneyear // timetools.Period(&#39;360d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test13TimegridInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_right(self):
</span><span class="hit">        timetools.Timegrid(self.year97, self.year98, self.oneday)
</span><span class="hit">    def test_02_wrong(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year97, self.year97, self.oneday)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year98, self.year97, self.oneday)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                               timetools.Period(&#39;360d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test14TimegridIterable(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="hit">        self.timegrid = timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                                           self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_01_indexing_with_integers(self):
</span><span class="hit">        self.assertEqual(self.timegrid[0], self.year97)
</span><span class="hit">        self.assertEqual(self.timegrid[365], self.year98)
</span><span class="hit">        self.assertEqual(self.timegrid[1], self.year97+self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[-1], self.year97-self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[366], self.year98+self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[364], self.year98-self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_02_indexing_with_dates(self):
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97], 0)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98], 365)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97+self.oneday], 1)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97-self.oneday], -1)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98+self.oneday], 366)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98-self.oneday], 364)
</span><span class="noop">
</span><span class="hit">    def test_03_indexing_errors(self):
</span><span class="hit">        with self.assertRaises(TypeError):
</span><span class="hit">            self.timegrid[0.]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.timegrid[self.year97 + &#39;1m&#39;]
</span><span class="noop">
</span><span class="hit">    def test_04_iteration(self):
</span><span class="hit">        self.assertEqual(list(self.timegrid)[1], self.year97+self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_05_len(self):
</span><span class="hit">        self.assertEqual(len(self.timegrid), 365)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test15TimegridComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="hit">        self.onehour = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.timegrid = timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                                           self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_01_eq(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertTrue(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest.firstdate.year = 1995
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate.year = 1998
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize = self.onehour
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_02_ne(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertFalse(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest.firstdate.year = 1995
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate.year = 1998
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize = self.onehour
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_03_date_in(self):
</span><span class="hit">        self.assertTrue(self.year97 in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year98 in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year97+&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97-&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year98-&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98+&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97+&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97-&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98-&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98+&#39;12h&#39; in self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_04_timegrid_in(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertTrue(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest.firstdate -= &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate += &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.firstdate -= &#39;1d&#39;
</span><span class="hit">        timegridtest.lastdate += &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.firstdate += &#39;12h&#39;
</span><span class="hit">        timegridtest.lastdate -= &#39;12d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertFalse(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize /= 24
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertFalse(self.timegrid in timegridtest)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_03_filetools.py">unittests_03_filetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="noop">#from __future__ import division, print_function
</span><span class="noop">#import os
</span><span class="noop">#import unittest
</span><span class="noop">## ...from HydPy
</span><span class="noop">#from hydpy.core import filetools
</span><span class="noop">#from hydpy import pub
</span><span class="noop">#
</span><span class="noop">#PROJECTNAME = &#39;projectnamemock&#39;
</span><span class="noop">#
</span><span class="noop">#class NetworkFileMock(filetools.NetworkFile):
</span><span class="noop">#    def checkpath(self):
</span><span class="noop">#        pass
</span><span class="noop">#
</span><span class="noop">#class Test02NetwortFile(unittest.TestCase):
</span><span class="noop">#
</span><span class="noop">#    def setUp(self):
</span><span class="noop">#        pub.projectname = PROJECTNAME
</span><span class="noop">#        self.testdirectory = os.path.abspath(&#39;controlfiles&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_01_getdirectory(self):
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        self.assertEqual(networkfile.directory, self.testdirectory)
</span><span class="noop">#
</span><span class="noop">#    def test_02_getfilename(self):
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        self.assertEqual(networkfile.filename, PROJECTNAME+&#39;_network.py&#39;)
</span><span class="noop">#        networkfile._filename = &#39;testname&#39;
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_03_setwrongfilename(self):
</span><span class="noop">#        with self.assertRaises(IOError):
</span><span class="noop">#             filetools.NetworkFile(&#39;testname&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_04_setcorrectfilename(self):
</span><span class="noop">#        networkfile = NetworkFileMock(&#39;testname&#39;)
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#        networkfile = NetworkFileMock(&#39;testname.py&#39;)
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#        networkfile.filename = None
</span><span class="noop">#        self.assertEqual(networkfile.filename, PROJECTNAME+&#39;_network.py&#39;)
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        networkfile.filename = &#39;testname&#39;
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_5_savefile(self):
</span><span class="noop">#        pass
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_04_devicetools.py">unittests_04_devicetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">sys.path.insert(0, &#39;..\\..\\..\\HydPy&#39;)
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.connectiontools import *
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test01NodeCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_fromstring(self):
</span><span class="hit">        test1a = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1a, Node)
</span><span class="hit">        self.assertEqual(test1a.name, &#39;test1&#39;)
</span><span class="hit">        test1b = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIs(test1a, test1b)
</span><span class="hit">        test2 = Node(&#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1a, test2)
</span><span class="hit">    def test_02_fromnode(self):
</span><span class="hit">        test1 = Node(&#39;test&#39;)
</span><span class="hit">        test2 = Node(test1)
</span><span class="hit">        self.assertIsInstance(test2, Node)
</span><span class="hit">        self.assertIs(test1, test2)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Node([test1, test2])
</span><span class="hit">    def test_03_fromwronginput(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node([&#39;test&#39;])
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node(5)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node({&#39;test&#39;: &#39;test&#39;})
</span><span class="hit">    def test_04_attributes(self):
</span><span class="hit">        test1 = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1.entries, Connections)
</span><span class="hit">        self.assertIsInstance(test1.exits, Connections)
</span><span class="hit">        self.assertEqual(test1.variable, &#39;Q&#39;)
</span><span class="hit">        test2 = Node(&#39;test2&#39;, &#39;T&#39;)
</span><span class="hit">        self.assertIsInstance(test2.entries, Connections)
</span><span class="hit">        self.assertIsInstance(test2.exits, Connections)
</span><span class="hit">        self.assertEqual(test2.variable, &#39;T&#39;)
</span><span class="hit">    def test_03_wrongredefinition(self):
</span><span class="hit">        test = Node(&#39;test&#39;)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Node(&#39;test&#39;, &#39;T&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02ElementCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_fromstring(self):
</span><span class="hit">        test1a = Element(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1a, Element)
</span><span class="hit">        self.assertEqual(test1a.name, &#39;test1&#39;)
</span><span class="hit">        test1b = Element(&#39;test1&#39;)
</span><span class="hit">        self.assertIs(test1a, test1b)
</span><span class="hit">        test2 = Element(&#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1a, test2)
</span><span class="hit">    def test_02_fromelement(self):
</span><span class="hit">        test1 = Element(&#39;test&#39;)
</span><span class="hit">        test2 = Element(test1)
</span><span class="hit">        self.assertIsInstance(test2, Element)
</span><span class="hit">        self.assertIs(test1, test2)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element([test1, test2])
</span><span class="hit">    def test_03_fromwronginput(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element([&#39;test&#39;])
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element(5)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element({&#39;test&#39;: &#39;test&#39;})
</span><span class="hit">    def test_04_attributes(self):
</span><span class="hit">        test = Element(&#39;test&#39;)
</span><span class="hit">        self.assertIsInstance(test.inlets, Connections)
</span><span class="hit">        self.assertIsInstance(test.outlets, Connections)
</span><span class="hit">        self.assertIsInstance(test.receivers, Connections)
</span><span class="hit">        self.assertIsInstance(test.senders, Connections)
</span><span class="hit">        self.assertIsNone(test.model)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03ElementInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.n1Q = Node(&#39;n1Q&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n2Q = Node(&#39;n2Q&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n3W = Node(&#39;n3W&#39;, &#39;W&#39;)
</span><span class="hit">        self.n4T = Node(&#39;n4T&#39;, &#39;T&#39;)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_inlet(self):
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.exits.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.exits.e, e)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n1Q)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n4T)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.inlets.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n3W)
</span><span class="hit">        self.assertIs(e.inlets.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, outlets=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, inlets=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_02_outlet(self):
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.entries.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.entries.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n1Q)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n4T)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.outlets.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n3W)
</span><span class="hit">        self.assertIs(e.outlets.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, inlets=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, outlets=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_03_receiver(self):
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.exits.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.exits.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n1Q)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n4T)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.receivers.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n3W)
</span><span class="hit">        self.assertIs(e.receivers.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, senders=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, receivers=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_04_sender(self):
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.entries.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.entries.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n1Q)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n4T)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.senders.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n3W)
</span><span class="hit">        self.assertIs(e.senders.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, receivers=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, senders=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_05_inletandoutlet(self):
</span><span class="hit">        e1 = Element(&#39;e1&#39;, inlets=self.n1Q, outlets=self.n2Q)
</span><span class="hit">        self.assertIs(e1.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e1.outlets.n2Q, self.n2Q)
</span><span class="hit">        e2 = Element(&#39;e2&#39;, inlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e2&#39;, outlets=self.n1Q)
</span><span class="hit">        e3 = Element(&#39;e3&#39;, outlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e3&#39;, inlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e4&#39;, inlets=self.n1Q, outlets=self.n1Q)
</span><span class="noop">
</span><span class="hit">    def test_06_receiverandsender(self):
</span><span class="hit">        e1 = Element(&#39;e1&#39;, receivers=self.n1Q, senders=self.n2Q)
</span><span class="hit">        self.assertIs(e1.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e1.senders.n2Q, self.n2Q)
</span><span class="hit">        e2 = Element(&#39;e2&#39;, receivers=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e2&#39;, senders=self.n1Q)
</span><span class="hit">        e3 = Element(&#39;e3&#39;, senders=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e3&#39;, receivers=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e4&#39;, receivers=self.n1Q, senders=self.n1Q)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">#class Test04NodesCreation(unittest.TestCase):
</span><span class="noop">#
</span><span class="noop">#    def setUp(self):
</span><span class="noop">#        asdf
</span><span class="noop">
</span><span class="hit">class Test05ElementsCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.element1 = Element(&#39;element1&#39;)
</span><span class="hit">        self.element2 = Element(&#39;element2&#39;)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_00_fromnone(self):
</span><span class="hit">        test = Elements(None)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="noop">
</span><span class="hit">    def test_01_fromelements(self):
</span><span class="hit">        test = Elements(self.element1)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(self.element1, self.element2)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_02_fromstrings(self):
</span><span class="hit">        test = Elements(&#39;element1&#39;)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(&#39;element1&#39;, &#39;element2&#39;)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_03_fromelements(self):
</span><span class="hit">        test1 = Elements(&#39;element1&#39;)
</span><span class="hit">        test2 = Elements(test1)
</span><span class="hit">        self.assertIsInstance(test2, Elements)
</span><span class="noop">
</span><span class="hit">    def test_04_fromemptycontainer(self):
</span><span class="hit">        test = Elements([])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="noop">
</span><span class="hit">    def test_05_fromcontaineredelements1(self):
</span><span class="hit">        test = Elements([self.element1])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements([self.element1, self.element2])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_06_fromcontaineredelements1(self):
</span><span class="hit">        test = Elements(Elements([self.element1]))
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(Elements([self.element1, self.element2]))
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_07_fromcontaineredstrings(self):
</span><span class="hit">        test = Elements([&#39;element1&#39;])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements([&#39;element1&#39;, &#39;element2&#39;])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_07_fromwrongtype(self):
</span><span class="hit">        with self.assertRaises(TypeError):
</span><span class="hit">            Elements(1.)
</span><span class="noop">
</span><span class="hit">class Test06ElementsArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.element1 = Element(&#39;element1&#39;)
</span><span class="hit">        self.element2 = Element(&#39;element2&#39;)
</span><span class="hit">        self.element3 = Element(&#39;element3&#39;)
</span><span class="hit">        self.element4 = Element(&#39;element3&#39;)
</span><span class="hit">        self.elements12 = Elements(self.element1, self.element2)
</span><span class="hit">        self.elements34 = Elements(self.element3, self.element4)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_iadd_element(self):
</span><span class="hit">        self.elements12 += self.element3
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_02_iadd_elements(self):
</span><span class="hit">        self.elements12 += self.elements34
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_03a_iadd_emptylist(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        self.elements12 += []
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">    def test_04a_iadd_elementlist(self):
</span><span class="hit">        self.elements12 += [self.element3]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_04b_iadd_elementlist(self):
</span><span class="hit">        self.elements12 += [self.element3, self.element4]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_05a_iadd_stringlist(self):
</span><span class="hit">        self.elements12 += [&#39;element3&#39;]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_05b_iadd_stringlist(self):
</span><span class="hit">        self.elements12 += [&#39;element3&#39;, &#39;element4&#39;]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="noop">
</span><span class="hit">    def test_06_isub_element(self):
</span><span class="hit">        self.elements12 -= self.element2
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            self.elements12.element2
</span><span class="noop">
</span><span class="hit">    def test_07_add_element(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        elements123 = self.elements12 + self.element3
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">        self.assertIsInstance(elements123, Elements)
</span><span class="hit">        self.assertIs(elements123.element1, self.element1)
</span><span class="hit">        self.assertIs(elements123.element3, self.element3)
</span><span class="noop">
</span><span class="hit">    def test_08_sub_element(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        elements1 = self.elements12 - self.element2
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">        self.assertIsInstance(elements1, Elements)
</span><span class="hit">        self.assertIs(elements1.element1, self.element1)
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            self.elements1.element2
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test07ElementsComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_bool(self):
</span><span class="hit">        self.assertFalse(Elements())
</span><span class="hit">        self.assertTrue(Elements(&#39;a&#39;))
</span><span class="hit">        self.assertTrue(Elements(&#39;a&#39;, &#39;b&#39;))</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_05_connectiontools.py">unittests_05_connectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.connectiontools import *
</span><span class="noop">
</span><span class="hit">class Test01Connections(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.cons = Connections(None)
</span><span class="hit">        setattr(self.cons, &#39;test1&#39;, 1)
</span><span class="hit">        setattr(self.cons, &#39;test2&#39;, 2)
</span><span class="noop">
</span><span class="hit">    def test_01_properties(self):
</span><span class="hit">        self.assertListEqual(sorted(self.cons.names), [&#39;test1&#39;, &#39;test2&#39;])
</span><span class="hit">        self.assertListEqual(sorted(self.cons.slaves), [1, 2])
</span><span class="hit">    def test_02_contains(self):
</span><span class="hit">        self.assertTrue(&#39;test1&#39; in self.cons)
</span><span class="hit">        self.assertTrue(&#39;test2&#39; in self.cons)
</span><span class="hit">        self.assertTrue(1 in self.cons)
</span><span class="hit">        self.assertTrue(2 in self.cons)
</span><span class="hit">    def test_03_iterable(self):
</span><span class="hit">        names, cons = [], []
</span><span class="hit">        for (name, con) in self.cons:
</span><span class="hit">            names.append(name)
</span><span class="hit">            cons.append(con)
</span><span class="hit">        self.assertListEqual(sorted(names), [&#39;test1&#39;, &#39;test2&#39;])
</span><span class="hit">        self.assertListEqual(sorted(cons), [1, 2])
</span><span class="noop">
</span><span class="hit">class Test01Self2Node(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_iadd(self):
</span><span class="hit">        test = Connections(None)
</span><span class="hit">        n1 = Node(&#39;n1&#39;, &#39;Q&#39;)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertIsInstance(test, Connections)
</span><span class="hit">        self.assertIsInstance(test.n1, Node)
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertIsInstance(test, Connections)
</span><span class="hit">        self.assertIsInstance(test.n1, Node)
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        n2 = Node(&#39;n2&#39;, &#39;T&#39;)
</span><span class="hit">        test += n2
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        self.assertIs(test.n2, n2)
</span><span class="noop">
</span><span class="hit">    def test_02_variables(self):
</span><span class="hit">        test = Connections(None)
</span><span class="hit">        self.assertListEqual(test.variables, [])
</span><span class="hit">        n1 = Node(&#39;n1&#39;, &#39;Q&#39;)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertListEqual(test.variables, [&#39;Q&#39;])
</span><span class="hit">        n2 = Node(&#39;n2&#39;, &#39;T&#39;)
</span><span class="hit">        test += n2
</span><span class="hit">        self.assertListEqual(sorted(test.variables), [&#39;Q&#39;, &#39;T&#39;])
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            test.X</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_06_selectiontools.py">unittests_06_selectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.selectiontools import *
</span><span class="noop">
</span><span class="hit">class Test01SelectionInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_empty(self):
</span><span class="hit">        test = Selection(&#39;test&#39;)
</span><span class="hit">        self.assertIsInstance(test, Selection)
</span><span class="hit">        self.assertIsInstance(test.nodes, Nodes)
</span><span class="hit">        self.assertIsInstance(test.elements, Elements)
</span><span class="hit">        self.assertFalse(bool(test))
</span><span class="hit">    def test_02_nonempty(self):
</span><span class="hit">        test = Selection(&#39;test&#39;, nodes=&#39;a&#39;, elements=(&#39;b&#39;, &#39;c&#39;))
</span><span class="hit">        self.assertIsInstance(test, Selection)
</span><span class="hit">        self.assertIsInstance(test.nodes, Nodes)
</span><span class="hit">        self.assertIsInstance(test.elements, Elements)
</span><span class="hit">        self.assertEqual(test.nodes.a.name, &#39;a&#39;)
</span><span class="hit">        self.assertEqual(test.elements.b.name, &#39;b&#39;)
</span><span class="hit">        self.assertEqual(test.elements.c.name, &#39;c&#39;)
</span><span class="hit">        self.assertTrue(bool(test))
</span><span class="hit">    def test_03_copy(self):
</span><span class="hit">        test1 = Selection(&#39;test1&#39;, nodes=&#39;a&#39;, elements=(&#39;b&#39;, &#39;c&#39;))
</span><span class="hit">        test2 = test1.copy(&#39;test2&#39;)
</span><span class="hit">        self.assertIsInstance(test2, Selection)
</span><span class="hit">        self.assertEqual(test2.name, &#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1, test2)
</span><span class="hit">        self.assertEqual(test2.nodes, test1.nodes)
</span><span class="hit">        self.assertEqual(test2.elements, test1.elements)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02SelectionSelect(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="noop">        # e1 + e2 -&gt; n_Q1 -&gt; e3 -&gt; n_Q2 -&gt; e4 + (e7 -&gt; n_Q4 -&gt; e6)-&gt; n_Q3
</span><span class="noop">        # e1 + e2 -&gt; n_T1 -&gt; e3 -&gt; n_T2 -&gt; e5 -&gt; n_T3
</span><span class="hit">        self.n_Q1 = Node(&#39;n_Q1&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n_T1 = Node(&#39;n_T1&#39;, &#39;T&#39;)
</span><span class="hit">        self.e1 = Element(&#39;e1&#39;, outlets=&#39;n_Q1&#39;)
</span><span class="hit">        self.e1 = Element(&#39;e1&#39;, outlets=&#39;n_T1&#39;)
</span><span class="hit">        self.e2 = Element(&#39;e2&#39;, outlets=&#39;n_Q1&#39;)
</span><span class="hit">        self.e2 = Element(&#39;e2&#39;, outlets=&#39;n_T1&#39;)
</span><span class="hit">        self.n_Q2 = Node(&#39;n_Q2&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n_T2 = Node(&#39;n_T2&#39;, &#39;T&#39;)
</span><span class="hit">        self.e3 = Element(&#39;e3&#39;, inlets=&#39;n_Q1&#39;, outlets=&#39;n_Q2&#39;)
</span><span class="hit">        self.e3 = Element(&#39;e3&#39;, inlets=&#39;n_T1&#39;, outlets=&#39;n_T2&#39;)
</span><span class="hit">        self.n_Q3 = Node(&#39;n_Q3&#39;, &#39;Q&#39;)
</span><span class="hit">        self.e4 = Element(&#39;e4&#39;, inlets=&#39;n_Q2&#39;, outlets=&#39;n_Q3&#39;)
</span><span class="hit">        self.n_T3 = Node(&#39;n_T3&#39;, &#39;T&#39;)
</span><span class="hit">        self.e5 = Element(&#39;e5&#39;, inlets=&#39;n_T2&#39;, outlets=&#39;n_T3&#39;)
</span><span class="hit">        self.n_Q4 = Node(&#39;n_Q4&#39;, &#39;Q&#39;)
</span><span class="hit">        self.e6 = Element(&#39;e6&#39;, inlets=&#39;n_Q4&#39;, outlets=&#39;n_Q3&#39;)
</span><span class="hit">        self.e7 = Element(&#39;e7&#39;, outlets=&#39;n_Q4&#39;)
</span><span class="noop">
</span><span class="hit">        self.complete = Selection(&#39;complete&#39;,
</span><span class="noop">                                  nodes=Node.registerednodes(),
</span><span class="noop">                                  elements=Element.registeredelements())
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_nextelement(self):
</span><span class="hit">        nodes, elements = self.complete._nextelement(self.e1,
</span><span class="noop">                                                  Nodes(), Elements())
</span><span class="hit">        self.assertEqual(nodes, Nodes())
</span><span class="hit">        self.assertEqual(elements, Elements(self.e1))
</span><span class="hit">    def test_02_nextnode(self):
</span><span class="hit">        nodes, elements = self.complete._nextnode(self.n_Q1,
</span><span class="noop">                                                  Nodes(), Elements())
</span><span class="hit">        self.assertEqual(nodes, Nodes(self.n_Q1))
</span><span class="hit">        self.assertEqual(elements, Elements(self.e1, self.e2))
</span><span class="hit">    def test_03_select_upstream(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_upstream(self.n_Q3)
</span><span class="hit">        reference = self.complete.copy(&#39;reference&#39;)
</span><span class="hit">        del(reference.elements.e5)
</span><span class="hit">        del(reference.nodes.n_T2)
</span><span class="hit">        del(reference.nodes.n_T3)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_04_deselect_upstream(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_upstream(self.n_Q3)
</span><span class="hit">        reference = Selection(&#39;reference&#39;, [&#39;n_T2&#39;, &#39;n_T3&#39;], &#39;e5&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="noop">
</span><span class="noop">#    def test_05_selectmodelclasses(self):
</span><span class="noop">#        with self.assertRaises(RuntimeError):
</span><span class="noop">#            self.complete.copy(&#39;test&#39;).getby_modelclasses(&#39;HBV96_zone&#39;)
</span><span class="noop">
</span><span class="hit">    def test_06_select_nodenames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_nodenames(&#39;n_Q1&#39;, &#39;n_T&#39;, &#39;NO&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        reference.nodes = Nodes(&#39;n_Q1&#39;, &#39;n_T1&#39;, &#39;n_T2&#39;, &#39;n_T3&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_07_deselect_nodenames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_nodenames(&#39;n_Q1&#39;, &#39;n_T&#39;,
</span><span class="noop">                                                             &#39;NO&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        del(reference.nodes.n_Q1)
</span><span class="hit">        del(reference.nodes.n_T1)
</span><span class="hit">        del(reference.nodes.n_T2)
</span><span class="hit">        del(reference.nodes.n_T3)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_08_select_elementnames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_elementnames(&#39;e&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, self.complete.nodes)
</span><span class="hit">        self.assertEqual(test.elements, self.complete.elements)
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_elementnames(&#39;2&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        reference.elements = Elements(&#39;e2&#39;)
</span><span class="hit">    def test_09_deselect_elementnames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_elementnames(&#39;e&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, self.complete.nodes)
</span><span class="hit">        self.assertEqual(test.elements, Elements())
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_elementnames(&#39;2&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        del(reference.elements.e2)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03SelectionMagic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_len(self):
</span><span class="hit">        test1 = Selection(&#39;test1&#39;, [&#39;n1&#39;, &#39;n2&#39;], [])
</span><span class="hit">        self.assertEqual(len(test1), 2)
</span><span class="hit">        test2 = Selection(&#39;test2&#39;, [], [&#39;e1&#39;])
</span><span class="hit">        self.assertEqual(len(test2), 1)
</span><span class="noop">
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        test = Selection(&#39;sel&#39;,
</span><span class="noop">                         [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;],
</span><span class="noop">                         [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test += Selection(&#39;add&#39;, [&#39;n3&#39;, &#39;n4&#39;], [])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;, &#39;n4&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">        test += Selection(&#39;add&#39;, [], [&#39;e4&#39;, &#39;e5&#39;])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;, &#39;n4&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;, &#39;e4&#39;, &#39;e5&#39;])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_03_isub(self):
</span><span class="hit">        test = Selection(&#39;sel&#39;,
</span><span class="noop">                         [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;],
</span><span class="noop">                         [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test -= Selection(&#39;sub&#39;, [&#39;n3&#39;, &#39;n4&#39;], [])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test -= Selection(&#39;sub&#39;, [], [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;],
</span><span class="noop">                              [])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_07_parametertools.py">unittests_07_parametertools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Created on Thu Dec 01 10:53:44 2016
</span><span class="noop">
</span><span class="noop">@author: tyralla
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_08_indextools.py">unittests_08_indextools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import indextools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="hit">class Test01MonthOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.monthofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.monthofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.monthofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.monthofyear = [1,2]
</span><span class="hit">        self.assertIsInstance(self.indexer.monthofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.monthofyear), (1, 2))
</span><span class="hit">        del(self.indexer.monthofyear)
</span><span class="hit">        self.assertIsNone(self.indexer._monthofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.monthofyear = [1,2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.monthofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.monthofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.monthofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.monthofyear),
</span><span class="noop">                              tuple(31*[0]+29*[1]+31*[2]+30*[3]+
</span><span class="noop">                                    31*[4]+30*[5]+31*[6]+31*[7]+
</span><span class="noop">                                    30*[8]+31*[9]+30*[10]+31*[11]))
</span><span class="hit">        self.assertIs(self.indexer.monthofyear, self.indexer.monthofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02DayOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.dayofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.dayofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.dayofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.dayofyear = [1,2]
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.dayofyear), (1, 2))
</span><span class="hit">        del self.indexer.dayofyear
</span><span class="hit">        self.assertIsNone(self.indexer._dayofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.dayofyear = [1,2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.dayofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.dayofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.dayofyear),
</span><span class="noop">                              tuple(range(366)))
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2005&#39;,
</span><span class="noop">                                                               &#39;1.01.2006&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        del self.indexer.dayofyear
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.dayofyear), 365)
</span><span class="hit">        self.assertTupleEqual(
</span><span class="noop">           tuple(self.indexer.dayofyear),
</span><span class="noop">           tuple(list(range(31+28))+list(range(31+28+1, 366)))
</span><span class="noop">           )
</span><span class="hit">        self.assertIs(self.indexer.dayofyear, self.indexer.dayofyear)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">&#34;&#34;&#34;
</span><span class="noop">HydPy
</span><span class="noop">
</span><span class="noop">An interactive framework for the developement and a application of
</span><span class="noop">hydrological models.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">from hydpy.core.hydpytools import HydPy
</span><span class="hit">from hydpy.core.timetools import Date
</span><span class="hit">from hydpy.core.timetools import Period
</span><span class="hit">from hydpy.core.timetools import Timegrid
</span><span class="hit">from hydpy.core.timetools import Timegrids
</span><span class="hit">from hydpy.core.filetools import MainManager
</span><span class="hit">from hydpy.core.filetools import NetworkManager
</span><span class="hit">from hydpy.core.filetools import ControlManager
</span><span class="hit">from hydpy.core.filetools import SequenceManager
</span><span class="hit">from hydpy.core.filetools import ConditionManager
</span><span class="hit">from hydpy.core.devicetools import Node
</span><span class="hit">from hydpy.core.devicetools import Nodes
</span><span class="hit">from hydpy.core.devicetools import Element
</span><span class="hit">from hydpy.core.devicetools import Elements
</span><span class="hit">from hydpy.core.selectiontools import Selection
</span><span class="hit">from hydpy.core.selectiontools import Selections
</span><span class="hit">from hydpy import pub
</span><span class="noop">
</span><span class="hit">import warnings
</span><span class="hit">import sys
</span><span class="hit">warnings.filterwarnings(&#39;ignore&#39;, r&#39;All-NaN (slice|axis) encountered&#39;)
</span><span class="hit">def customwarn(message, category, filename, lineno, file=None, line=None):
</span><span class="miss">    sys.stdout.write(warnings.formatwarning(message, category, filename, lineno))
</span><span class="hit">warnings.showwarning = customwarn
</span><span class="noop">
</span><span class="hit">__all__ = [&#39;HydPy&#39;, &#39;pub&#39;,
</span><span class="noop">           &#39;Date&#39;, &#39;Period&#39;, &#39;Timegrid&#39;, &#39;Timegrids&#39;,
</span><span class="noop">           &#39;MainManager&#39;, &#39;NetworkManager&#39;, &#39;ControlManager&#39;,
</span><span class="noop">           &#39;SequenceManager&#39;, &#39;ConditionManager&#39;,
</span><span class="noop">           &#39;Node&#39;, &#39;Nodes&#39;, &#39;Element&#39;, &#39;Elements&#39;, &#39;Selection&#39;, &#39;Selections&#39;]
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import from...
</span><span class="noop"># ...the standard library
</span><span class="hit">import sys as __sys
</span><span class="noop"># from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import indextools
</span><span class="noop">
</span><span class="hit">projectname = None
</span><span class="noop">
</span><span class="hit">options = objecttools.Options()
</span><span class="hit">indexer = indextools.Indexer()
</span><span class="hit">networkmanager = None
</span><span class="hit">controlmanager = None
</span><span class="hit">conditionmanager = None
</span><span class="hit">sequencemanager = None
</span><span class="hit">timegrids = None
</span><span class="noop">
</span><span class="hit">pyversion = int(__sys.version[0])
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from Hydpy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="hit">class Connections(object):
</span><span class="noop">    &#34;&#34;&#34;Connection between :class:`~hydpy.core.devicetools.Node` and
</span><span class="noop">    :class:`~hydpy.core.devicetools.Element` instances.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, master, *slaves):
</span><span class="hit">        self.master = master
</span><span class="hit">        for slave in slaves:
</span><span class="miss">            self.add
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, slave):
</span><span class="hit">        setattr(self, slave.name, slave)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def names(self):
</span><span class="hit">        return [name for (name, slave) in self]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def slaves(self):
</span><span class="hit">        return [slave for (name, slave) in self]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variables(self):
</span><span class="hit">        variable = getattr(self.master, &#39;variable&#39;, None)
</span><span class="hit">        if variable:
</span><span class="miss">            return [variable]
</span><span class="noop">        else:
</span><span class="hit">            return sorted(set([slave.variable for (name, slave) in self]))
</span><span class="noop">
</span><span class="hit">    def __contains__(self, value):
</span><span class="hit">        return value in (self.names + self.slaves)
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, name, value):
</span><span class="miss">        self.__dict__[name] = value
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, name):
</span><span class="hit">        return self.__dict__[name]
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (name, slave) in vars(self).items():
</span><span class="hit">            if name != &#39;master&#39;:
</span><span class="hit">                yield (name, slave)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self.names)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import copy
</span><span class="hit">import struct
</span><span class="noop"># ...from site-packages
</span><span class="hit">from matplotlib import pyplot
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import connectiontools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.cythons import pointer
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Device(object):
</span><span class="noop">
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="noop">
</span><span class="hit">    def _getname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the actual device (node or element).&#34;&#34;&#34;
</span><span class="hit">        return self._name
</span><span class="hit">    name = property(_getname)
</span><span class="noop">
</span><span class="hit">    def _checkname(self, name):
</span><span class="noop">        &#34;&#34;&#34;Raises an :class:`~exceptions.ValueError` if the given name is not
</span><span class="noop">        a valid Python identifier.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        exc = ValueError(&#39;For initializing `%s` objects, `value` is a &#39;
</span><span class="noop">                         &#39;necessary function argument.  Principally, any &#39;
</span><span class="noop">                         &#39;object is allowed that supports the Python build-in &#39;
</span><span class="noop">                         &#39;function `str`.  But note that `str(value)` must &#39;
</span><span class="noop">                         &#39;return a valid Python identifier (that does &#39;
</span><span class="noop">                         &#39;not start with a number, that does not contain `-`, &#39;
</span><span class="noop">                         &#39;that is not a Python keyword like `for`...).  The &#39;
</span><span class="noop">                         &#39;given object returned the string `%s`, which is not &#39;
</span><span class="noop">                         &#39;a valid Python identifier.&#39;
</span><span class="noop">                         % (objecttools.classname(self), name))
</span><span class="hit">        try:
</span><span class="hit">            exec(&#39;%s = None&#39; % name)
</span><span class="hit">        except SyntaxError:
</span><span class="hit">            raise exc
</span><span class="hit">        if name in dir(__builtins__):
</span><span class="miss">            raise exc
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def clearregistry(cls):
</span><span class="hit">        cls._selection.clear()
</span><span class="hit">        cls._registry.clear()
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registerednames(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all names of :class:`Device` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return cls._registry.keys()
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (key, value) in vars(self).items():
</span><span class="miss">            if isinstance(value, connectiontools.Connections):
</span><span class="miss">                yield (key, value)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return self.name
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Node(Device):
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    readobs = False
</span><span class="noop">    readext = False
</span><span class="noop">    passsim = True
</span><span class="noop">    passobs = False
</span><span class="noop">    passext = False
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="hit">    _predefinedvariable = &#39;Q&#39;
</span><span class="hit">    ROUTING_MODES = (&#39;newsim&#39;, &#39;obs&#39;, &#39;oldsim&#39;)
</span><span class="noop">
</span><span class="hit">    def __new__(cls, value, variable=None):
</span><span class="noop">        &#34;&#34;&#34;Returns an already existing :class:`Node` instance or, if such
</span><span class="noop">        an instance does not exist yet, a new newly created one.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        name = str(value)
</span><span class="hit">        if name not in cls._registry:
</span><span class="hit">            self = object.__new__(Node)
</span><span class="hit">            self._checkname(name)
</span><span class="hit">            self._name = name
</span><span class="hit">            if variable is None:
</span><span class="hit">                self._variable = self._predefinedvariable
</span><span class="noop">            else:
</span><span class="hit">                self._variable = variable
</span><span class="hit">            self.entries = connectiontools.Connections(self)
</span><span class="hit">            self.exits = connectiontools.Connections(self)
</span><span class="hit">            self.sequences = sequencetools.NodeSequences(self)
</span><span class="hit">            self.routingmode = &#39;newsim&#39;
</span><span class="hit">            self._blackhole = None
</span><span class="hit">            cls._registry[name] = self
</span><span class="hit">        cls._selection[name] = cls._registry[name]
</span><span class="hit">        return cls._registry[name]
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, variable=None, route=None):
</span><span class="hit">        if (variable is not None) and (variable != self.variable):
</span><span class="hit">            raise ValueError(&#39;The variable to be represented by a `Node &#39;
</span><span class="noop">                             &#39;instance cannot be changed.  The variable of &#39;
</span><span class="noop">                             &#39;node `%s` is `%s` instead of `%s` or `None`.  &#39;
</span><span class="noop">                             &#39;Keep in mind, that `name` is the unique &#39;
</span><span class="noop">                             &#39;identifier of node objects.&#39;
</span><span class="noop">                             % (self.name, self.variable, variable))
</span><span class="noop">
</span><span class="hit">    def _getvariable(self):
</span><span class="noop">        &#34;&#34;&#34;The variable handled by the respective node instance.&#34;&#34;&#34;
</span><span class="hit">        return self._variable
</span><span class="hit">    variable = property(_getvariable)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def predefinevariable(cls, name):
</span><span class="miss">        cls._predefinedvariable = str(name)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registerednodes(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all :class:`Node` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return Nodes(cls._registry.values())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def gathernewnodes(cls):
</span><span class="noop">        &#34;&#34;&#34;Gather all `new` :class:`Node` objects. :class:`Node` objects
</span><span class="noop">        are deemed to be new if their constructor has been called since the
</span><span class="noop">        last usage of this method.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        nodes = Nodes(cls._selection.values())
</span><span class="miss">        cls._selection.clear()
</span><span class="miss">        return nodes
</span><span class="noop">
</span><span class="hit">    def _getroutingmode(self):
</span><span class="hit">        return self._routingmode
</span><span class="hit">    def _setroutingmode(self, value):
</span><span class="hit">        if value in self.ROUTING_MODES:
</span><span class="hit">            self._routingmode = value
</span><span class="hit">            if value == &#39;newsim&#39;:
</span><span class="hit">                self.sequences.sim.use_ext = False
</span><span class="miss">            elif value == &#39;obs&#39;:
</span><span class="miss">                self.sequences.sim.use_ext = False
</span><span class="miss">                self.sequences.obs.use_ext = True
</span><span class="miss">            elif value == &#39;oldsim&#39;:
</span><span class="miss">                self.sequences.sim.use_ext = True
</span><span class="miss">                self._blackhole = pointer.Double(0.)
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;When trying to set the routing mode of node %s, &#39;
</span><span class="noop">                             &#39;the value `%s` was given, but only the &#39;
</span><span class="noop">                             &#39;following values are allowed: %s.&#39;
</span><span class="noop">                             % (self.name, value,
</span><span class="noop">                             &#39;, &#39;.join(self.ROUTING_MODES)))
</span><span class="hit">    routingmode = property(_getroutingmode, _setroutingmode)
</span><span class="noop">
</span><span class="hit">    def getdouble_via_exits(self):
</span><span class="hit">        if self.routingmode != &#39;obs&#39;:
</span><span class="hit">            return self.sequences.fastaccess.sim
</span><span class="noop">        else:
</span><span class="miss">            return self.sequences.fastaccess.obs
</span><span class="noop">
</span><span class="hit">    def getdouble_via_entries(self):
</span><span class="hit">        if self.routingmode != &#39;oldsim&#39;:
</span><span class="hit">            return self.sequences.fastaccess.sim
</span><span class="noop">        else:
</span><span class="miss">            return self._blackhole
</span><span class="noop">
</span><span class="hit">    def reset(self, idx=None):
</span><span class="miss">        self.sequences.fastaccess.sim[0] = 0.
</span><span class="noop">
</span><span class="hit">    def _loaddata_sim(self, idx):
</span><span class="miss">        fastaccess = self.sequences.fastaccess
</span><span class="miss">        if fastaccess._sim_ramflag:
</span><span class="miss">            fastaccess.sim[0] = fastaccess._sim_array[idx]
</span><span class="miss">        elif fastaccess._sim_diskflag:
</span><span class="miss">            raw = fastaccess._sim_file.read(8)
</span><span class="miss">            fastaccess.sim[0] = struct.unpack(&#39;d&#39;, raw)
</span><span class="noop">
</span><span class="hit">    def _savedata_sim(self, idx):
</span><span class="miss">        fastaccess = self.sequences.fastaccess
</span><span class="miss">        if fastaccess._sim_ramflag:
</span><span class="miss">            fastaccess._sim_array[idx] = fastaccess.sim[0]
</span><span class="miss">        elif fastaccess._sim_diskflag:
</span><span class="miss">            raw = struct.pack(&#39;d&#39;, fastaccess.sim[0])
</span><span class="miss">            fastaccess._sim_file.write(raw)
</span><span class="noop">
</span><span class="hit">    def _loaddata_obs(self, idx):
</span><span class="miss">        fastaccess = self.sequences.fastaccess
</span><span class="miss">        if fastaccess._obs_ramflag:
</span><span class="miss">            fastaccess.obs[0] = fastaccess._obs_array[idx]
</span><span class="miss">        elif fastaccess._obs_diskflag:
</span><span class="miss">            raw = fastaccess._obs_file.read(8)
</span><span class="miss">            fastaccess.obs[0] = struct.unpack(&#39;d&#39;, raw)
</span><span class="noop">
</span><span class="hit">    def comparisonplot(self, **kwargs):
</span><span class="miss">        for (name, seq) in self.sequences:
</span><span class="miss">            if pyplot.isinteractive():
</span><span class="miss">                name = &#39; &#39;.join((self.name, name))
</span><span class="miss">            pyplot.plot(seq.series, label=name, **kwargs)
</span><span class="miss">        pyplot.legend()
</span><span class="miss">        variable = self.variable
</span><span class="miss">        if variable == &#39;Q&#39;:
</span><span class="miss">            variable = u&#39;Q [m³/s]&#39;
</span><span class="miss">        pyplot.ylabel(variable)
</span><span class="miss">        if not pyplot.isinteractive():
</span><span class="miss">            pyplot.show()
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="hit">        return (&#39;%sNode(&#34;%s&#34;, variable=&#34;%s&#34;)&#39;
</span><span class="noop">                % (prefix, self.name, self.variable))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Element(Device):
</span><span class="noop">
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="noop">
</span><span class="hit">    def __new__(cls, value, inlets=None, outlets=None,
</span><span class="noop">                receivers=None,  senders=None
</span><span class="noop">                ):
</span><span class="noop">        &#34;&#34;&#34;Returns an already existing :class:`Element` instance or, if such
</span><span class="noop">        an instance does not exist yet, a new newly created one.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        name = str(value)
</span><span class="hit">        if name not in cls._registry:
</span><span class="hit">            self = object.__new__(Element)
</span><span class="hit">            self._checkname(name)
</span><span class="hit">            self._name = name
</span><span class="hit">            self.inlets = connectiontools.Connections(self)
</span><span class="hit">            self.outlets = connectiontools.Connections(self)
</span><span class="hit">            self.receivers = connectiontools.Connections(self)
</span><span class="hit">            self.senders = connectiontools. Connections(self)
</span><span class="hit">            self.model = None
</span><span class="hit">            cls._registry[name] = self
</span><span class="hit">        cls._selection[name] = cls._registry[name]
</span><span class="hit">        return cls._registry[name]
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, inlets=None, outlets=None,
</span><span class="noop">                 receivers=None, senders=None
</span><span class="noop">                ):
</span><span class="noop">        &#34;&#34;&#34;Adds the given :class:`~connectiontools.Connections` instances to
</span><span class="noop">        the (old or new) :class:`Element` instance.&#34;&#34;&#34;
</span><span class="hit">        if inlets is not None:
</span><span class="hit">            for (name, inlet) in Nodes(inlets):
</span><span class="hit">                if inlet in self.outlets:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given inlet node &#39;
</span><span class="noop">                                     &#39;`%s` is already defined as an outlet &#39;
</span><span class="noop">                                     &#39;node, which is not allowed.&#39;
</span><span class="noop">                                     % (self, inlet))
</span><span class="hit">                self.inlets += inlet
</span><span class="hit">                inlet.exits += self
</span><span class="hit">        if outlets is not None:
</span><span class="hit">            for (name, outlet) in Nodes(outlets):
</span><span class="hit">                if outlet in self.inlets:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given outlet node &#39;
</span><span class="noop">                                     &#39;`%s` is already defined as an inlet &#39;
</span><span class="noop">                                     &#39;node, which is not allowed.&#39;
</span><span class="noop">                                     % (self, outlet))
</span><span class="hit">                self.outlets += outlet
</span><span class="hit">                outlet.entries += self
</span><span class="hit">        if receivers is not None:
</span><span class="hit">            for (name, receiver) in Nodes(receivers):
</span><span class="hit">                if receiver in self.senders:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given receiver &#39;
</span><span class="noop">                                     &#39;node `%s` is already defined as an &#39;
</span><span class="noop">                                     &#39;sender node, which is not allowed.&#39;
</span><span class="noop">                                     % (self, receiver))
</span><span class="hit">                self.receivers += receiver
</span><span class="hit">                receiver.exits += self
</span><span class="hit">        if senders is not None:
</span><span class="hit">            for (name, sender) in Nodes(senders):
</span><span class="hit">                if sender in self.receivers:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given sender node &#39;
</span><span class="noop">                                     &#39;`%s` is already defined as an receiver, &#39;
</span><span class="noop">                                     &#39;node which is not allowed.&#39;
</span><span class="noop">                                     % (self, sender))
</span><span class="hit">                self.senders += sender
</span><span class="hit">                sender.entries += self
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registeredelements(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all :class:`Element` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return Elements(cls._registry.values())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def gathernewelements(cls):
</span><span class="noop">        &#34;&#34;&#34;Gather all `new` :class:`Element` objects. :class:`Element` objects
</span><span class="noop">        are deemed to be new if their constructor has been called since the
</span><span class="noop">        last usage of this method.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        elements = Elements(cls._selection.values())
</span><span class="miss">        cls._selection.clear()
</span><span class="miss">        return elements
</span><span class="noop">
</span><span class="hit">    def _getvariables(self):
</span><span class="miss">        variables = set()
</span><span class="miss">        for (name, connections) in self:
</span><span class="miss">            variables.update(connections.variables)
</span><span class="miss">        return variables
</span><span class="hit">    variables = property(_getvariables)
</span><span class="noop">
</span><span class="hit">    def initmodel(self):
</span><span class="miss">        namespace = pub.controlmanager.loadfile(self.name)
</span><span class="miss">        self.model = namespace[&#39;model&#39;]
</span><span class="miss">        self.model.element = self
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="miss">        try:
</span><span class="miss">            self.model.connect()
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise RuntimeError(&#39;First init than build&#39;)
</span><span class="noop">
</span><span class="hit">    def _plot(self, subseqs, selnames, kwargs):
</span><span class="miss">        for name in selnames:
</span><span class="miss">            seq = getattr(subseqs, name)
</span><span class="miss">            if seq.NDIM == 0:
</span><span class="miss">                label = kwargs.pop(&#39;label&#39;, &#39; &#39;.join((self.name, name)))
</span><span class="miss">                pyplot.plot(seq.series, label=label, **kwargs)
</span><span class="miss">                pyplot.legend()
</span><span class="noop">            else:
</span><span class="miss">                color = kwargs.pop(&#39;color&#39;, kwargs.pop(&#39;c&#39;, &#39;red&#39;))
</span><span class="miss">                pyplot.plot(seq.series, color=color, **kwargs)
</span><span class="miss">        if not pyplot.isinteractive():
</span><span class="miss">            pyplot.show()
</span><span class="noop">
</span><span class="hit">    def inputplot(self, *args, **kwargs):
</span><span class="miss">        self._plot(self.model.sequences.inputs, args, kwargs)
</span><span class="noop">
</span><span class="hit">    def fluxplot(self, *args, **kwargs):
</span><span class="miss">        self._plot(self.model.sequences.fluxes, args, kwargs)
</span><span class="noop">
</span><span class="hit">    def stateplot(self, *args, **kwargs):
</span><span class="miss">        self._plot(self.model.sequences.states, args, kwargs)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        blanks = &#39; &#39; * (len(prefix) + 8)
</span><span class="hit">        lines = []
</span><span class="hit">        lines.append(&#39;%sElement(&#34;%s&#34;,&#39; % (prefix, self.name))
</span><span class="hit">        for conname in (&#39;inlets&#39;, &#39;outlets&#39;, &#39;receivers&#39;, &#39;senders&#39;):
</span><span class="hit">            connections = getattr(self, conname, None)
</span><span class="hit">            if connections:
</span><span class="miss">                subprefix = &#39;%s%s=&#39; % (blanks, conname)
</span><span class="miss">                if len(connections) == 1:
</span><span class="miss">                    line = connections.slaves[0].assignrepr(subprefix)
</span><span class="noop">                else:
</span><span class="miss">                    line = Nodes(connections.slaves).assignrepr(subprefix)
</span><span class="miss">                lines.append(line + &#39;,&#39;)
</span><span class="hit">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Devices(object):
</span><span class="noop">
</span><span class="hit">    _contentclass = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, *values):
</span><span class="hit">        self._extractvalues(values)
</span><span class="noop">
</span><span class="hit">    def _extractvalues(self, values):
</span><span class="hit">        if values is not None:
</span><span class="noop">
</span><span class="hit">            if isinstance(values, (self._contentclass, str)):
</span><span class="hit">                device = self._contentclass(values)
</span><span class="hit">                self[device.name] = device
</span><span class="noop">            else:
</span><span class="hit">                try:
</span><span class="hit">                    for value in values:
</span><span class="hit">                        self._extractvalues(value)
</span><span class="hit">                except TypeError:
</span><span class="hit">                    raise TypeError(&#39;toDo&#39;)
</span><span class="noop">
</span><span class="hit">    def _getnames(self):
</span><span class="hit">        return vars(self).keys()
</span><span class="hit">    names = property(_getnames)
</span><span class="noop">
</span><span class="hit">    def _getdevices(self):
</span><span class="hit">        return vars(self).values()
</span><span class="hit">    devices = property(_getdevices)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Return a shallow copy of the actual :class:`Elements` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.copy(self)
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="hit">        self.__dict__[key] = value
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __delitem__(self, key):
</span><span class="hit">        del(self.__dict__[key])
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for name in sorted(vars(self).keys()):
</span><span class="hit">            yield (name, self[name])
</span><span class="noop">
</span><span class="hit">    def __contains__(self, device):
</span><span class="hit">        device = self._contentclass(device)
</span><span class="hit">        return device.name in self.__dict__
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self.names)
</span><span class="noop">
</span><span class="hit">    def __add__(self, values):
</span><span class="hit">        new = self.copy()
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            new[name] = device
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, values):
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            self[name] = device
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, values):
</span><span class="hit">        new = self.copy()
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            if name in self:
</span><span class="hit">                del(new[name])
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __isub__(self, values):
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            if name in self:
</span><span class="hit">                del(self[name])
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="miss">        return set(self.devices) &lt; set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="miss">        return set(self.devices) &lt;= set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return set(self.devices) == set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="miss">        return set(self.devices) != set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        return set(self.devices) &gt;= set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="miss">        return set(self.devices) &gt; set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        lines = []
</span><span class="miss">        for (name, device) in sorted(zip(self.names, self.devices)):
</span><span class="miss">            lines.append(repr(device))
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="miss">        lines = []
</span><span class="miss">        prefix += &#39;%s(&#39; % objecttools.classname(self)
</span><span class="miss">        blanks = &#39; &#39;*len(prefix)
</span><span class="miss">        names = sorted(self.names)
</span><span class="miss">        for (idx, name) in enumerate(names):
</span><span class="miss">            device = self[name]
</span><span class="miss">            if idx == 0:
</span><span class="miss">                lines.append(device.assignrepr(prefix))
</span><span class="noop">            else:
</span><span class="miss">                lines.append(device.assignrepr(blanks))
</span><span class="miss">            lines[-1] += &#39;,&#39;
</span><span class="miss">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="hit">class Nodes(Devices):
</span><span class="noop">
</span><span class="hit">    _contentclass = Node
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Elements(Devices):
</span><span class="noop">
</span><span class="hit">    _contentclass = Element</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MainManager(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self.info = {}
</span><span class="miss">        self.networkfile = None
</span><span class="miss">        self.controlfiles = None
</span><span class="miss">        self.sequencefiles = None
</span><span class="miss">        self.initialvaluefiles = None
</span><span class="miss">        self.parameterfiles = None
</span><span class="miss">        self.checkpath()
</span><span class="miss">        self.loadinfo()
</span><span class="miss">        self.applyinfo()
</span><span class="miss">        self.clearinfo()
</span><span class="noop">
</span><span class="hit">    def _getpath(self):
</span><span class="miss">        return os.path.abspath(pub.projectname+&#39;.py&#39;)
</span><span class="hit">    path = property(_getpath)
</span><span class="noop">
</span><span class="hit">    def checkpath(self):
</span><span class="miss">        if not os.path.exists(self.path):
</span><span class="miss">            raise IOError(&#39;The required project main file `%s` does not exist.&#39;
</span><span class="noop">                          % self.path)
</span><span class="noop">
</span><span class="hit">    def loadinfo(self):
</span><span class="noop">        &#34;&#34;&#34;Load general information from the project&#39;s main file.&#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            with open(self.path) as file_:
</span><span class="miss">                code = compile(file_.read(), self.path, &#39;exec&#39;)
</span><span class="miss">                exec(code, {}, self.info)
</span><span class="miss">        except Exception:
</span><span class="miss">            prefix = (&#39;While trying to load the genereal project settings &#39;
</span><span class="noop">                      &#39;from `%s`&#39; % self.path)
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="noop">
</span><span class="hit">    def clearinfo(self):
</span><span class="miss">        self.info = {}
</span><span class="noop">
</span><span class="hit">    def applyinfo(self):
</span><span class="miss">        self.timegrids2pub()
</span><span class="miss">        self.getmanagers()
</span><span class="noop">
</span><span class="hit">    def timegrids2pub(self):
</span><span class="miss">        selection = [value for value in self.info.values()
</span><span class="noop">                     if isinstance(value, timetools.Timegrids)]
</span><span class="miss">        if len(selection) != 1:
</span><span class="miss">            print(self.info)
</span><span class="miss">            raise ImportError(&#39;The main project file `%s` must define exactly &#39;
</span><span class="noop">                              &#39;1 `Timegrids` object; %d objects are defined &#39;
</span><span class="noop">                              &#39;instead.&#39; % (self.path, len(selection)))
</span><span class="noop">        else:
</span><span class="miss">            pub.timegrids = selection[0]
</span><span class="noop">
</span><span class="hit">    def getmanagers(self):
</span><span class="miss">        for FileClass in (NetworkManager, ControlManager,
</span><span class="noop">                          SequenceManager, ConditionManager):
</span><span class="miss">            selection = [value for value in self.info.values()
</span><span class="noop">                         if isinstance(value, FileClass)]
</span><span class="miss">            if len(selection) &gt; 1:
</span><span class="miss">                raise ImportError(&#39;The main project file `%s` must not define &#39;
</span><span class="noop">                                  &#39;more then one `%s` objects but %d objects &#39;
</span><span class="noop">                                  &#39;are defined.&#39;
</span><span class="noop">                                  % (self.path, FileClass.__name__,
</span><span class="noop">                                     len(selection)))
</span><span class="miss">            elif len(selection) == 1:
</span><span class="miss">                setattr(self, FileClass.__name__.lower(), selection[0])
</span><span class="noop">            else:
</span><span class="miss">                setattr(self, FileClass.__name__.lower(), FileClass())
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NetworkManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for network files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;network&#39;
</span><span class="miss">        self.directory = pub.projectname
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all network directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Directory containing the network files.&#34;&#34;&#34;
</span><span class="miss">        return self._subdirectory
</span><span class="hit">    def _setdirectory(self, subdirectory):
</span><span class="miss">        directory = os.path.join(self.basepath, subdirectory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;A directory `%s` within the network base path &#39;
</span><span class="noop">                          &#39;`%s` does not exist.&#39;
</span><span class="noop">                          % (subdirectory, self.basepath))
</span><span class="miss">        self._subdirectory = str(subdirectory)
</span><span class="hit">    directory = property(_getdirectory, _setdirectory)
</span><span class="noop">
</span><span class="hit">    def _getdirpath(self):
</span><span class="noop">        &#34;&#34;&#34;Complete path of the directory containing the network files.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.directory)
</span><span class="hit">    dirpath = property(_getdirpath)
</span><span class="noop">
</span><span class="hit">    def _getfilenames(self):
</span><span class="noop">        &#34;&#34;&#34;Names of the network files.&#34;&#34;&#34;
</span><span class="miss">        return [fn for fn in os.listdir(self.dirpath)
</span><span class="noop">                if (fn.endswith(&#39;.py&#39;) and not fn.startswith(&#39;_&#39;))]
</span><span class="hit">    filenames = property(_getfilenames)
</span><span class="noop">
</span><span class="hit">    def _getfilepaths(self):
</span><span class="noop">        &#34;&#34;&#34;Complete paths of the defined networks files.&#34;&#34;&#34;
</span><span class="miss">        root = os.path.join(self.basepath, self.directory)
</span><span class="miss">        return [os.path.join(root, fn) for fn in self.filenames]
</span><span class="hit">    filepaths = property(_getfilepaths)
</span><span class="noop">
</span><span class="hit">    def load(self):
</span><span class="noop">        &#34;&#34;&#34;Load nodes and elements from all network files and return them in
</span><span class="noop">        a :class:`~hydpy.selectiontools.Selections` instance.  Each single
</span><span class="noop">        network file defines a seperate
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` instance.  Additionally, all
</span><span class="noop">        elements and nodes are bundled in a selection named `complete`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        selections = selectiontools.Selections()
</span><span class="miss">        for (filename, path) in zip(self.filenames, self.filepaths):
</span><span class="noop">            # Ensure both `Node` and `Element`start with a `fresh` memory.
</span><span class="miss">            devicetools.Node.gathernewnodes()
</span><span class="miss">            devicetools.Element.gathernewelements()
</span><span class="miss">            info = {}
</span><span class="miss">            try:
</span><span class="miss">                with open(path) as file_:
</span><span class="miss">                    code = compile(file_.read(), path, &#39;exec&#39;)
</span><span class="miss">                    exec(code, {}, info)
</span><span class="miss">            except Exception:
</span><span class="miss">                prefix = &#39;While trying to load the network file `%s`&#39; % path
</span><span class="miss">                objecttools.augmentexcmessage(prefix)
</span><span class="miss">            try:
</span><span class="miss">                selections += selectiontools.Selection(
</span><span class="noop">                                           filename.split(&#39;.&#39;)[0],
</span><span class="noop">                                           info[&#39;Node&#39;].gathernewnodes(),
</span><span class="noop">                                           info[&#39;Element&#39;].gathernewelements())
</span><span class="noop">
</span><span class="miss">            except KeyError as exc:
</span><span class="miss">                KeyError(&#39;The class `%s` cannot be loaded from the network &#39;
</span><span class="noop">                         &#39;file `%s`.  Please refer to the HydPy documentation &#39;
</span><span class="noop">                         &#39;on how to prepare network files properly.&#39;
</span><span class="noop">                         % (exc.args[0], filename))
</span><span class="miss">        selections += selectiontools.Selection(
</span><span class="noop">                                          &#39;complete&#39;,
</span><span class="noop">                                          info[&#39;Node&#39;].registerednodes(),
</span><span class="noop">                                          info[&#39;Element&#39;].registeredelements())
</span><span class="miss">        return selections
</span><span class="noop">
</span><span class="hit">    def save(self, selections, overwrite=False):
</span><span class="noop">        &#34;&#34;&#34;Save the nodes and elements from each
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` object contained within the
</span><span class="noop">        given :class:`~hydpy.selectiontools.Selections` instance to a seperate
</span><span class="noop">        network file of the same name.  Set `overwrite` to `True`, if you
</span><span class="noop">        want to overwrite already existing network files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        selections = selectiontools.Selections(selections)
</span><span class="miss">        for (name, selection) in selections:
</span><span class="miss">            if name == &#39;complete&#39;:
</span><span class="miss">                continue
</span><span class="miss">            path = os.path.join(self.dirpath, name+&#39;.py&#39;)
</span><span class="miss">            if os.path.exists(path) and not overwrite:
</span><span class="miss">                warnings.warn(&#39;The path `%s` does already exist, selection &#39;
</span><span class="noop">                              &#39;`%s` cannot be saved.  Please select another &#39;
</span><span class="noop">                              &#39;network directory or set the `overwrite` flag &#39;
</span><span class="noop">                              &#39;to `True`&#39; % (path, name))
</span><span class="noop">            else:
</span><span class="miss">                with open(path, &#39;w&#39;) as file_:
</span><span class="miss">                    file_.write(&#39;from hydpy import *\n\n&#39;)
</span><span class="miss">                    file_.write(repr(selection.elements))
</span><span class="noop">
</span><span class="hit">    def delete(self, *selections):
</span><span class="noop">        &#34;&#34;&#34;Delete network files.  One or more filenames and/or
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` instances can serve as
</span><span class="noop">        function arguments.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        for selection in selections:
</span><span class="miss">            name = str(selection)
</span><span class="miss">            if not name.endswith(&#39;.py&#39;):
</span><span class="miss">                name += &#39;.py&#39;
</span><span class="miss">            path = os.path.join(self.dirpath, name)
</span><span class="miss">            try:
</span><span class="miss">                os.remove(path)
</span><span class="miss">            except EnvironmentError:
</span><span class="miss">                exception, message = sys.exc_info()[:2]
</span><span class="miss">                exception = str(exception)[:-2].split(&#39;.&#39;)[-1]
</span><span class="miss">                warnings.warn(&#39;: &#39;.join((exception, str(message))))
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for control parameter files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # The following file path to content mapping is used to circumvent reading
</span><span class="noop">    # the same secondary control parameter file from disk multiple times.
</span><span class="hit">    _registry = {}
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;control&#39;
</span><span class="miss">        self._projectdirectory = pub.projectname
</span><span class="miss">        self._controldirectory = None
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all control directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the control directories of the current project.&#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a control directory &#39;
</span><span class="noop">                          &#39;named `%s`.&#39; % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getcontroldirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the control files of different parameter sets.&#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="hit">    controldirectories = property(_getcontroldirectories)
</span><span class="noop">
</span><span class="hit">    def _getcontrolpaths(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the control directories.&#34;&#34;&#34;
</span><span class="miss">        paths = FolderShow()
</span><span class="miss">        for (directory, dummy) in self.controldirectories:
</span><span class="miss">            paths.add(directory, os.path.join(self.projectpath, directory))
</span><span class="miss">        return paths
</span><span class="hit">    controlpaths = property(_getcontrolpaths)
</span><span class="noop">
</span><span class="hit">    def _getcontroldirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) control directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.controldirectories
</span><span class="miss">        if self._controldirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._controldirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified control directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._controldirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;control directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return directories.default
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple control&#39;
</span><span class="noop">                          &#39;directories, but none is named `default`.  &#39;
</span><span class="noop">                          &#39;Please specify the control directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="hit">    def _setcontroldirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._controldirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;control directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="hit">    def _delcontroldirectory(self):
</span><span class="miss">        self._controldirectory = None
</span><span class="hit">    controldirectory = property(_getcontroldirectory, _setcontroldirectory,
</span><span class="noop">                                _delcontroldirectory)
</span><span class="noop">
</span><span class="hit">    def _getcontrolpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected control directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.controldirectory)
</span><span class="hit">    controlpath = property(_getcontrolpath)
</span><span class="noop">
</span><span class="hit">    def loadfile(self, filename):
</span><span class="noop">        &#34;&#34;&#34;Return the namespace of the given file (and eventually of its
</span><span class="noop">        subfile) as a :class:`dict`.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * filename (:class:`str`): Any object returning a valid filename
</span><span class="noop">              with or without extension.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        workingpath = os.path.abspath(os.curdir)
</span><span class="miss">        try:
</span><span class="miss">            os.chdir(self.controlpath)
</span><span class="miss">        except OSError:
</span><span class="miss">            raise IOError(&#39;The specified control path `%s` does not exist.&#39;
</span><span class="noop">                          % self.controlpath)
</span><span class="noop">        else:
</span><span class="miss">            info = {}
</span><span class="miss">            self.read2dict(filename, info)
</span><span class="miss">            return info
</span><span class="noop">        finally:
</span><span class="miss">            self._registry.clear()
</span><span class="miss">            os.chdir(workingpath)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def read2dict(cls, path, info):
</span><span class="noop">        &#34;&#34;&#34;Reads the control parameters of the given path (and its subpaths
</span><span class="noop">        where appropriate) and stores it in the given :class:`dict` `info`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * path (:class:`str`): Any object returning a valid path
</span><span class="noop">              with or without extension.
</span><span class="noop">            * info (:class:`dict`): Target dictionary.
</span><span class="noop">
</span><span class="noop">        Note that the :class:`dict` `info` can be used to feed information
</span><span class="noop">        into the execution of control files.  Use this function only if you
</span><span class="noop">        are completely sure on how the control parameter import of HydPy
</span><span class="noop">        works.  Otherwise, you should most probably prefer to use
</span><span class="noop">        :func:`loadfile` or :func:`loadfiles`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        path = str(path)
</span><span class="miss">        if not path.endswith(&#39;.py&#39;):
</span><span class="miss">            path += &#39;.py&#39;
</span><span class="miss">        try:
</span><span class="miss">            if path not in cls._registry:
</span><span class="miss">                with file(path) as file_:
</span><span class="miss">                    cls._registry[path] = file_.read()
</span><span class="miss">            exec(cls._registry[path], {}, info)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = &#39;While trying to load the control file `%s`&#39; % path
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        if &#39;model&#39; not in info:
</span><span class="miss">            raise IOError(&#39;Model parameters cannot be loaded from control &#39;
</span><span class="noop">                          &#39;file `%s`.  Please refer to the HydPy &#39;
</span><span class="noop">                          &#39;documentation on how to prepare control files &#39;
</span><span class="noop">                          &#39;properly.&#39; % path)
</span><span class="noop">
</span><span class="hit">class FolderShow(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, *args, **kwargs):
</span><span class="miss">        for arg in args:
</span><span class="miss">            self.add(arg)
</span><span class="miss">        for (key, value) in kwargs.items():
</span><span class="miss">            self.add(key, value)
</span><span class="noop">
</span><span class="hit">    def add(self, directory, path=None):
</span><span class="miss">        if path is None:
</span><span class="miss">            path = directory
</span><span class="miss">        try:
</span><span class="miss">            exec(&#39;self.%s = r&#34;%s&#34;&#39; %(directory, path))
</span><span class="miss">        except BaseException:
</span><span class="miss">            raise IOError(&#39;The directory name `%s` cannot be handled as a &#39;
</span><span class="noop">                          &#39;variable name.  Please avoid arithmetic operators &#39;
</span><span class="noop">                          &#39;like `-`, prefixed numbers...&#39; % directory)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        return vars(self).items()
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return sorted(vars(self).values())[key]
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(vars(self))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        if not len(self):
</span><span class="miss">            return &#39;Folders()&#39;
</span><span class="noop">        else:
</span><span class="miss">            args, kwargs = [], []
</span><span class="miss">            for (idx, (key, value)) in enumerate(self):
</span><span class="miss">                if key == value:
</span><span class="miss">                    args.append(key)
</span><span class="noop">                else:
</span><span class="miss">                    kwargs.append(&#39;%s=%s&#39; % (key, value))
</span><span class="miss">            lines = [&#39;           %s,&#39; %arg for arg in (args + kwargs)]
</span><span class="miss">            lines[0] = &#39;FolderShow(&#39; + lines[0][11:]
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">            return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SequenceManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for sequence files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _supportedmodes = (&#39;npy&#39;, &#39;asc&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, projectdirectory=None, inputdirectory=None,
</span><span class="noop">                 outputdirectory=None, nodedirectory=None, tempdirectory=None,
</span><span class="noop">                 inputfiletype=None, outputfiletype=None, nodefiletype=None):
</span><span class="hit">        self._BASEDIRECTORY = &#39;sequences&#39;
</span><span class="hit">        if projectdirectory:
</span><span class="miss">            self.projectdirectory = projectdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._projectdirectory = pub.projectname
</span><span class="hit">        if inputdirectory:
</span><span class="miss">            self.inputdirectory = inputdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._inputdirectory = None
</span><span class="hit">        if outputdirectory:
</span><span class="miss">            self.outputdirectory = outputdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._outputdirectory = None
</span><span class="hit">        if nodedirectory:
</span><span class="miss">            self.nodedirectory = nodedirectory
</span><span class="noop">        else:
</span><span class="hit">            self._nodedirectory = None
</span><span class="hit">        if tempdirectory:
</span><span class="miss">            self.tempdirectory = tempdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._tempdirectory = None
</span><span class="hit">        if inputfiletype:
</span><span class="miss">            self.inputfiletype = inputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._inputfiletype = &#39;npy&#39;
</span><span class="hit">        if outputfiletype:
</span><span class="miss">            self.outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._outputfiletype = &#39;npy&#39;
</span><span class="hit">        if outputfiletype:
</span><span class="miss">            self.outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._outputfiletype = &#39;npy&#39;
</span><span class="hit">        if nodefiletype:
</span><span class="miss">            self.nodefiletype = nodefiletype
</span><span class="noop">        else:
</span><span class="hit">            self._nodefiletype = &#39;npy&#39;
</span><span class="hit">        self._inputoverwrite = False
</span><span class="hit">        self._outputoverwrite = False
</span><span class="hit">        self._simoverwrite = False
</span><span class="hit">        self._obsoverwrite = False
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all sequence directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the file directories of the current project.&#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a directory named `%s`.&#39;
</span><span class="noop">                          % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getsequencedirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the different input/output/temp sequences.&#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="hit">    sequencedirectories = property(_getsequencedirectories)
</span><span class="noop">
</span><span class="hit">    def _getsequencepaths(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the sequence directories.&#34;&#34;&#34;
</span><span class="miss">        paths = FolderShow()
</span><span class="miss">        for (key, value) in self.sequencedirectories:
</span><span class="miss">            paths.add(key, os.path.join(self.projectpath, key))
</span><span class="miss">        return paths
</span><span class="hit">    sequencepaths = property(_getsequencepaths)
</span><span class="noop">
</span><span class="hit">    def _getinputdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) input sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._inputdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._inputdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified input sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._inputdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.input
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`input`.  Please specify the input sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="hit">    def _setinputdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._inputdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="hit">    def _delinputdirectory(self):
</span><span class="miss">        self._inputdirectory = None
</span><span class="hit">    inputdirectory = property(_getinputdirectory, _setinputdirectory,
</span><span class="noop">                              _delinputdirectory)
</span><span class="noop">
</span><span class="hit">    def _getoutputdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) output sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._outputdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._outputdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified output sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._outputdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.output
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`output`.  Please specify the sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="hit">    def _setoutputdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._outputdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="hit">    def _deloutputdirectory(self):
</span><span class="miss">        self._outputdirectory = None
</span><span class="hit">    outputdirectory = property(_getoutputdirectory, _setoutputdirectory,
</span><span class="noop">                               _deloutputdirectory)
</span><span class="noop">
</span><span class="hit">    def _getnodedirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) node sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._nodedirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._nodedirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified node sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._nodedirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.node
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`node`.  Please specify the node sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="hit">    def _setnodedirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._nodedirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="hit">    def _delnodedirectory(self):
</span><span class="miss">        self._nodedirectory = None
</span><span class="hit">    nodedirectory = property(_getnodedirectory, _setnodedirectory,
</span><span class="noop">                              _delnodedirectory)
</span><span class="noop">
</span><span class="hit">    def _gettempdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) temporary sequence directory.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._tempdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._tempdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified temporary sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._tempdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.temp
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`temp`.  Please specify the temporary sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="hit">    def _settempdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._tempdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="hit">    def _deltempdirectory(self):
</span><span class="miss">        self._tempdirectory = None
</span><span class="hit">    tempdirectory = property(_gettempdirectory, _settempdirectory,
</span><span class="noop">                             _deltempdirectory)
</span><span class="noop">
</span><span class="hit">    def _getinputpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected input sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.inputdirectory)
</span><span class="hit">    inputpath = property(_getinputpath)
</span><span class="noop">
</span><span class="hit">    def _getoutputpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected output sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.outputdirectory)
</span><span class="hit">    outputpath = property(_getoutputpath)
</span><span class="noop">
</span><span class="hit">    def _getnodepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected node sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.nodedirectory)
</span><span class="hit">    nodepath = property(_getnodepath)
</span><span class="noop">
</span><span class="hit">    def _gettemppath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected temporary sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.tempdirectory)
</span><span class="hit">    temppath = property(_gettemppath)
</span><span class="noop">
</span><span class="hit">    def _getinputfiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external input files.&#34;&#34;&#34;
</span><span class="miss">        return self._inputfiletype
</span><span class="hit">    def _setinputfiletype(self, inputfiletype):
</span><span class="miss">        inputfiletype = str(inputfiletype)
</span><span class="miss">        if inputfiletype in self._supportedmodes:
</span><span class="miss">            self._inputfiletype = inputfiletype
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;The given input file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (inputfiletype, self._supportedmodes))
</span><span class="hit">    inputfiletype = property(_getinputfiletype, _setinputfiletype)
</span><span class="noop">
</span><span class="hit">    def _getoutputfiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external output files.&#34;&#34;&#34;
</span><span class="miss">        return self._outputfiletype
</span><span class="hit">    def _setoutputfiletype(self, outputfiletype):
</span><span class="hit">        outputfiletype = str(outputfiletype)
</span><span class="hit">        if outputfiletype in self._supportedmodes:
</span><span class="miss">            self._outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;The given output file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (outputfiletype, self._supportedmodes))
</span><span class="hit">    outputfiletype = property(_getoutputfiletype, _setoutputfiletype)
</span><span class="noop">
</span><span class="hit">    def _getnodefiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external node files.&#34;&#34;&#34;
</span><span class="miss">        return self._nodefiletype
</span><span class="hit">    def _setnodefiletype(self, nodefiletype):
</span><span class="miss">        nodefiletype = str(nodefiletype)
</span><span class="miss">        if nodefiletype in self._supportedmodes:
</span><span class="miss">            self._nodefiletype = nodefiletype
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;The given node file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (nodefiletype, self._supportedmodes))
</span><span class="hit">    nodefiletype = property(_getnodefiletype, _setnodefiletype)
</span><span class="noop">
</span><span class="hit">    def _getinputoverwrite(self):
</span><span class="miss">        return self._inputoverwrite
</span><span class="hit">    def _setinputoverwrite(self, value):
</span><span class="miss">        self._inputoverwrite = bool(value)
</span><span class="hit">    inputoverwrite = property(_getinputoverwrite, _setinputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getoutputoverwrite(self):
</span><span class="miss">        return self._outputoverwrite
</span><span class="hit">    def _setoutputoverwrite(self, value):
</span><span class="miss">        self._outputoverwrite = bool(value)
</span><span class="hit">    outputoverwrite = property(_getoutputoverwrite, _setoutputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getsimoverwrite(self):
</span><span class="miss">        return self._simoverwrite
</span><span class="hit">    def _setsimoverwrite(self, value):
</span><span class="miss">        self._simoverwrite = bool(value)
</span><span class="hit">    simoverwrite = property(_getsimoverwrite, _setsimoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getobsoverwrite(self):
</span><span class="miss">        return self._obsoverwrite
</span><span class="hit">    def _setobsoverwrite(self, value):
</span><span class="miss">        self._obsoverwrite = bool(value)
</span><span class="hit">    obsoverwrite = property(_getobsoverwrite, _setobsoverwrite)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ConditionManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for condition files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;conditions&#39;
</span><span class="miss">        self._projectdirectory = pub.projectname
</span><span class="miss">        self._loaddirectory = None
</span><span class="miss">        self._savedirectory = None
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all condition directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the condition directories of the current
</span><span class="noop">        project.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a condition directory &#39;
</span><span class="noop">                          &#39;named `%s`.&#39; % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getconditiondirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the condition files of e.g. different time
</span><span class="noop">        points.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="hit">    conditiondirectories = property(_getconditiondirectories)
</span><span class="noop">
</span><span class="hit">    def _getloaddirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or only selectable) initial conditions directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.conditiondirectories
</span><span class="miss">        if self._loaddirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._loaddirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified conditions directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._loaddirectory))
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;conditions directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            string = &#39;init_&#39; + pub.timegrids.sim.firstdate.string(&#39;os&#39;)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple control&#39;
</span><span class="noop">                          &#39;directories, and no first simulation date is &#39;
</span><span class="noop">                          &#39;available to determine the relevant one.  &#39;
</span><span class="noop">                          &#39;Please specify the control directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return getattr(directories, string)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple control&#39;
</span><span class="noop">                          &#39;directories, but none is in accordance with the  &#39;
</span><span class="noop">                          &#39;first simulation date (%s).  Please specify&#39;
</span><span class="noop">                          &#39;the control directory to be worked with manually.&#39;
</span><span class="noop">                          % (self.projectpath, string))
</span><span class="hit">    def _setloaddirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._loaddirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;condition directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="hit">    def _delloaddirectory(self):
</span><span class="miss">        self._loaddirectory = None
</span><span class="hit">    loaddirectory = property(_getloaddirectory, _setloaddirectory,
</span><span class="noop">                             _delloaddirectory)
</span><span class="noop">
</span><span class="hit">    def _getsavedirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or only selectable) final conditions directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.conditiondirectories
</span><span class="miss">        if self._savedirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._savedirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified conditions directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._savedirectory))
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;conditions directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            string = &#39;init_&#39; + pub.timegrids.sim.lastdate.string(&#39;os&#39;)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple control&#39;
</span><span class="noop">                          &#39;directories, and no last simulation date is &#39;
</span><span class="noop">                          &#39;available to determine the relevant one.  &#39;
</span><span class="noop">                          &#39;Please specify the control directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return getattr(directories, string)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple control&#39;
</span><span class="noop">                          &#39;directories, but none is in accordance with the  &#39;
</span><span class="noop">                          &#39;last simulation date (%s).  Please specify&#39;
</span><span class="noop">                          &#39;the control directory to be worked with manually.&#39;
</span><span class="noop">                          % (self.projectpath, string))
</span><span class="hit">    def _setsavedirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._savedirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;condition directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="hit">    def _delsavedirectory(self):
</span><span class="miss">        self._loaddirectory = None
</span><span class="hit">    savedirectory = property(_getsavedirectory, _setsavedirectory,
</span><span class="noop">                             _delsavedirectory)
</span><span class="noop">
</span><span class="hit">    def _getloadpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the relevant initial condition directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.loaddirectory)
</span><span class="hit">    loadpath = property(_getloadpath)
</span><span class="noop">
</span><span class="hit">    def _getsavepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the relevant final condition directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.savedirectory)
</span><span class="hit">    savepath = property(_getsavepath)
</span><span class="noop">
</span><span class="hit">    def loadfile(self, filename, dirname=None):
</span><span class="miss">        if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">            filename += &#39;.py&#39;
</span><span class="miss">        if dirname is None:
</span><span class="miss">            dirname = os.path.join(pub.conditionmanager.loadpath)
</span><span class="miss">        filepath = os.path.join(dirname, filename)
</span><span class="miss">        try:
</span><span class="miss">            with file(filepath) as file_:
</span><span class="miss">                return file_.read()
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = &#39;While trying to read the conditions file `%s`&#39; % filepath
</span><span class="miss">            objecttools.augmentexcmessage(prefix)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import time
</span><span class="hit">import warnings
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="hit">from hydpy.core import magictools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HydPy(object):
</span><span class="noop">    &#34;&#34;&#34;HydPy for single processing.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # A counter for the number of HydPy instances.
</span><span class="hit">    nmb_instances = 0
</span><span class="noop">
</span><span class="hit">    def __init__(self, projectname):
</span><span class="noop">
</span><span class="miss">        if pub.options.printprogress:
</span><span class="miss">            print(&#39;HydPy initialization started at&#39;, time.strftime(&#39;%X&#39;))
</span><span class="noop">
</span><span class="noop">        # Increment and check number of HydPy instances.
</span><span class="miss">        HydPy.nmb_instances += 1
</span><span class="miss">        if HydPy.nmb_instances &gt; 1:
</span><span class="miss">            warnings.warn(&#39;Currently %d instances of HydPy are initialized &#39;
</span><span class="noop">                          &#39;within the same process.  It is strongly &#39;
</span><span class="noop">                          &#39;recommended to initialize only one instance at a &#39;
</span><span class="noop">                          &#39;time.  Consider deleting all instances and &#39;
</span><span class="noop">                          &#39;initializing a new one, unless you are fully aware &#39;
</span><span class="noop">                          &#39;in what manner HydPy is relying on some global &#39;
</span><span class="noop">                          &#39;information stored in modules.&#39;
</span><span class="noop">                          %HydPy.nmb_instances)
</span><span class="noop">
</span><span class="noop">        # Store public information in a seperate module.
</span><span class="miss">        pub.allowcoldstart = False
</span><span class="miss">        pub.projectname = projectname
</span><span class="miss">        pub.filemanager = filetools.MainManager()
</span><span class="miss">        pub.networkmanager = filetools.NetworkManager()
</span><span class="miss">        pub.controlmanager = filetools.ControlManager()
</span><span class="miss">        pub.sequencemanager = filetools.SequenceManager()
</span><span class="miss">        pub.conditionmanager = filetools.ConditionManager()
</span><span class="noop">
</span><span class="miss">        if pub.options.printprogress:
</span><span class="miss">            print(&#39;HydPy initialization ended at&#39;, time.strftime(&#39;%X&#39;))
</span><span class="noop">
</span><span class="hit">    def preparenetwork(self):
</span><span class="miss">        pub.selections = selectiontools.Selections()
</span><span class="miss">        pub.selections += pub.networkmanager.load()
</span><span class="miss">        self.updatedevices(pub.selections.complete)
</span><span class="noop">
</span><span class="hit">    def initmodels(self):
</span><span class="miss">        warn = magictools.simulationstep.warn
</span><span class="miss">        magictools.simulationstep.warn = False
</span><span class="miss">        try:
</span><span class="miss">            for (name, element) in self.elements:
</span><span class="miss">                element.initmodel()
</span><span class="miss">                element.model.parameters.update()
</span><span class="miss">                element.model.connect()
</span><span class="noop">        finally:
</span><span class="miss">            magictools.simulationstep.warn = warn
</span><span class="noop">
</span><span class="hit">    def savecontrols(self, controldirectory=None, projectdirectory=None,
</span><span class="noop">                     parameterstep=None, simulationstep=None):
</span><span class="miss">        _controldirectory = pub.controlmanager._controldirectory
</span><span class="miss">        _projectdirectory = pub.controlmanager._projectdirectory
</span><span class="miss">        try:
</span><span class="miss">            if controldirectory:
</span><span class="miss">                pub.controlmanager.controldirectory = controldirectory
</span><span class="miss">            if projectdirectory:
</span><span class="miss">                pub.controlmanager.projectdirectory = projectdirectory
</span><span class="miss">            for (name, element) in self.elements:
</span><span class="miss">                element.model.parameters.savecontrols(parameterstep,
</span><span class="noop">                                                      simulationstep)
</span><span class="noop">        finally:
</span><span class="miss">            pub.controlmanager._controldirectory = _controldirectory
</span><span class="miss">            pub.controlmanager._projectdirectory = _projectdirectory
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    def loadconditions(self, conditiondirectory=None, controldirectory=None,
</span><span class="noop">                       projectdirectory=None, ):
</span><span class="miss">        self._ioconditions(conditiondirectory,  controldirectory,
</span><span class="noop">                           projectdirectory, True)
</span><span class="noop">
</span><span class="hit">    def saveconditions(self, conditiondirectory=None, controldirectory=None,
</span><span class="noop">                       projectdirectory=None):
</span><span class="miss">        self._ioconditions(conditiondirectory,  controldirectory,
</span><span class="noop">                           projectdirectory, False)
</span><span class="noop">
</span><span class="hit">    def _ioconditions(self, conditiondirectory, controldirectory,
</span><span class="noop">                      projectdirectory, loadflag):
</span><span class="miss">        if loadflag:
</span><span class="miss">            _conditiondirectory = pub.conditionmanager._loaddirectory
</span><span class="noop">        else:
</span><span class="miss">            _conditiondirectory = pub.conditionmanager._savedirectory
</span><span class="miss">        _controldirectory = pub.controlmanager._controldirectory
</span><span class="miss">        _projectdirectory = pub.conditionmanager._projectdirectory
</span><span class="miss">        try:
</span><span class="miss">            if projectdirectory:
</span><span class="miss">                pub.conditionmanager.projectdirectory = projectdirectory
</span><span class="miss">            if conditiondirectory:
</span><span class="miss">                if loadflag:
</span><span class="miss">                    pub.conditionmanager.loaddirectory = conditiondirectory
</span><span class="noop">                else:
</span><span class="miss">                    pub.conditionmanager.savedirectory = conditiondirectory
</span><span class="miss">            if controldirectory:
</span><span class="miss">                pub.controlmanager.controldirectory = controldirectory
</span><span class="miss">            for (name, element) in self.elements:
</span><span class="miss">                if loadflag:
</span><span class="miss">                    element.model.sequences.loadconditions()
</span><span class="noop">                else:
</span><span class="miss">                    element.model.sequences.saveconditions()
</span><span class="noop">        finally:
</span><span class="miss">            if loadflag:
</span><span class="miss">                pub.conditionmanager._loaddirectory = _conditiondirectory
</span><span class="noop">            else:
</span><span class="miss">                pub.conditionmanager._savedirectory = _conditiondirectory
</span><span class="miss">            pub.controlmanager._controldirectory = _controldirectory
</span><span class="miss">            pub.conditionmanager._projectdirectory = _projectdirectory
</span><span class="noop">
</span><span class="hit">    def trimconditions(self):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.model.sequences.trimconditions()
</span><span class="noop">
</span><span class="hit">    def resetconditions(self):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.model.sequences.reset()
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.connect()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def network_properties(self):
</span><span class="miss">        print(&#39;Number of nodes: %d&#39; % len(self.nodes))
</span><span class="miss">        print(&#39;Number of elements: %d&#39; % len(self.elements))
</span><span class="miss">        print(&#39;Number of end nodes: %d&#39; % len(self.endnodes))
</span><span class="miss">        print(&#39;Number of distinct networks: %d&#39; % len(self.distinct_networks))
</span><span class="miss">        print(&#39;Applied node variables: %s&#39; % &#39;, &#39;.join(self.variables))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def distinct_networks(self):
</span><span class="miss">        sels1 = selectiontools.Selections()
</span><span class="miss">        sels2 = selectiontools.Selections()
</span><span class="miss">        complete = selectiontools.Selection(&#39;complete&#39;,
</span><span class="noop">                                            self.nodes, self.elements)
</span><span class="miss">        for (name, node) in self.endnodes:
</span><span class="miss">            sel = complete.copy(name).select_upstream(node)
</span><span class="miss">            sels1 += sel
</span><span class="miss">            sels2 += sel.copy(name)
</span><span class="miss">        for (name1, sel1) in sels1:
</span><span class="miss">            for (name2, sel2) in sels2:
</span><span class="miss">                if name1 != name2:
</span><span class="miss">                    sel1 -= sel2
</span><span class="miss">        for name in sels1.names:
</span><span class="miss">            if not sels1[name].elements:
</span><span class="miss">                del sels1[name]
</span><span class="miss">        return sels1
</span><span class="noop">
</span><span class="hit">    def _updatedeviceorder(self):
</span><span class="miss">        self.deviceorder = []
</span><span class="miss">        for (name, node) in self.endnodes:
</span><span class="miss">            self._nextnode(node)
</span><span class="miss">        self.deviceorder = self.deviceorder[::-1]
</span><span class="noop">
</span><span class="hit">    def _nextnode(self, node):
</span><span class="miss">        for (name, element) in node.exits:
</span><span class="miss">            if ((element in self.elements) and
</span><span class="noop">                (element not in self.deviceorder)):
</span><span class="miss">                if not node in element.receivers:
</span><span class="miss">                    self._nextelement(element)
</span><span class="miss">        if (node in self.nodes) and (node not in self.deviceorder):
</span><span class="miss">            self.deviceorder.append(node)
</span><span class="miss">            for (name, element) in node.entries:
</span><span class="miss">                self._nextelement(element)
</span><span class="noop">
</span><span class="hit">    def _nextelement(self, element):
</span><span class="miss">        for (name, node) in element.outlets:
</span><span class="miss">            if ((node in self.nodes) and
</span><span class="noop">                (node not in self.deviceorder)):
</span><span class="miss">                self._nextnode(node)
</span><span class="miss">        if (element in self.elements) and (element not in self.deviceorder):
</span><span class="miss">            self.deviceorder.append(element)
</span><span class="miss">            for (name, node) in element.inlets:
</span><span class="miss">                self._nextnode(node)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def endnodes(self):
</span><span class="miss">        endnodes = devicetools.Nodes()
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            for (name, element) in node.exits:
</span><span class="miss">                if ((element in self.elements) and
</span><span class="noop">                    (node not in element.receivers)):
</span><span class="miss">                    break
</span><span class="noop">            else:
</span><span class="miss">                endnodes += node
</span><span class="miss">        return endnodes
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variables(self):
</span><span class="miss">        variables = set([])
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            variables.add(node.variable)
</span><span class="miss">        return sorted(variables)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def simindices(self):
</span><span class="miss">        return (pub.timegrids.init[pub.timegrids.sim.firstdate],
</span><span class="noop">                pub.timegrids.init[pub.timegrids.sim.lastdate])
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.model.sequences.openfiles(idx)
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            node.sequences.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.model.sequences.closefiles()
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            node.sequences.closefiles()
</span><span class="noop">
</span><span class="hit">    def updatedevices(self, selection=None):
</span><span class="miss">        if selection is not None:
</span><span class="miss">            self.nodes = selection.nodes
</span><span class="miss">            self.elements = selection.elements
</span><span class="miss">        self._updatedeviceorder()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def funcorder(self):
</span><span class="miss">        funcs = []
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            if node.routingmode == &#39;oldsim&#39;:
</span><span class="miss">                funcs.append(node._loaddata_sim)
</span><span class="miss">            elif node.sequences.obs.use_ext:
</span><span class="miss">                funcs.append(node._loaddata_obs)
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            if element.receivers:
</span><span class="miss">                funcs.append(element.model.updatereceivers)
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            if node.routingmode != &#39;oldsim&#39;:
</span><span class="miss">                funcs.append(node.reset)
</span><span class="miss">        for device in self.deviceorder:
</span><span class="miss">            if isinstance(device, devicetools.Element):
</span><span class="miss">                funcs.append(device.model.doit)
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            if element.senders:
</span><span class="miss">                funcs.append(element.model.updatesenders)
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            if node.routingmode != &#39;oldsim&#39;:
</span><span class="miss">                funcs.append(node._savedata_sim)
</span><span class="miss">        return funcs
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="miss">        idx_start,idx_end = self.simindices
</span><span class="miss">        self.openfiles(idx_start)
</span><span class="miss">        funcorder = self.funcorder
</span><span class="miss">        if pub.options.printprogress:
</span><span class="miss">            maxcounter = int(float(idx_end-idx_start)/20.)
</span><span class="miss">            print(&#39;|&#39;+18*&#39;-&#39;+&#39;|&#39;)
</span><span class="noop">        else:
</span><span class="miss">            maxcounter = idx_end
</span><span class="miss">        counter = 0
</span><span class="miss">        for idx in range(idx_start, idx_end):
</span><span class="miss">            counter += 1
</span><span class="miss">            if counter &gt; maxcounter:
</span><span class="miss">                print(&#39;*&#39;, end=&#39;&#39;)
</span><span class="miss">                counter = 0
</span><span class="miss">            for func in funcorder:
</span><span class="miss">                func(idx)
</span><span class="miss">        if pub.options.printprogress:
</span><span class="miss">            print(&#39;*&#39;)
</span><span class="miss">        self.closefiles()
</span><span class="noop">
</span><span class="hit">    def prepare_modelseries(self, ramflag=True):
</span><span class="miss">        self.prepare_inputseries(ramflag)
</span><span class="miss">        self.prepare_fluxseries(ramflag)
</span><span class="miss">        self.prepare_stateseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_inputseries(self, ramflag=True):
</span><span class="miss">        self._prepare_modelseries(&#39;inputs&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_fluxseries(self, ramflag=True):
</span><span class="miss">        self._prepare_modelseries(&#39;fluxes&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_stateseries(self, ramflag=True):
</span><span class="miss">        self._prepare_modelseries(&#39;states&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def _prepare_modelseries(self, name_subseqs, ramflag):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            sequences = element.model.sequences
</span><span class="miss">            subseqs = getattr(sequences, name_subseqs, None)
</span><span class="miss">            if subseqs:
</span><span class="miss">                if ramflag:
</span><span class="miss">                    subseqs.activate_ram()
</span><span class="noop">                else:
</span><span class="miss">                    subseqs.activate_disk()
</span><span class="noop">
</span><span class="hit">    def prepare_nodeseries(self, ramflag=True):
</span><span class="miss">        self.prepare_simseries(ramflag)
</span><span class="miss">        self.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_simseries(self, ramflag=True):
</span><span class="miss">        self._prepare_nodeseries(&#39;sim&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_obsseries(self, ramflag=True):
</span><span class="miss">        self._prepare_nodeseries(&#39;obs&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def _prepare_nodeseries(self, seqname, ramflag):
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            seq = getattr(node.sequences, seqname)
</span><span class="miss">            if ramflag:
</span><span class="miss">                seq.activate_ram()
</span><span class="noop">            else:
</span><span class="miss">                seq.activate_disk()
</span><span class="noop">
</span><span class="hit">    def save_modelseries(self):
</span><span class="miss">        self.save_inputseries()
</span><span class="miss">        self.save_fluxseries()
</span><span class="miss">        self.save_stateseries()
</span><span class="noop">
</span><span class="hit">    def save_inputseries(self):
</span><span class="miss">        self._save_modelseries(&#39;inputs&#39;, pub.sequencemanager.inputoverwrite)
</span><span class="noop">
</span><span class="hit">    def save_fluxseries(self):
</span><span class="miss">        self._save_modelseries(&#39;fluxes&#39;, pub.sequencemanager.outputoverwrite)
</span><span class="noop">
</span><span class="hit">    def save_stateseries(self):
</span><span class="miss">        self._save_modelseries(&#39;states&#39;, pub.sequencemanager.outputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _save_modelseries(self, name_subseqs, overwrite):
</span><span class="miss">        for (name1, element) in self.elements:
</span><span class="miss">            sequences = element.model.sequences
</span><span class="miss">            subseqs = getattr(sequences, name_subseqs, ())
</span><span class="miss">            for (name2, seq) in subseqs:
</span><span class="miss">                if seq.memoryflag:
</span><span class="miss">                    if overwrite or not os.path.exists(seq.filepath_ext):
</span><span class="miss">                        seq.save_ext()
</span><span class="noop">                    else:
</span><span class="miss">                        warnings.warn(&#39;Due to the argument `overwrite` beeing &#39;
</span><span class="noop">                                      &#39;`False` it is not allowed to overwrite &#39;
</span><span class="noop">                                      &#39;the already existing file `%s`.&#39;
</span><span class="noop">                                      % seq.filepath_ext)
</span><span class="noop">
</span><span class="hit">    def save_nodeseries(self):
</span><span class="miss">        self.save_simseries()
</span><span class="miss">        self.save_obsseries()
</span><span class="noop">
</span><span class="hit">    def save_simseries(self, ramflag=True):
</span><span class="miss">        self._save_nodeseries(&#39;sim&#39;, pub.sequencemanager.simoverwrite)
</span><span class="noop">
</span><span class="hit">    def save_obsseries(self, ramflag=True):
</span><span class="miss">        self._save_nodeseries(&#39;obs&#39;, pub.sequencemanager.obsoverwrite)
</span><span class="noop">
</span><span class="hit">    def _save_nodeseries(self, seqname, overwrite):
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            seq = getattr(node.sequences, seqname)
</span><span class="miss">            if seq.memoryflag:
</span><span class="miss">                if overwrite or not os.path.exists(seq.filepath_ext):
</span><span class="miss">                    seq.save_ext()
</span><span class="noop">                else:
</span><span class="miss">                    warnings.warn(&#39;Due to the argument `overwrite` beeing &#39;
</span><span class="noop">                                  &#39;`False` it is not allowed to overwrite &#39;
</span><span class="noop">                                  &#39;the already existing file `%s`.&#39;
</span><span class="noop">                                  % seq.filepath_ext)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">#from hydpy.pub import ... (actual import commands moved to
</span><span class="noop"># different functions below to avoid circular dependencies)
</span><span class="noop">
</span><span class="hit">class Indexer(object):
</span><span class="noop">    &#34;&#34;&#34;Handles arrays containing indexes.  One can specify these array indexes
</span><span class="noop">    manually, but usually they are determined automatically based on the
</span><span class="noop">    :class:`~hydpy.core.timetools.Timegrids` object made available through
</span><span class="noop">    module :mod:`~hydpy.pub`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self._monthofyear = None
</span><span class="hit">        self._dayofyear = None
</span><span class="noop">
</span><span class="hit">    def _getmonthofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Month of the year index (January = 0...).&#34;&#34;&#34;
</span><span class="hit">        if self._monthofyear is None:
</span><span class="hit">            self._monthofyear = self._calcidxs(lambda date: date.month-1,
</span><span class="noop">                                               &#39;monthofyear&#39;)
</span><span class="hit">        return self._monthofyear
</span><span class="hit">    def _setmonthofyear(self, values):
</span><span class="hit">        self._monthofyear = self._convertandtest(values, &#39;monthofyear&#39;)
</span><span class="hit">    def _delmonthofyear(self):
</span><span class="hit">        self._monthofyear = None
</span><span class="hit">    monthofyear = property(_getmonthofyear, _setmonthofyear, _delmonthofyear)
</span><span class="noop">
</span><span class="hit">    def _getdayofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Day of the year index (the first of January = 0...).
</span><span class="noop">
</span><span class="noop">        For reasons of consistency between leap years and non-leap years,
</span><span class="noop">        assuming a daily time step, index 59 is always associated with the
</span><span class="noop">        29th of February.  Hence, it is missing in non-leap years:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.indextools import Indexer
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2004&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2004&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 59, 60, 61])
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2005&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2005&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 60, 61])
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self._dayofyear is None:
</span><span class="hit">            func = lambda date: (date.dayofyear - 1 +
</span><span class="noop">                                 ((date.month &gt; 2) and (not date.leapyear)))
</span><span class="hit">            self._dayofyear = self._calcidxs(func, &#39;dayofyear&#39;)
</span><span class="hit">        return self._dayofyear
</span><span class="hit">    def _setdayofyear(self, values):
</span><span class="hit">        self._dayofyear = self._convertandtest(values, &#39;dayofyear&#39;)
</span><span class="hit">    def _deldayofyear(self):
</span><span class="hit">        self._dayofyear = None
</span><span class="hit">    dayofyear = property(_getdayofyear, _setdayofyear, _deldayofyear)
</span><span class="noop">
</span><span class="hit">    def _convertandtest(self, values, name):
</span><span class="noop">        &#34;&#34;&#34;Try to convert the given values to a :mod:`numpy`
</span><span class="noop">        :class:`~numpy.ndarrray` and check if it is plausible.  If so, return
</span><span class="noop">        the array, other raise a :class:`~exceptions.ValueError` or re-raise a
</span><span class="noop">        :mod:`numpy` specific exception.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        try:
</span><span class="hit">            array = numpy.array(values, dtype=int)
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to assign a new `%s` &#39;
</span><span class="noop">                                          &#39;index array to an Indexer object&#39;
</span><span class="noop">                                          % name)
</span><span class="hit">        if array.ndim != 1:
</span><span class="hit">            raise ValueError(&#39;The `%s` index array of an Indexer object must &#39;
</span><span class="noop">                             &#39;be 1-dimensional.  However, the given value has &#39;
</span><span class="noop">                             &#39;interpreted as a %d-dimensional object.&#39;
</span><span class="noop">                             % (name, array.ndim))
</span><span class="hit">        if timegrids is not None:
</span><span class="hit">            if len(array) != len(timegrids.init):
</span><span class="hit">                raise ValueError(&#39;The %s` index array of an Indexer object &#39;
</span><span class="noop">                                 &#39;must have a number of entries fitting to &#39;
</span><span class="noop">                                 &#39;the initialization time period precisely.  &#39;
</span><span class="noop">                                 &#39;However, the given value has been &#39;
</span><span class="noop">                                 &#39;interpreted to be of length %d and the &#39;
</span><span class="noop">                                 &#39;length of the Timegrid object representing &#39;
</span><span class="noop">                                 &#39;the actual initialization time period is %d.&#39;
</span><span class="noop">                                 % (name, len(array), len(timegrids.init)))
</span><span class="hit">        return array
</span><span class="noop">
</span><span class="hit">    def _calcidxs(self, func, name):
</span><span class="noop">        &#34;&#34;&#34;Return the required indexes based on the given lambda function and
</span><span class="noop">        the :class:`~hydpy.core.timetools.Timegrids` object handled by module
</span><span class="noop">        :mod:`~hydpy.pub`.  Raise a :class:`~exceptions.RuntimeError` if the
</span><span class="noop">        latter is not available.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        if timegrids is None:
</span><span class="hit">            raise RuntimeError(&#39;An Indexer object has been asked for an &#39;
</span><span class="noop">                               &#39;%s array.  Such an array has neither been&#39;
</span><span class="noop">                               &#39;determined yet nor can it be determined &#39;
</span><span class="noop">                               &#39;automatically at the moment.   Either &#39;
</span><span class="noop">                               &#39;define an %s array manually and pass it to &#39;
</span><span class="noop">                               &#39;the Indexer object, or make a proper &#39;
</span><span class="noop">                               &#39;Timegrids object available within the pub &#39;
</span><span class="noop">                               &#39;module.  In usual HydPy applications, the &#39;
</span><span class="noop">                               &#39;latter is done automatically.&#39;
</span><span class="noop">                               % (name, name))
</span><span class="hit">        idxs = numpy.empty(len(timegrids.init), dtype=int)
</span><span class="hit">        for (jdx, date) in enumerate(timegrids.init):
</span><span class="hit">            idxs[jdx] = func(date)
</span><span class="hit">        return idxs
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from the Python standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import inspect
</span><span class="hit">import warnings
</span><span class="hit">import importlib
</span><span class="hit">import doctest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="noop">
</span><span class="hit">_warnsimulationstep = True
</span><span class="noop">
</span><span class="hit">class Tester(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        frame = inspect.currentframe().f_back
</span><span class="hit">        self.filepath = frame.f_code.co_filename
</span><span class="hit">        self.package = frame.f_locals[&#39;__package__&#39;]
</span><span class="hit">        self.ispackage = os.path.split(self.filepath)[-1] == &#39;__init__.py&#39;
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def filenames(self):
</span><span class="miss">        if self.ispackage:
</span><span class="miss">            return os.listdir(os.path.dirname(self.filepath))
</span><span class="noop">        else:
</span><span class="miss">            return [self.filepath]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modulenames(self):
</span><span class="miss">        return [os.path.split(fn)[-1].split(&#39;.&#39;)[0] for fn in self.filenames
</span><span class="noop">                if (fn.endswith(&#39;.py&#39;) and not fn.startswith(&#39;_&#39;))]
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="miss">        timegrids = pub.timegrids
</span><span class="miss">        pub.timegrids = None
</span><span class="miss">        dirverbose = pub.options.dirverbose
</span><span class="miss">        reprcomments = pub.options.reprcomments
</span><span class="miss">        pub.options.reprcomments = False
</span><span class="miss">        reprdigits = pub.options.reprdigits
</span><span class="miss">        pub.options.reprdigits = 6
</span><span class="miss">        warntrim = pub.options.warntrim
</span><span class="miss">        pub.options.warntrim = False
</span><span class="miss">        nodes = devicetools.Node._registry.copy()
</span><span class="miss">        elements = devicetools.Element._registry.copy()
</span><span class="miss">        devicetools.Node.clearregistry()
</span><span class="miss">        devicetools.Element.clearregistry()
</span><span class="miss">        try:
</span><span class="miss">            color = 34 if pub.options.usecython else 36
</span><span class="miss">            with PrintStyle(color=color, font=4):
</span><span class="miss">                print(&#39;Test %s %s in %sython mode.&#39;
</span><span class="noop">                    % (&#39;package&#39; if self.ispackage else &#39;module&#39;,
</span><span class="noop">                       self.package if self.ispackage else self.modulenames[0],
</span><span class="noop">                       &#39;C&#39; if pub.options.usecython else &#39;P&#39;))
</span><span class="miss">            with PrintStyle(color=color, font=2):
</span><span class="miss">                for name in self.modulenames:
</span><span class="miss">                    print(&#39;    * %s:&#39; % name, )
</span><span class="miss">                    with StdOutErr(indent=8):
</span><span class="miss">                        modulename = &#39;.&#39;.join((self.package, name))
</span><span class="miss">                        module = importlib.import_module(modulename)
</span><span class="miss">                        doctest.testmod(module, extraglobs={&#39;testing&#39;: True})
</span><span class="noop">        finally:
</span><span class="miss">            pub.timegrids = timegrids
</span><span class="miss">            pub.options.dirverbose = dirverbose
</span><span class="miss">            pub.options.reprcomments = reprcomments
</span><span class="miss">            pub.options.reprdigits = reprdigits
</span><span class="miss">            pub.options.warntrim = warntrim
</span><span class="miss">            devicetools.Node.clearregistry()
</span><span class="miss">            devicetools.Element.clearregistry()
</span><span class="miss">            devicetools.Node._registry = nodes
</span><span class="miss">            devicetools.Element._registry = elements
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PrintStyle(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, color, font):
</span><span class="hit">        self.color = color
</span><span class="hit">        self.font = font
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="hit">        print(&#39;\x1B[%d;30;%dm&#39; % (self.font, self.color))
</span><span class="noop">
</span><span class="hit">    def __exit__(self, exception, message, traceback_):
</span><span class="hit">        print(&#39;\x1B[0m&#39;)
</span><span class="hit">        if exception:
</span><span class="miss">            objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StdOutErr(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, indent=0):
</span><span class="miss">        self.indent = indent
</span><span class="miss">        self.stdout = sys.stdout
</span><span class="miss">        self.stderr = sys.stderr
</span><span class="miss">        self.texts = []
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="miss">        sys.stdout = self
</span><span class="miss">        sys.stderr = self
</span><span class="noop">
</span><span class="hit">    def __exit__(self, exception, message, traceback_):
</span><span class="miss">        if not self.texts:
</span><span class="miss">            self.print_(&#39;no failures occurred&#39;)
</span><span class="noop">        else:
</span><span class="miss">            for text in self.texts:
</span><span class="miss">                self.print_(text)
</span><span class="miss">        sys.stdout = self.stdout
</span><span class="miss">        sys.stderr = self.stderr
</span><span class="miss">        if exception:
</span><span class="miss">            objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="hit">    def write(self, text):
</span><span class="miss">        self.texts.extend(text.split(&#39;\n&#39;))
</span><span class="noop">
</span><span class="hit">    def print_(self, text):
</span><span class="miss">        if text.strip():
</span><span class="miss">            self.stdout.write(self.indent*&#39; &#39; + text + &#39;\n&#39;)
</span><span class="noop">
</span><span class="hit">    def flush(self):
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def parameterstep(timestep=None):
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    Define a parameter time step size within a parameter control file.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">      * timestep(:class:`~hydpy.core.timetools.Period`): Time step size.
</span><span class="noop">
</span><span class="noop">    Function :func:`parameterstep` should usually be be applied in a line
</span><span class="noop">    immediately behind the model import.  Defining the step size of time
</span><span class="noop">    dependent parameters is a prerequisite to access any model specific
</span><span class="noop">    parameter.
</span><span class="noop">
</span><span class="noop">    Note that :func:`parameterstep` implements some namespace magic by
</span><span class="noop">    means of the module :mod:`inspect`.  This makes things a little
</span><span class="noop">    complicated for framework developers, but it eases the definition of
</span><span class="noop">    parameter control files for framework users.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if timestep is not None:
</span><span class="hit">        parametertools.Parameter._parameterstep = timetools.Period(timestep)
</span><span class="hit">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="hit">    model = namespace.get(&#39;model&#39;)
</span><span class="hit">    if model is None:
</span><span class="hit">        model = namespace[&#39;Model&#39;]()
</span><span class="hit">        namespace[&#39;model&#39;] = model
</span><span class="hit">        if pub.options.usecython and &#39;cythonizer&#39; in namespace:
</span><span class="hit">            cythonizer = namespace[&#39;cythonizer&#39;]
</span><span class="hit">            namespace[&#39;cythonmodule&#39;] = cythonizer.cymodule
</span><span class="hit">            model.cymodel = cythonizer.cymodule.Model()
</span><span class="hit">            namespace[&#39;cymodel&#39;] = model.cymodel
</span><span class="hit">            for (name, func) in cythonizer.pyxwriter.listofmodeluserfunctions:
</span><span class="hit">                setattr(model, name, getattr(model.cymodel, name))
</span><span class="hit">            for func in (&#39;doit&#39;, &#39;new2old&#39;, &#39;openfiles&#39;, &#39;closefiles&#39;,
</span><span class="noop">                         &#39;loaddata&#39;, &#39;savedata&#39;):
</span><span class="hit">                if hasattr(model.cymodel, func):
</span><span class="hit">                    setattr(model, func, getattr(model.cymodel, func))
</span><span class="hit">        model.parameters = namespace[&#39;Parameters&#39;](namespace)
</span><span class="hit">        model.sequences = namespace[&#39;Sequences&#39;](namespace)
</span><span class="hit">        namespace[&#39;parameters&#39;] = model.parameters
</span><span class="hit">        for (name, pars) in model.parameters:
</span><span class="hit">            namespace[name] = pars
</span><span class="hit">        namespace[&#39;sequences&#39;] = model.sequences
</span><span class="hit">        for (name, seqs) in model.sequences:
</span><span class="hit">            namespace[name] = seqs
</span><span class="hit">    try:
</span><span class="hit">        namespace.update(namespace[&#39;CONSTANTS&#39;])
</span><span class="hit">    except KeyError:
</span><span class="hit">        pass
</span><span class="hit">    focus = namespace.get(&#39;focus&#39;)
</span><span class="hit">    for (name, par) in model.parameters.control:
</span><span class="hit">        try:
</span><span class="hit">            if (focus is None) or (par is focus):
</span><span class="hit">                namespace[par.name] = par
</span><span class="noop">            else:
</span><span class="miss">                namespace[par.name] = lambda *args, **kwargs: None
</span><span class="miss">        except AttributeError:
</span><span class="miss">            pass
</span><span class="noop">
</span><span class="hit">class Simulationstep(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.warn = True
</span><span class="noop">
</span><span class="hit">    def __call__(self, timestep, warn=True):
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        Define a simulation time step size for testing purposes within a
</span><span class="noop">        parameter control file.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * timestep(:class:`~hydpy.core.timetools.Period): Time step size.
</span><span class="noop">
</span><span class="noop">        Using :func:`simulationstep` only affects the values of time dependent
</span><span class="noop">        parameters, when `pub.timegrids.stepsize` is not defined.  It thus has
</span><span class="noop">        no influence on usual hydpy simulations at all.  Use it just to check
</span><span class="noop">        your parameter control files.  Write it in a line immediately behind the
</span><span class="noop">        one calling :func:`parameterstep`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if warn and self.warn:
</span><span class="miss">            warnings.warn(&#39;Note that the applied function `simulationstep` is &#39;
</span><span class="noop">                          &#39;inteded for testing purposes only.  When doing a &#39;
</span><span class="noop">                          &#39;hydpy simulation, parameter values are initialized &#39;
</span><span class="noop">                          &#39;based on the actual simulation time step as defined &#39;
</span><span class="noop">                          &#39;under `pub.timegrids.stepsize` and the value given &#39;
</span><span class="noop">                          &#39;to `simulationstep` is ignored.&#39;)
</span><span class="hit">        parametertools.Parameter._simulationstep = timetools.Period(timestep)
</span><span class="noop">
</span><span class="hit">simulationstep = Simulationstep()
</span><span class="noop">
</span><span class="hit">def controlcheck(controldir=&#39;default&#39;, projectdir=None, controlfile=None):
</span><span class="miss">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="miss">    model = namespace.get(&#39;model&#39;)
</span><span class="miss">    if model is None:
</span><span class="miss">        if projectdir is None:
</span><span class="miss">            projectdir = os.path.split(os.path.dirname(os.path.abspath(os.curdir)))[-1]
</span><span class="miss">        os.chdir(os.path.join(&#39;..&#39;, &#39;..&#39;, &#39;..&#39;))
</span><span class="miss">        controlpath = os.path.abspath(os.path.join(&#39;control&#39;, projectdir, controldir))
</span><span class="miss">        initfile = os.path.split(namespace[&#39;__file__&#39;])[-1]
</span><span class="miss">        if controlfile is None:
</span><span class="miss">            controlfile = initfile
</span><span class="miss">        filepath = os.path.join(controlpath, controlfile)
</span><span class="miss">        if not os.path.exists(filepath):
</span><span class="miss">            raise IOError(&#39;The check of consistency between the control &#39;
</span><span class="noop">                          &#39;parameter file %s and the initial condition file &#39;
</span><span class="noop">                          &#39;%s failed.  The control parameter file does not &#39;
</span><span class="noop">                          &#39;exist in directory %s.&#39;
</span><span class="noop">                          % (controlfile, initfile, controlpath))
</span><span class="miss">        controlmanager = filetools.ControlManager()
</span><span class="miss">        controlmanager.projectdirectory = projectdir
</span><span class="miss">        controlmanager.selecteddirectory = controldir
</span><span class="miss">        model = controlmanager.loadfile(controlfile)[&#39;model&#39;]
</span><span class="miss">        model.parameters.update()
</span><span class="miss">        namespace[&#39;model&#39;] = model
</span><span class="miss">        for name1 in (&#39;states&#39;, &#39;logs&#39;):
</span><span class="miss">            subseqs = getattr(model.sequences, name1, None)
</span><span class="miss">            if subseqs is not None:
</span><span class="miss">                for (name2, seq) in subseqs:
</span><span class="miss">                    namespace[name2] = seq</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for hydrological models.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.element = None
</span><span class="hit">        self.parameters = None
</span><span class="hit">        self.sequences = None
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="noop">        &#34;&#34;&#34;Connect the link sequences of the actual model.&#34;&#34;&#34;
</span><span class="miss">        conname_isexit_pairs = ((&#39;inlets&#39;, True),
</span><span class="noop">                                (&#39;receivers&#39;, True),
</span><span class="noop">                                (&#39;outlets&#39;, False),
</span><span class="noop">                                (&#39;senders&#39;, False))
</span><span class="miss">        for (conname, isexit) in conname_isexit_pairs:
</span><span class="miss">            nodes = getattr(self.element, conname).slaves
</span><span class="miss">            if len(nodes) == 1:
</span><span class="miss">                node = nodes[0]
</span><span class="miss">                links = getattr(self.sequences, conname)
</span><span class="miss">                seq = getattr(links, node.variable.lower(), None)
</span><span class="miss">                if seq is None:
</span><span class="miss">                    RuntimeError(&#39;ToDo&#39;)
</span><span class="miss">                elif isexit:
</span><span class="miss">                    seq.setpointer(node.getdouble_via_exits())
</span><span class="noop">                else:
</span><span class="miss">                    seq.setpointer(node.getdouble_via_entries())
</span><span class="noop">            else:
</span><span class="miss">                NotImplementedError(&#39;ToDo&#39;)
</span><span class="noop">#        nodes = self.element.inlets.slaves
</span><span class="noop">#        if len(nodes) == 1:
</span><span class="noop">#            node = nodes[0]
</span><span class="noop">#            seq = getattr(self.sequences.inlets, node.variable.lower(), None)
</span><span class="noop">#            if seq is None:
</span><span class="noop">#                RuntimeError(&#39;ToDo&#39;)
</span><span class="noop">#            else:
</span><span class="noop">#                seq.setpointer(node.getdouble_via_exits())
</span><span class="noop">#        else:
</span><span class="noop">#            NotImplementedError(&#39;ToDo&#39;)
</span><span class="noop">#        nodes = self.element.outlets.slaves
</span><span class="noop">#        if not nodes:
</span><span class="noop">#            RuntimeError(&#39;ToDo&#39;)
</span><span class="noop">#        elif len(nodes) == 1:
</span><span class="noop">#            node = nodes[0]
</span><span class="noop">#            seq = getattr(self.sequences.outlets, node.variable.lower(), None)
</span><span class="noop">#            if seq is None:
</span><span class="noop">#                RuntimeError(&#39;ToDo&#39;)
</span><span class="noop">#            else:
</span><span class="noop">#                seq.setpointer(node.getdouble_via_entries())
</span><span class="noop">#        else:
</span><span class="noop">#            NotImplementedError(&#39;ToDo&#39;)
</span><span class="noop">
</span><span class="hit">    def updatereceivers(self, idx):
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="hit">    def updatesenders(self, idx):
</span><span class="hit">        pass
</span><span class="noop">
</span><span class="hit">    def doit(self, idx):
</span><span class="hit">        self.loaddata(idx)
</span><span class="hit">        self.updateinlets(idx)
</span><span class="hit">        self.run(idx)
</span><span class="hit">        self.updateoutlets(idx)
</span><span class="hit">        self.updatesenders(idx)
</span><span class="hit">        self.new2old()
</span><span class="hit">        self.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="hit">        self.sequences.loaddata(idx)
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        self.sequences.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def updateinlets(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Maybe.&#34;&#34;&#34;
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="hit">    def updateoutlets(self, idx):
</span><span class="noop">        &#34;&#34;&#34;In any case.&#34;&#34;&#34;
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="noop">        &#34;&#34;&#34;Assign the new/final state values of the actual time step to the
</span><span class="noop">        new/initial state values of the next time step.  Needs to be
</span><span class="noop">        overwritten in Cython mode.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            self.sequences.states.new2old()
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import inspect
</span><span class="hit">import sys
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="noop">#from hydpy.pub import ... (actual import commands moved to
</span><span class="noop"># different functions below to avoid circular dependencies)
</span><span class="noop">
</span><span class="hit">def dir_(self):
</span><span class="noop">    &#34;&#34;&#34;The prefered way for HydPy objects to respond to :func:`dir`.
</span><span class="noop">
</span><span class="noop">    Note thedepencence on the `pub.options.dirverbose`.  If this option is
</span><span class="noop">    set `True`, all attributes and methods of the given instance and its
</span><span class="noop">    class (including those inherited from the parent classes) are returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; options.dirverbose = True
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import dir_
</span><span class="noop">    &gt;&gt;&gt; class Test(object):
</span><span class="noop">    ...     only_public_attribute =  None
</span><span class="noop">    &gt;&gt;&gt; print(len(dir_(Test())) &gt; 1) # Long list, try it yourself...
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    If the option is set to `False`, only the `public` attributes and methods
</span><span class="noop">    (which do need begin with `_`) are returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.dirverbose = False
</span><span class="noop">    &gt;&gt;&gt; print(dir_(Test())) # Short list with one single entry...
</span><span class="noop">    [&#39;only_public_attribute&#39;]
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    from hydpy.pub import options
</span><span class="hit">    names = set()
</span><span class="hit">    for thing in list(inspect.getmro(type(self))) + [self]:
</span><span class="hit">        for name in vars(thing).keys():
</span><span class="hit">            if options.dirverbose or not name.startswith(&#39;_&#39;):
</span><span class="hit">                names.add(name)
</span><span class="hit">    if names:
</span><span class="hit">        names = list(names)
</span><span class="noop">    else:
</span><span class="miss">        names = [&#39; &#39;]
</span><span class="hit">    return names
</span><span class="noop">
</span><span class="hit">def classname(self):
</span><span class="noop">    &#34;&#34;&#34;Return the class name of the given instance object or class.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import classname
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(classname(float))
</span><span class="noop">    float
</span><span class="noop">    &gt;&gt;&gt; print(classname(options))
</span><span class="noop">    Options
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if not inspect.isclass(self):
</span><span class="hit">        self = type(self)
</span><span class="hit">    return str(self).split(&#34;&#39;&#34;)[1].split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="hit">def instancename(self):
</span><span class="noop">    &#34;&#34;&#34;Return the class name of the given instance object or class in lower
</span><span class="noop">    case letters.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import instancename
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(instancename(options))
</span><span class="noop">    options
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return classname(self).lower()
</span><span class="noop">
</span><span class="hit">def modulename(self):
</span><span class="noop">    &#34;&#34;&#34;Return the module name of the given instance object.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import modulename
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(modulename(options))
</span><span class="noop">    objecttools
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return self.__module__.split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="hit">def devicename(self):
</span><span class="noop">    &#34;&#34;&#34;Try to return the name of the (indirect) master
</span><span class="noop">    :class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">    :class:`~hydpy.core.devicetools.Element` instance,
</span><span class="noop">    otherwise return `?`.&#34;&#34;&#34;
</span><span class="hit">    while True:
</span><span class="hit">        device = getattr(self, &#39;element&#39;, getattr(self, &#39;node&#39;, None))
</span><span class="hit">        if device is not None:
</span><span class="miss">            return device.name
</span><span class="hit">        for test in (&#39;model&#39;, &#39;seqs&#39;, &#39;subseqs&#39;, &#39;pars&#39;, &#39;subpars&#39;):
</span><span class="hit">            master = getattr(self, test, None)
</span><span class="hit">            if master is not None:
</span><span class="hit">                self = master
</span><span class="hit">                break
</span><span class="noop">        else:
</span><span class="hit">            return &#39;?&#39;
</span><span class="noop">
</span><span class="hit">def augmentexcmessage(prefix=None, suffix=None):
</span><span class="noop">    &#34;&#34;&#34;Augment an exception message with additional information while keeping
</span><span class="noop">    the original traceback.
</span><span class="noop">
</span><span class="noop">    You can prefix and/or suffix text.  If you prefix something (which happens
</span><span class="noop">    much more often in the HydPy framework), the sub-clause &#39;, the following
</span><span class="noop">    error occured:&#39; is automatically included:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core import objecttools
</span><span class="noop">    &gt;&gt;&gt; import textwrap
</span><span class="noop">    &gt;&gt;&gt; try:
</span><span class="noop">    ...     1 + &#39;1&#39;
</span><span class="noop">    ... except TypeError:
</span><span class="noop">    ...     try:
</span><span class="noop">    ...         prefix = &#39;While showing how prefixing works&#39;
</span><span class="noop">    ...         suffix = &#39;(This is a final remark.)&#39;
</span><span class="noop">    ...         objecttools.augmentexcmessage(prefix, suffix)
</span><span class="noop">    ...     except TypeError as exc:
</span><span class="noop">    ...         for line in textwrap.wrap(exc.args[0], width=76):
</span><span class="noop">    ...             print(line)
</span><span class="noop">    While showing how prefixing works, the following error occured: unsupported
</span><span class="noop">    operand type(s) for +: &#39;int&#39; and &#39;str&#39; (This is a final remark.)
</span><span class="noop">
</span><span class="noop">    Note that the ancillary purpose of function :func:`augmentexcmessage` is
</span><span class="noop">    to make re-raising exceptions compatible with both Python 2 and 3.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    from hydpy.pub import pyversion
</span><span class="hit">    exception, message, traceback_ = sys.exc_info()
</span><span class="hit">    if prefix is not None:
</span><span class="hit">        message = (&#39;%s, the following error occured: %s&#39;
</span><span class="noop">                    % (prefix, message))
</span><span class="hit">    if suffix is not None:
</span><span class="hit">        message = &#39; &#39;.join((message, suffix))
</span><span class="hit">    if pyversion &lt; 3:
</span><span class="hit">        exec(&#39;raise exception, message, traceback_&#39;)
</span><span class="noop">    else:
</span><span class="miss">        raise exception(message).with_traceback(traceback_)
</span><span class="noop">
</span><span class="hit">def repr_(value):
</span><span class="noop">    &#34;&#34;&#34;Modifies :func:`repr` for strings and floats, mainly for supporting
</span><span class="noop">    clean float representations that are compatible with :mod:`doctest`.
</span><span class="noop">
</span><span class="noop">    When value is a string, it is returned without any modification:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import repr_
</span><span class="noop">    &gt;&gt;&gt; repr(&#39;test&#39;)
</span><span class="noop">    &#34;&#39;test&#39;&#34;
</span><span class="noop">    &gt;&gt;&gt; repr_(&#39;test&#39;)
</span><span class="noop">    &#39;test&#39;
</span><span class="noop">
</span><span class="noop">    When value is a float, the result depends on how the option
</span><span class="noop">    :attr:`~Options.reprdigits` is set. If it is :class:`None`, :func:`repr`
</span><span class="noop">    defines the number of digits in the usual, system dependend manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; options.reprdigits = None
</span><span class="noop">    &gt;&gt;&gt; repr(1./3.) == repr_(1./3.)
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    Through setting :attr:`~Options.reprdigits` to a positive integer value,
</span><span class="noop">    one defines the maximum number of decimal places, which allows for
</span><span class="noop">    doctesting across different systems and Python versions:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.reprdigits = 6
</span><span class="noop">    &gt;&gt;&gt; repr_(1./3.)
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(2./3.)
</span><span class="noop">    &#39;0.666667&#39;
</span><span class="noop">    &gt;&gt;&gt; repr(1./2.)
</span><span class="noop">    &#39;0.5&#39;
</span><span class="noop">
</span><span class="noop">    :func:`repr_` can also be applied on numpy&#39;s float types:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float64(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float32(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float16(1./3.))
</span><span class="noop">    &#39;0.333252&#39;
</span><span class="noop">
</span><span class="noop">    Note that the deviation from the `true` result in the last example is due
</span><span class="noop">    to the low precision of :class:`~numpy.float16`.
</span><span class="noop">
</span><span class="noop">    On all types not mentioned above, the usual :func:`repr` function is
</span><span class="noop">    applied, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; repr([1, 2, 3])
</span><span class="noop">    &#39;[1, 2, 3]&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_([1, 2, 3])
</span><span class="noop">    &#39;[1, 2, 3]&#39;
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    from hydpy.pub import options
</span><span class="hit">    if isinstance(value, str):
</span><span class="hit">        return value
</span><span class="hit">    elif ((options.reprdigits is not None) and
</span><span class="noop">          isinstance(value,
</span><span class="noop">                     (float, numpy.float64, numpy.float32, numpy.float16))):
</span><span class="hit">        string = &#39;{0:.{1}f}&#39;.format(value, options.reprdigits)
</span><span class="hit">        string = string.rstrip(&#39;0&#39;)
</span><span class="hit">        if string.endswith(&#39;.&#39;):
</span><span class="hit">            string += &#39;0&#39;
</span><span class="hit">        return string
</span><span class="noop">    else:
</span><span class="hit">        return repr(value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Options(object):
</span><span class="noop">    &#34;&#34;&#34;Singleton class for `global` options.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self._printprogress = True
</span><span class="hit">        self._verbosedir = False
</span><span class="hit">        self._reprcomments = True
</span><span class="hit">        self._usecython = True
</span><span class="hit">        self._skipdoctests = False
</span><span class="hit">        self._refreshmodels = False
</span><span class="hit">        self._reprdigits = None
</span><span class="hit">        self._warntrim = True
</span><span class="noop">
</span><span class="hit">    def _getprintprogress(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether information about the progress
</span><span class="noop">        of certain processes shall be printed to the standard output or not.
</span><span class="noop">        The default is `True`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._printprogress
</span><span class="hit">    def _setprintprogress(self, value):
</span><span class="miss">        self._printprogress = bool(value)
</span><span class="hit">    printprogress = property(_getprintprogress, _setprintprogress)
</span><span class="noop">
</span><span class="hit">    def _getdirverbose(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicationg whether the listboxes for the member
</span><span class="noop">        selection of the classes of the HydPy framework should be complete
</span><span class="noop">        (True) or restrictive (False).  The latter is more viewable and hence
</span><span class="noop">        the default.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._verbosedir
</span><span class="hit">    def _setdirverbose(self, value):
</span><span class="hit">        self._verbosedir = bool(value)
</span><span class="hit">    dirverbose = property(_getdirverbose, _setdirverbose)
</span><span class="noop">
</span><span class="hit">    def _getreprcomments(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicationg whether comments shall be included
</span><span class="noop">        in string representations of some classes of the HydPy framework or
</span><span class="noop">        not.  The default is `True`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._reprcomments
</span><span class="hit">    def _setreprcomments(self, value):
</span><span class="hit">        self._reprcomments = bool(value)
</span><span class="hit">    reprcomments = property(_getreprcomments, _setreprcomments)
</span><span class="noop">
</span><span class="hit">    def _getusecython(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether Cython models (True) or pure
</span><span class="noop">        Python models (False) shall be applied if possible.  Using Cython 
</span><span class="noop">        models is more time efficient and thus the default.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._usecython
</span><span class="hit">    def _setusecython(self, value):
</span><span class="hit">        self._usecython = bool(value)
</span><span class="hit">    usecython = property(_getusecython, _setusecython)
</span><span class="noop">
</span><span class="hit">    def _getskipdoctests(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether documetation tests shall be 
</span><span class="noop">        performed under certain situations.  Applying tests increases 
</span><span class="noop">        reliabilty and is thus the default.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._skipdoctests
</span><span class="hit">    def _setskipdoctests(self, value):
</span><span class="hit">        self._skipdoctests = bool(value)
</span><span class="hit">    skipdoctests = property(_getskipdoctests, _setskipdoctests)
</span><span class="noop">
</span><span class="hit">    def _getreprdigits(self):
</span><span class="noop">        &#34;&#34;&#34;Required precision of string representations of floating point 
</span><span class="noop">        numbers, defined as the minimum number of digits to be reproduced 
</span><span class="noop">        by the string representation (see function :func:`repr_`).
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._reprdigits
</span><span class="hit">    def _setreprdigits(self, value):
</span><span class="hit">        if value is None:
</span><span class="hit">            self._reprdigits = value
</span><span class="noop">        else:
</span><span class="hit">            self._reprdigits = int(value)
</span><span class="hit">    reprdigits = property(_getreprdigits, _setreprdigits)
</span><span class="noop">
</span><span class="hit">    def _getwarntrim(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised 
</span><span class="noop">        whenever certain values needed to be trimmed due to violating
</span><span class="noop">        certain boundaries. Such warnings increase savety and are thus
</span><span class="noop">        the default is `True`.  However, to cope with the limited precision
</span><span class="noop">        of floating point numbers only those violations beyond a small 
</span><span class="noop">        tolerance value are reported (see :class:`Trimmer`).  Warnings
</span><span class="noop">        with identical information are reported only once.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._warntrim
</span><span class="hit">    def _setwarntrim(self, value):
</span><span class="hit">        self._warntrim = bool(value)
</span><span class="hit">    warntrim = property(_getwarntrim, _setwarntrim)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def trim(self, lower=None, upper=None):
</span><span class="noop">    &#34;&#34;&#34;ToDo&#34;&#34;&#34;
</span><span class="hit">    from hydpy.pub import options
</span><span class="hit">    if lower is None:
</span><span class="hit">        lower = self.SPAN[0]
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = self.SPAN[1]
</span><span class="hit">    if self.NDIM == 0:
</span><span class="hit">        if (lower is not None) and (self &lt; lower):
</span><span class="hit">            if (self+tolerance(self)) &lt; (lower-tolerance(lower)):
</span><span class="hit">                if options.warntrim:
</span><span class="miss">                    self.warntrim()
</span><span class="hit">            self.value = lower
</span><span class="hit">        elif (upper is not None) and (self &gt; upper):
</span><span class="miss">            if (self-tolerance(self)) &gt; (upper+tolerance(upper)):
</span><span class="miss">                if options.warntrim:
</span><span class="miss">                    self.warntrim()
</span><span class="miss">            self.value = upper
</span><span class="noop">    else:
</span><span class="hit">        if (((lower is not None) and numpy.any(self.values &lt; lower)) or
</span><span class="noop">            ((upper is not None) and numpy.any(self.values &gt; upper))):
</span><span class="hit">            if (numpy.any((self+tolerance(self)) &lt;
</span><span class="noop">                          (lower-tolerance(lower))) or
</span><span class="noop">                numpy.any((self-tolerance(self)) &gt;
</span><span class="noop">                          (upper+tolerance(upper)))):
</span><span class="hit">                    if options.warntrim:
</span><span class="miss">                        self.warntrim()
</span><span class="hit">            self.values = numpy.clip(self.values, lower, upper)
</span><span class="noop">
</span><span class="hit">def tolerance(values):
</span><span class="hit">    return abs(values*1e-15)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ValueMath(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for :class:`~hydpy.core.parametertools.Parameter` and
</span><span class="noop">    :class:`~hydpy.core.sequencetools.Sequence`.  Implements special
</span><span class="noop">    methods for arithmetic calculations, comparisons and type conversions.
</span><span class="noop">
</span><span class="noop">    The subclasses are required to provide the members `NDIM` (usually a
</span><span class="noop">    class attribute) and `value` (usually a property).  But for testing
</span><span class="noop">    purposes, one can simply add them as instance attributes.
</span><span class="noop">
</span><span class="noop">    A few examples for 0-dimensional objects:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import ValueMath
</span><span class="noop">    &gt;&gt;&gt; vm0 = ValueMath()
</span><span class="noop">    &gt;&gt;&gt; vm0.NDIM = 0
</span><span class="noop">    &gt;&gt;&gt; vm0.value = 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm0 + vm0)
</span><span class="noop">    4.0
</span><span class="noop">    &gt;&gt;&gt; print(3. - vm0)
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; vm0 /= 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm0.value)
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; print(vm0 &gt; vm0)
</span><span class="noop">    False
</span><span class="noop">    &gt;&gt;&gt; print(vm0 != 1.5)
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    Similar examples for 1-dimensional objects:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; vm1 = ValueMath()
</span><span class="noop">    &gt;&gt;&gt; vm1.NDIM = 1
</span><span class="noop">    &gt;&gt;&gt; vm1.value = numpy.array([1.,2.,3.])
</span><span class="noop">    &gt;&gt;&gt; print(vm1 + vm1)
</span><span class="noop">    [ 2.  4.  6.]
</span><span class="noop">    &gt;&gt;&gt; print(3. - vm1)
</span><span class="noop">    [ 2.  1.  0.]
</span><span class="noop">    &gt;&gt;&gt; vm1 /= 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm1.value)
</span><span class="noop">    [ 0.5  1.   1.5]
</span><span class="noop">    &gt;&gt;&gt; print(vm1 &gt; vm1)
</span><span class="noop">    [False False False]
</span><span class="noop">    &gt;&gt;&gt; print(vm1 != 1.5)
</span><span class="noop">    [ True  True False]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # Subclasses need to define...
</span><span class="hit">    NDIM = None # ... e.g. as class attribute (int)
</span><span class="hit">    name = None # ... e.g. as property (str)
</span><span class="hit">    value = None # ... e.g. as property (float or ndarray of dtype float)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _arithmetic_conversion(other):
</span><span class="hit">        try:
</span><span class="hit">            return other.value
</span><span class="hit">        except AttributeError:
</span><span class="hit">            return other
</span><span class="noop">
</span><span class="hit">    def _arithmetic_exception(self, verb, other):
</span><span class="miss">        augmentexcmessage(&#39;While trying to %s %s instance `%s` and %s `%s`&#39;
</span><span class="noop">                          % (verb, classname(self), self.name,
</span><span class="noop">                             classname(other), other))
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value + self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;add&#39;, other)
</span><span class="hit">    def __radd__(self, other):
</span><span class="hit">        return self.__add__(other)
</span><span class="hit">    def __iadd__(self, other):
</span><span class="miss">        self.value = self.__add__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value  - self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;subtract&#39;, other)
</span><span class="hit">    def __rsub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self._arithmetic_conversion(other) - self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;subtract&#39;, other)
</span><span class="hit">    def __isub__(self, other):
</span><span class="miss">        self.value = self.__sub__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __mul__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value * self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;multiply&#39;, other)
</span><span class="hit">    def __rmul__(self, other):
</span><span class="miss">        return self.__mul__(other)
</span><span class="hit">    def __imul__(self, other):
</span><span class="miss">        self.value = self.__mul__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __truediv__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value / self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;divide&#39;, other)
</span><span class="hit">    def __rtruediv__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self._arithmetic_conversion(other) / self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;divide&#39;, other)
</span><span class="hit">    def __itruediv__(self, other):
</span><span class="hit">        self.value = self.__truediv__(other)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __floordiv__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value // self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;floor divide&#39;, other)
</span><span class="hit">    def __rfloordiv__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other) // self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;floor divide&#39;, other)
</span><span class="hit">    def __ifloordiv__(self, other):
</span><span class="miss">        self.value = self.__floordiv__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __mod__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value % self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;mod divide&#39;, other)
</span><span class="hit">    def __rmod__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other) % self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;mod divide&#39;, other)
</span><span class="hit">    def __imod__(self, other):
</span><span class="miss">        self.value = self.__mod__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __pow__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value**self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;exponentiate&#39;, other)
</span><span class="hit">    def __rpow__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other)**self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;exponentiate&#39;, other)
</span><span class="hit">    def __ipow__(self, other):
</span><span class="miss">        self.value = self.__pow__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __neg__(self):
</span><span class="miss">        return -self.value
</span><span class="noop">
</span><span class="hit">    def __pos__(self):
</span><span class="miss">        return +self.value
</span><span class="noop">
</span><span class="hit">    def __abs__(self):
</span><span class="miss">        return abs(self.value)
</span><span class="noop">
</span><span class="hit">    def __invert__(self):
</span><span class="miss">        return 1./self.value
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &lt; self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&lt;)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &lt;= self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&lt;=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value == self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (==)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value != self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (!=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value &gt;= self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&gt;=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &gt; self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&gt;)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def _typeconversion(self, type_):
</span><span class="hit">        if not self.NDIM:
</span><span class="hit">            return type_(self.value)
</span><span class="noop">        else:
</span><span class="miss">            raise TypeError(&#39;The %s instance `%s` is %d-dimensional and thus &#39;
</span><span class="noop">                            &#39;cannot be converted to a scalar %s value.&#39;
</span><span class="noop">                            % (classname(self), self.name, self.NDIM,
</span><span class="noop">                               classname(type_)))
</span><span class="noop">
</span><span class="hit">    def __float__(self):
</span><span class="hit">        return self._typeconversion(float)
</span><span class="noop">
</span><span class="hit">    def __int__(self):
</span><span class="miss">        return self._typeconversion(int)
</span><span class="noop">
</span><span class="hit">    def __round__(self, ndigits=0):
</span><span class="miss">        return numpy.round(self.value, ndigits)
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...standard
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import inspect
</span><span class="hit">import time
</span><span class="hit">import copy
</span><span class="hit">import textwrap
</span><span class="hit">import warnings
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># The import of `_strptime` is not thread save.  The following call of
</span><span class="noop"># `strptime` is supposed to prevent possible problems arising from this bug.
</span><span class="hit">time.strptime(&#39;1999&#39;, &#39;%Y&#39;)
</span><span class="noop">
</span><span class="hit">class Parameters(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling all parameters of a specific model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, kwargs):
</span><span class="hit">        self.model = kwargs.get(&#39;model&#39;)
</span><span class="hit">        self.control = None
</span><span class="hit">        self.derived = None
</span><span class="hit">        cythonmodule = kwargs.get(&#39;cythonmodule&#39;)
</span><span class="hit">        cymodel = kwargs.get(&#39;cymodel&#39;)
</span><span class="hit">        for (name, cls) in kwargs.items():
</span><span class="hit">            if name.endswith(&#39;Parameters&#39;) and issubclass(cls, SubParameters):
</span><span class="hit">                if cythonmodule:
</span><span class="hit">                    cls_fastaccess = getattr(cythonmodule, name)
</span><span class="hit">                    subpars = cls(self, cls_fastaccess, cymodel)
</span><span class="noop">                else:
</span><span class="hit">                    subpars = cls(self, None, None)
</span><span class="hit">                setattr(self, subpars.name, subpars)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Needs to be defined for each individual :class:`Parameters`
</span><span class="noop">        subclass that contains `derived` paramemeters, whose values are
</span><span class="noop">        calculated on the basis of given control parameter values.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def savecontrols(self, parameterstep=None, simulationstep=None,
</span><span class="noop">                     filename=None, dirname=None):
</span><span class="miss">        if self.control:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._controldefaultfilename
</span><span class="miss">            if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">                filename += &#39;.py&#39;
</span><span class="miss">            if dirname is None:
</span><span class="miss">                dirname = pub.controlmanager.controlpath
</span><span class="miss">            filepath = os.path.join(dirname, filename)
</span><span class="miss">            with file(filepath, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(&#39;from hydpy.models.%s import *\n\n&#39;
</span><span class="noop">                            % self.model.__module__.split(&#39;.&#39;)[2])
</span><span class="miss">                if not parameterstep:
</span><span class="miss">                    parameterstep = pub.timegrids.stepsize
</span><span class="miss">                file_.write(&#39;parameterstep(&#34;%s&#34;)\n&#39; % parameterstep)
</span><span class="miss">                if not simulationstep:
</span><span class="miss">                    simulationstep = pub.timegrids.stepsize
</span><span class="miss">                file_.write(&#39;simulationstep(&#34;%s&#34;)\n\n&#39; % simulationstep)
</span><span class="miss">                for (name, par) in self.control:
</span><span class="miss">                    _parameterstep = par._parameterstep
</span><span class="miss">                    try:
</span><span class="miss">                        par.parameterstep = parameterstep
</span><span class="miss">                        file_.write(repr(par) + &#39;\n&#39;)
</span><span class="noop">                    finally:
</span><span class="miss">                        par._parameterstep = _parameterstep
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _controldefaultfilename(self):
</span><span class="miss">        filename = objecttools.devicename(self)
</span><span class="miss">        if filename == &#39;?&#39;:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;To save the control parameters of a model to a file, its &#39;
</span><span class="noop">                &#39;filename must be known.  This can be done, by passing &#39;
</span><span class="noop">                &#39;filename to function `savecontrols` directly.  &#39;
</span><span class="noop">                &#39;But in complete HydPy applications, it is usally &#39;
</span><span class="noop">                &#39;assumed to be consistent with the name of the element &#39;
</span><span class="noop">                &#39;handling the model.  Actually, neither a filename is given &#39;
</span><span class="noop">                &#39;nor does the model know its master element.&#39;)
</span><span class="noop">        else:
</span><span class="miss">            return filename + &#39;.py&#39;
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;&#34;&#34;&#34;
</span><span class="miss">        for (name, parameter) in self.control:
</span><span class="miss">            parameter.verify()
</span><span class="miss">        for (name, parameter) in self.derived:
</span><span class="miss">            parameter.verify()
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (key, value) in vars(self).items():
</span><span class="hit">            if isinstance(value, SubParameters):
</span><span class="hit">                yield key, value
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(dict(self))
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SubParameters(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling subgroups of model parameters.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _PARCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self, pars, cls_fastaccess=None, cymodel=None):
</span><span class="hit">        self.pars = pars
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess = type(&#39;FastAccess&#39;, (), {})
</span><span class="noop">        else:
</span><span class="hit">            self.fastaccess = cls_fastaccess()
</span><span class="hit">            setattr(cymodel, self.name, self.fastaccess)
</span><span class="hit">        for Par in self._PARCLASSES:
</span><span class="hit">            setattr(self, objecttools.instancename(Par), Par())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return objecttools.instancename(cls)[:-10]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def name(self):
</span><span class="hit">        return self.getname()
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="noop">        &#34;&#34;&#34;Attributes and methods should usually not be replaced.  Existing
</span><span class="noop">        :class:`Parameter` attributes are protected in a way, that only their
</span><span class="noop">        values are changed through assignements.  For new :class:`Parameter`
</span><span class="noop">        attributes, additional `fastaccess` references are defined.  If you
</span><span class="noop">        actually want to replace a parameter, you have to delete it first.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            attr = getattr(self, name)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            object.__setattr__(self, name, value)
</span><span class="hit">            if isinstance(value, Parameter):
</span><span class="hit">                value.subpars = self
</span><span class="hit">                value.fastaccess = self.fastaccess
</span><span class="hit">                try:
</span><span class="noop">                    # Necessary when working in Python mode...
</span><span class="hit">                    setattr(self.fastaccess, value.name, None)
</span><span class="hit">                except TypeError:
</span><span class="noop">                    # ...but unnecessary and impossible in Cython mode.
</span><span class="hit">                    pass
</span><span class="hit">                if getattr(value, &#39;INIT&#39;, None) is not None:
</span><span class="miss">                    value(value.INIT)
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                attr._setvalue(value)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;`%s` instances do not allow the direct&#39;
</span><span class="noop">                                   &#39;replacement of their members.  After &#39;
</span><span class="noop">                                   &#39;initialization you should usually only &#39;
</span><span class="noop">                                   &#39;change parameter values through &#39;
</span><span class="noop">                                   &#39;assignements.  If you really need to &#39;
</span><span class="noop">                                   &#39;replace a object member, delete it &#39;
</span><span class="noop">                                   &#39;beforehand.&#39; % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for Par in self._PARCLASSES:
</span><span class="hit">            name = objecttools.instancename(Par)
</span><span class="hit">            yield name, getattr(self, name)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameter(objecttools.ValueMath):
</span><span class="noop">    &#34;&#34;&#34;Base class for :class:`SingleParameter` and :class:`MultiParameter`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _parameterstep = None
</span><span class="hit">    _simulationstep = None
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.subpars = None
</span><span class="hit">        self.fastaccess = type(&#39;JustForDemonstrationPurposes&#39;, (),
</span><span class="noop">                               {self.name: None})()
</span><span class="noop">
</span><span class="hit">    def _getname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the parameter, which is the name if the instantiating
</span><span class="noop">        subclass of :class:`Parameter` in lower case letters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return objecttools.classname(self).lower()
</span><span class="hit">    name = property(_getname)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if args and kwargs:
</span><span class="miss">            raise ValueError(&#39;For parameter %s of element %s both positional &#39;
</span><span class="noop">                             &#39;and keyword arguments are given, which is &#39;
</span><span class="noop">                             &#39;ambiguous.&#39;
</span><span class="noop">                             % (self.name, objecttools.devicename(self)))
</span><span class="hit">        elif not args and not kwargs:
</span><span class="miss">            raise ValueError(&#39;For parameter %s of element %s neither a &#39;
</span><span class="noop">                             &#39;positional nor a keyword argument is given.&#39;
</span><span class="noop">                             % (self.name, objecttools.devicename(self)))
</span><span class="hit">        elif &#39;pyfile&#39; in kwargs:
</span><span class="miss">            values = self._getvalues_from_auxiliaryfile(kwargs[&#39;pyfile&#39;])
</span><span class="miss">            self.values = self.applytimefactor(values)
</span><span class="miss">            del(kwargs[&#39;pyfile&#39;])
</span><span class="hit">        elif args:
</span><span class="hit">            self.values = self.applytimefactor(numpy.array(args))
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;The value(s) of parameter %s of &#39;
</span><span class="noop">                                      &#39;element %s could not be set based on &#39;
</span><span class="noop">                                      &#39;the given keyword arguments.&#39;
</span><span class="noop">                                      % (self.name,
</span><span class="noop">                                         objecttools.devicename(self)))
</span><span class="hit">        self.trim()
</span><span class="noop">
</span><span class="hit">    def _getvalues_from_auxiliaryfile(self, pyfile):
</span><span class="noop">        &#34;&#34;&#34;Tries to return the parameter values from the auxiliary control file
</span><span class="noop">        with the given name.
</span><span class="noop">
</span><span class="noop">        Things are a little complicated here.  To understand this method, you
</span><span class="noop">        should first take a look at function :func:`parameterstep`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        frame = inspect.currentframe().f_back.f_back
</span><span class="miss">        while frame:
</span><span class="miss">            namespace = frame.f_locals
</span><span class="miss">            try:
</span><span class="miss">                subnamespace = {&#39;model&#39;: namespace[&#39;model&#39;],
</span><span class="noop">                                &#39;focus&#39;: self}
</span><span class="miss">                break
</span><span class="miss">            except KeyError:
</span><span class="miss">                frame = frame.f_back
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Something has gone wrong when trying to &#39;
</span><span class="noop">                               &#39;read parameter `%s` from file `%s`.&#39;
</span><span class="noop">                               % (self.name, pyfile))
</span><span class="miss">        filetools.ControlFileManager.read2dict(pyfile, subnamespace)
</span><span class="miss">        try:
</span><span class="miss">            subself = subnamespace[self.name]
</span><span class="miss">        except KeyError:
</span><span class="miss">            raise RuntimeError(&#39;Something has gone wrong when trying to &#39;
</span><span class="noop">                               &#39;read parameter `%s` from file `%s`.&#39;
</span><span class="noop">                               % (self.name, pyfile))
</span><span class="miss">        return subself.values
</span><span class="noop">
</span><span class="hit">    def _getparameterstep(self):
</span><span class="noop">        &#34;&#34;&#34;The parameter time step size new parameter values might be related
</span><span class="noop">        to.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self._parameterstep is None:
</span><span class="miss">            raise RuntimeError(&#39;The general parameter time step has not been &#39;
</span><span class="noop">                               &#39;defined so far.&#39;)
</span><span class="noop">        else:
</span><span class="hit">            return self._parameterstep
</span><span class="hit">    def _setparameterstep(self, value):
</span><span class="miss">        try:
</span><span class="miss">            self._parameterstep = timetools.Period(value)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to set the general &#39;
</span><span class="noop">                                          &#39;parameter time step&#39;)
</span><span class="hit">    parameterstep = property(_getparameterstep, _setparameterstep)
</span><span class="noop">
</span><span class="hit">    def _getsimulationstep(self):
</span><span class="noop">        &#34;&#34;&#34;The simulation time step size new parameter values might be related
</span><span class="noop">        to.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return pub.timegrids.stepsize
</span><span class="hit">        except AttributeError:
</span><span class="hit">            return self._simulationstep
</span><span class="hit">    simulationstep = property(_getsimulationstep)
</span><span class="noop">
</span><span class="hit">    def _gettimefactor(self):
</span><span class="noop">        &#34;&#34;&#34;Factor to adapt a new parameter value related to
</span><span class="noop">        :attr:`parameterstep` to a different simulation time step.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parfactor = pub.timegrids.parfactor
</span><span class="hit">        except AttributeError:
</span><span class="hit">            if self._simulationstep is None:
</span><span class="miss">                raise RuntimeError(&#39;The calculation of the effective value &#39;
</span><span class="noop">                                   &#39;of parameter `%s` requires a definition &#39;
</span><span class="noop">                                   &#39;of the actual simulation time step.  &#39;
</span><span class="noop">                                   &#39;The simulation time step is project &#39;
</span><span class="noop">                                   &#39;specific.  When initializing the HydPy &#39;
</span><span class="noop">                                   &#39;framework, it is automatically specified &#39;
</span><span class="noop">                                   &#39;under `pub.timegrids.stepsize.  For &#39;
</span><span class="noop">                                   &#39;testing purposes, one can alternatively &#39;
</span><span class="noop">                                   &#39;apply the function `simulationstep`.  &#39;
</span><span class="noop">                                   &#39;Please see the documentation for more &#39;
</span><span class="noop">                                   &#39;details.&#39; % self.name)
</span><span class="noop">            else:
</span><span class="hit">                date1 = timetools.Date(&#39;2000.01.01&#39;)
</span><span class="hit">                date2 = date1 + self._simulationstep
</span><span class="hit">                parfactor = timetools.Timegrids(timetools.Timegrid(
</span><span class="noop">                                 date1, date2, self._simulationstep)).parfactor
</span><span class="hit">        return parfactor(self.parameterstep)
</span><span class="hit">    timefactor = property(_gettimefactor)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="hit">        objecttools.trim(self, lower, upper)
</span><span class="noop">
</span><span class="hit">    def warntrim(self):
</span><span class="miss">        warnings.warn(&#39;For parameter %s of element %s at least one value &#39;
</span><span class="noop">                      &#39;needed to be trimmed.  Two possible reasons could be &#39;
</span><span class="noop">                      &#39;that the a parameter bound violated or that the values &#39;
</span><span class="noop">                      &#39;of two (or more) different parameters are inconsistent.&#39;
</span><span class="noop">                      % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def applytimefactor(self, values):
</span><span class="noop">        &#34;&#34;&#34;Change the given parameter value/values in accordance with the
</span><span class="noop">        actual parameter simulation time step if necessary, and return it/them.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        # Note: At least `values /= self.timefactor` is less flexible than
</span><span class="noop">        # `values = values / self.timefactor` regarding the type of `values`.
</span><span class="hit">        if self.TIME is True:
</span><span class="hit">            values = values * self.timefactor
</span><span class="hit">        elif self.TIME is False:
</span><span class="hit">            values = values / self.timefactor
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def reverttimefactor(self, values):
</span><span class="noop">        &#34;&#34;&#34;Change the given parameter value/values inversely in accordance
</span><span class="noop">        with the actual parameter simulation time step if necessary, and
</span><span class="noop">        return it/them.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        # Note: At least `values /= self.timefactor` is less flexible than
</span><span class="noop">        # `values = values / self.timefactor` regarding the type of `values`.
</span><span class="hit">        if self.TIME is True:
</span><span class="hit">            values = values / self.timefactor
</span><span class="hit">        elif self.TIME is False:
</span><span class="hit">            values = values * self.timefactor
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def commentrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list with comments, e.g. for making string representations
</span><span class="noop">        more informative.  When :attr:`pub.options.reprcomments` is set to
</span><span class="noop">        `False`, an empty list is returned.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = []
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="hit">            lines.append(&#39;# %s&#39; % self.__doc__.split(&#39;\n&#39;)[0])
</span><span class="hit">            if self.TIME is not None:
</span><span class="hit">                lines.append(&#39;# The actual value representation depends on &#39;
</span><span class="noop">                             &#39;the actual parameter step size, which is `%s`.&#39;
</span><span class="noop">                             % self.parameterstep)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return str(self.values)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SingleParameter(Parameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling a single value.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN, INIT = 0, float, None, (None, None), None
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Parameter.__init__(self)
</span><span class="hit">        if self.INIT is not None:
</span><span class="miss">            self(self.INIT)
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;An empty tuple.  (Only intended for increasing consistent usability
</span><span class="noop">        of :class:`SingleParameter` and :class:`MultiParameter` instances.)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return ()
</span><span class="hit">    def _setshape(self, shape):
</span><span class="miss">        raise RuntimeError(&#39;The shape information of `SingleParameters` &#39;
</span><span class="noop">                           &#39;as `%s` cannot be changed.&#39; % self.name)
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual parameter value handled by the respective
</span><span class="noop">        :class:`SingleParameter` instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        values = getattr(self.fastaccess, self.name, None)
</span><span class="hit">        if values is not None:
</span><span class="hit">            return values
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;No value of parameter `%s` has been defined &#39;
</span><span class="noop">                               &#39;so far.&#39; % self.name)
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        try:
</span><span class="hit">            temp = value[0]
</span><span class="hit">            if len(value) &gt; 1:
</span><span class="miss">                raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                 &#39;parameter `%s`, which is ambiguous.&#39;
</span><span class="noop">                                 % (len(value)), self.name)
</span><span class="hit">            value = temp
</span><span class="hit">        except (TypeError, IndexError):
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            value = self.TYPE(value)
</span><span class="miss">        except (ValueError, TypeError):
</span><span class="miss">            raise TypeError(&#39;When trying to set the value of parameter `%s`, &#39;
</span><span class="noop">                             &#39;it was not possible to convert `%s` to type &#39;
</span><span class="noop">                             &#39;`%s`.&#39; % (self.name, value,
</span><span class="noop">                                        objecttools.classname(self.TYPE)))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raises a :class:`~exceptions.RuntimeError` if the value of the
</span><span class="noop">        instance of the respective subclass of :class:`SingleParameter` is
</span><span class="noop">        `None` or `nan`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;The value of parameter `%s` has not been &#39;
</span><span class="noop">                               &#39;set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="noop">        &#34;&#34;&#34;Returns 1.  (This method is only intended for increasing consistent
</span><span class="noop">        usability of :class:`SingleParameter` and :class:`MultiParameter`
</span><span class="noop">        instances.)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return 1
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        if key in (0, slice(None, None, None)):
</span><span class="hit">            return self.value
</span><span class="noop">        else:
</span><span class="hit">            raise IndexError(&#39;The only allowed index for scalar parameters &#39;
</span><span class="noop">                             &#39;like `%s` is `0` (or `:`), but `%s` is given.&#39;
</span><span class="noop">                             % (self.name, key))
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="miss">        if key in (0, slice(None, None, None)):
</span><span class="miss">            self.value = value
</span><span class="noop">        else:
</span><span class="miss">            raise IndexError(&#39;The only allowed index for scalar parameters &#39;
</span><span class="noop">                             &#39;like `%s` is `0` (or `:`), but `%s` is given.&#39;
</span><span class="noop">                             % (self.name, key))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = self.commentrepr()
</span><span class="hit">        lines.append(&#39;%s(%s)&#39;
</span><span class="noop">                     % (self.name,
</span><span class="noop">                        objecttools.repr_(self.reverttimefactor(self.value))))
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(Parameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling multiple values.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple containing the lengths in all dimensions of the parameter
</span><span class="noop">        values.  Note that setting a new shape results in a loss of all values
</span><span class="noop">        of the respective parameter.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return getattr(self.fastaccess, self.name).shape
</span><span class="hit">        except AttributeError:
</span><span class="hit">            raise RuntimeError(&#39;Shape information for parameter `%s` &#39;
</span><span class="noop">                               &#39;can only be retrieved after it has been &#39;
</span><span class="noop">                               &#39;defined.&#39; % self.name)
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        try:
</span><span class="hit">            array = numpy.full(shape, numpy.nan, dtype=self.TYPE)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying create a new numpy &#39;
</span><span class="noop">                                          &#39;ndarray` for parameter `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="hit">        if array.ndim == self.NDIM:
</span><span class="hit">            setattr(self.fastaccess, self.name, array)
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;Parameter `%s` is %d-dimensional but the &#39;
</span><span class="noop">                             &#39;given shape indicates %d dimensions.&#39;
</span><span class="noop">                             % (self.name, self.NDIM, array.ndim))
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual parameter value(s) handled by the respective
</span><span class="noop">        :class:`Parameter` instance.  For consistency, `value` and `values`
</span><span class="noop">        can always be used interchangeably.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            raise RuntimeError(&#39;No value/values of parameter `%s` has/have &#39;
</span><span class="noop">                               &#39;been defined so far.&#39; % self.name)
</span><span class="noop">        else:
</span><span class="hit">            return numpy.asarray(value)
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        try:
</span><span class="hit">            value = value.value
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            value = numpy.full(self.shape, value, dtype=self.TYPE)
</span><span class="miss">        except ValueError:
</span><span class="miss">            raise ValueError(&#39;The values `%s` cannot be converted to a numpy &#39;
</span><span class="noop">                             &#39;ndarray with shape %s containing entries of &#39;
</span><span class="noop">                             &#39;type %s.&#39; % (value, self.shape,
</span><span class="noop">                                           objecttools.classname(self.TYPE)))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getverifymask(self):
</span><span class="noop">        &#34;&#34;&#34;A numpy array with all entries being `True` of the same
</span><span class="noop">        shape as the values handled by the respective parameter.  All entries
</span><span class="noop">        beeing `True` indicates that the method :func:`~MultiParameter.verify`
</span><span class="noop">        checks all entries of the numpy array storing the parameter values.
</span><span class="noop">        Overwrite :func:`~MultiParameter.verify` for :class:`MultiParameter`
</span><span class="noop">        subclasses, where certain entries do not to be checked.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return numpy.full(self.shape, True, dtype=bool)
</span><span class="hit">    verifymask = property(_getverifymask)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raises a :class:`~exceptions.RuntimeError` if at least one of the
</span><span class="noop">        required values of the instance of the respective subclass of
</span><span class="noop">        :class:`MultiParameter` is `None` or `nan`. The property
</span><span class="noop">        :func:`~MultiParameter.verifymask` defines, which values are
</span><span class="noop">        considered to be necessary.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.values is None:
</span><span class="miss">             raise RuntimeError(&#39;The values of parameter `%s` have not &#39;
</span><span class="noop">                                &#39;been set yet.&#39; % self.name)
</span><span class="miss">        nmbnan = sum(numpy.isnan(self.values[self.verifymask]))
</span><span class="miss">        if nmbnan:
</span><span class="miss">             raise RuntimeError(&#39;For parameter `%s`, %d required values have &#39;
</span><span class="noop">                                &#39;not been set yet.&#39; % (self.name, nmbnan))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Return a deep copy of the parameter values.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self.values)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="noop">        &#34;&#34;&#34;Returns the number of values handled by the :class:`MultiParameter`
</span><span class="noop">        instance.  It is required, that the `shape` has been set beforehand,
</span><span class="noop">        which specifies the length in each dimension.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.cumprod(self.shape)[-1]
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        try:
</span><span class="hit">            return self.values[key]
</span><span class="hit">        except Exception:
</span><span class="hit">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, values):
</span><span class="hit">        try:
</span><span class="hit">            self.values[key] = values
</span><span class="miss">        except Exception:
</span><span class="miss">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def _raiseitemexception(self):
</span><span class="hit">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;Parameter `%s` has no values so far.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">        else:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to item access the &#39;
</span><span class="noop">                                          &#39;values of parameter `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a compressed parameter value string, which is (in
</span><span class="noop">        accordance with :attr:`~MultiParameter.NDIM`) contained in a
</span><span class="noop">        nested list.  If the compression fails, a
</span><span class="noop">        :class:`~exceptions.NotImplementedError` is raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        unique = numpy.unique(self.values)
</span><span class="hit">        if sum(numpy.isnan(unique)) == len(unique.flatten()):
</span><span class="miss">            unique = numpy.array([numpy.nan])
</span><span class="noop">        else:
</span><span class="hit">            unique = self.reverttimefactor(unique)
</span><span class="hit">        if len(unique) == 1:
</span><span class="hit">            result = objecttools.repr_(unique[0])
</span><span class="hit">            for idx in range(self.NDIM):
</span><span class="hit">                result = [result]
</span><span class="hit">            return result
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;For parameter `%s` there is no &#39;
</span><span class="noop">                                      &#39;compression method implemented, &#39;
</span><span class="noop">                                      &#39;working for its actual values.&#39;
</span><span class="noop">                                      % self.name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = self.commentrepr()
</span><span class="hit">        try:
</span><span class="hit">            values = self.compressrepr()
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            values = self.reverttimefactor(self.values)
</span><span class="miss">        except BaseException:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to find a compressed &#39;
</span><span class="noop">                                          &#39;string representation for &#39;
</span><span class="noop">                                          &#39;parameter `%s`&#39; % self.name)
</span><span class="hit">        if self.NDIM == 1:
</span><span class="hit">            cols = &#39;, &#39;.join(objecttools.repr_(value) for value in values)
</span><span class="hit">            wrappedlines = textwrap.wrap(cols, 80-len(self.name)-2)
</span><span class="hit">            for (idx, line) in enumerate(wrappedlines):
</span><span class="hit">                if not idx:
</span><span class="hit">                    lines.append(&#39;%s(%s&#39; % (self.name, line))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append((len(self.name)+1)*&#39; &#39; + line)
</span><span class="hit">            lines[-1] += &#39;)&#39;
</span><span class="hit">            return &#39;\n&#39;.join(lines)
</span><span class="miss">        elif self.NDIM == 2:
</span><span class="miss">            skip = (1+len(self.name)) * &#39; &#39;
</span><span class="miss">            for (idx, row) in enumerate(values):
</span><span class="miss">                cols = &#39;, &#39;.join(objecttools.repr_(value) for value in row)
</span><span class="miss">                if not idx:
</span><span class="miss">                    lines.append(&#39;%s(%s,&#39; % (self.name, cols))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append(&#39;%s%s,&#39; % (skip, cols))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">            return &#39;\n&#39;.join(lines)
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;`repr` does not yet support &#39;
</span><span class="noop">                                      &#39;parameters, which handle %d-&#39;
</span><span class="noop">                                      &#39;dimensional matrices.&#39; % self.NDIM)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZipParameter(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling multiple values that offers
</span><span class="noop">    additional keyword zipping fuctionality.
</span><span class="noop">
</span><span class="noop">    When inheriting an actual parameter class from :class:`ZipParameter` one
</span><span class="noop">    needs to define suitable class constants
</span><span class="noop">    :const:`~ZipParameter.REQUIRED_VALUES` (a :class:`tuple`) and
</span><span class="noop">    :const:`~ZipParameter.MODEL_CONSTANTS` (a :class:`dict`).  Additionally,
</span><span class="noop">    a property named `refparameter` must be defined.
</span><span class="noop">
</span><span class="noop">    The implementation and functioning of subclasses of :class:`ZipParameter`
</span><span class="noop">    is best illustrated by an example: see the documentation of the class
</span><span class="noop">    :class:`~hydpy.models.hland.hland_parameters.MultiParameter` of the
</span><span class="noop">    HydPy-H-Land model.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = ()
</span><span class="hit">    MODEL_CONSTANTS = {}
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            Parameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError as exc:
</span><span class="hit">            if kwargs:
</span><span class="hit">                refvalues = self.refparameter.values
</span><span class="hit">                if min(refvalues) &lt; 1:
</span><span class="miss">                    raise RuntimeError(&#39;Parameter %s does not seem to &#39;
</span><span class="noop">                                       &#39;be prepared properly for element %s.  &#39;
</span><span class="noop">                                       &#39;Hence, setting values for parameter &#39;
</span><span class="noop">                                       &#39;%s via keyword arguments is not &#39;
</span><span class="noop">                                       &#39;possible.&#39;
</span><span class="noop">                                       % (self.refparameter.name,
</span><span class="noop">                                          objecttools.devicename(self),
</span><span class="noop">                                          self.name))
</span><span class="hit">                self.values = kwargs.pop(&#39;default&#39;, numpy.nan)
</span><span class="hit">                for (key, value)  in kwargs.items():
</span><span class="hit">                    sel = self.MODEL_CONSTANTS.get(key.upper())
</span><span class="hit">                    if sel is None:
</span><span class="miss">                        raise exc
</span><span class="noop">                    else:
</span><span class="hit">                        self.values[refvalues == sel] = value
</span><span class="hit">                self.values = self.applytimefactor(self.values)
</span><span class="hit">                self.trim()
</span><span class="noop">            else:
</span><span class="miss">                raise exc
</span><span class="noop">
</span><span class="hit">    def _getverifymask(self):
</span><span class="noop">        &#34;&#34;&#34;A numpy array of the same shape as the value array handled
</span><span class="noop">        by the respective parameter.  `True` entries indicate that certain
</span><span class="noop">        parameter values are required, which depends on the tuple
</span><span class="noop">        :const:`REQUIRED_VALUES` of the respective subclass.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        mask = numpy.full(self.shape, False, dtype=bool)
</span><span class="hit">        refvalues = self.refparameter.values
</span><span class="hit">        for reqvalue in self.REQUIRED_VALUES:
</span><span class="hit">            mask[refvalues == reqvalue] = True
</span><span class="hit">        return mask
</span><span class="hit">    verifymask = property(_getverifymask)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a compressed parameter value string, which is (in
</span><span class="noop">        accordance with :attr:`NDIM`) contained in a nested list.  If the
</span><span class="noop">        compression fails, a :class:`~exceptions.NotImplementedError` is
</span><span class="noop">        raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return MultiParameter.compressrepr(self)
</span><span class="hit">        except NotImplementedError as exc:
</span><span class="hit">            results = []
</span><span class="hit">            refvalues = self.refparameter.values
</span><span class="hit">            if min(refvalues) &lt; 1:
</span><span class="hit">                raise NotImplementedError(&#39;Parameter %s is not defined &#39;
</span><span class="noop">                                          &#39;poperly, which circumvents finding &#39;
</span><span class="noop">                                          &#39;a suitable compressed.&#39;)
</span><span class="hit">            for (key, value) in self.MODEL_CONSTANTS.items():
</span><span class="hit">                if value in self.REQUIRED_VALUES:
</span><span class="hit">                    unique = numpy.unique(self.values[refvalues == value])
</span><span class="hit">                    unique = self.reverttimefactor(unique)
</span><span class="hit">                    if len(unique) == 1:
</span><span class="hit">                        results.append(&#39;%s=%s&#39;
</span><span class="noop">                                       % (key.lower(), repr(unique[0])))
</span><span class="hit">                    elif len(unique) &gt; 1:
</span><span class="hit">                        raise exc
</span><span class="hit">            result = &#39;, &#39;.join(sorted(results))
</span><span class="hit">            for idx in range(self.NDIM):
</span><span class="hit">                result = [result]
</span><span class="hit">            return result
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IndexParameter(MultiParameter):
</span><span class="noop">
</span><span class="hit">    def setreference(self, indexarray):
</span><span class="miss">        setattr(self.fastaccess, self.name, indexarray)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import devicetools
</span><span class="noop">
</span><span class="hit">class Selections(object):
</span><span class="noop">    &#34;&#34;&#34;Collects :class:`Selection` instances.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * ? (:class:`Selection`): An arbitrary number of :class:`Selection`
</span><span class="noop">          objects, which can be added (and removed) on demand.  Choose
</span><span class="noop">          attribute names that are meaningfull within your specific project.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, *selections):
</span><span class="miss">        for selection in selections:
</span><span class="miss">            self += selection
</span><span class="noop">
</span><span class="hit">    def _getnames(self):
</span><span class="noop">        &#34;&#34;&#34;Names of the actual selections.&#34;&#34;&#34;
</span><span class="miss">        return vars(self).keys()
</span><span class="hit">    names = property(_getnames)
</span><span class="noop">
</span><span class="hit">    def _getselections(self):
</span><span class="noop">        &#34;&#34;&#34;The actual selections themselves.&#34;&#34;&#34;
</span><span class="miss">        return vars(self).values()
</span><span class="hit">    selections = property(_getselections)
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="miss">        self.__dict__[key] = value
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __delitem__(self, key):
</span><span class="miss">        del(self.__dict__[key])
</span><span class="noop">
</span><span class="hit">    def __contains__(self, value):
</span><span class="miss">        if isinstance(value, Selection):
</span><span class="miss">            return value in self.selections
</span><span class="noop">        else:
</span><span class="miss">            return value in self.names
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, selection) in vars(self).items():
</span><span class="miss">            yield (name, selection)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(self.names)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _getiterable(value):
</span><span class="noop">        &#34;&#34;&#34;Tries to convert the given argument to a :class:`list` of
</span><span class="noop">        :class:`Selection` objects and returns it.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * value (:class:`Selection`, :class:`Selections` of a simple
</span><span class="noop">            iterable containing :class:`Selection` objects): The second
</span><span class="noop">            operand applied in an arithmetic operation.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if isinstance(value, Selection):
</span><span class="miss">            return [value]
</span><span class="miss">        elif isinstance(value, Selections):
</span><span class="miss">            return value.selections
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                for selection in value:
</span><span class="miss">                    selection.name
</span><span class="miss">                    break
</span><span class="miss">                return list(value)
</span><span class="miss">            except (KeyError, AttributeError):
</span><span class="miss">                raise TypeError(&#39;Arithmetic operations on `Selections` &#39;
</span><span class="noop">                                &#39;objects are defined for other `Selections` &#39;
</span><span class="noop">                                &#39;objects, single `Selection` objects or &#39;
</span><span class="noop">                                &#39;simple iterables (like `list` objects) &#39;
</span><span class="noop">                                &#39;containing `Selection` objects only.  The &#39;
</span><span class="noop">                                &#39;given arguments type is `%s`.&#39;
</span><span class="noop">                                % type(value))
</span><span class="noop">
</span><span class="hit">    def __add__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        new = self.copy()
</span><span class="miss">        for selection in selections:
</span><span class="miss">            new[selection.name] = selection
</span><span class="miss">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        for selection in selections:
</span><span class="miss">            self[selection.name] = selection
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        new = self.copy()
</span><span class="miss">        for selection in selections:
</span><span class="miss">            try:
</span><span class="miss">                del(new[selection.name])
</span><span class="miss">            except KeyError:
</span><span class="miss">                pass
</span><span class="miss">        return new
</span><span class="noop">
</span><span class="hit">    def __isub__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        for selection in selections:
</span><span class="miss">            try:
</span><span class="miss">                del(self[selection.name])
</span><span class="miss">            except KeyError:
</span><span class="miss">                pass
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        prefix += &#39;Selections(&#39;
</span><span class="miss">        blanks = &#39; &#39; * len(prefix)
</span><span class="miss">        selections = sorted(self.selections)
</span><span class="miss">        if selections:
</span><span class="miss">            lines = [&#39;%s,&#39; % selections[0].assignrepr(prefix)]
</span><span class="miss">            for selection in selections:
</span><span class="miss">                lines.append(&#39;%s,&#39; % selection.assignrepr(blanks))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="noop">        else:
</span><span class="miss">            lines = [&#39;%s)&#39; % prefix]
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return [&#39;names&#39;, &#39;selections&#39;, &#39;assignrepr&#39;] + self.names
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Selection(object):
</span><span class="noop">    &#34;&#34;&#34;Defines a combination of :class:`~hydpy.core.node.Node` and
</span><span class="noop">    :class:`~hydpy.core.element.Element` objects suitable for a
</span><span class="noop">    specific task.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * name (:class:`str`): Name of the selection.
</span><span class="noop">        * nodes (:class:`~hydpy.core.node.Nodes`):
</span><span class="noop">          Currently selected nodes.
</span><span class="noop">        * elements (:class:`~hydpy.core.element.Elements`):
</span><span class="noop">          Currently selected elements.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, nodes=None, elements=None):
</span><span class="hit">        self.name = name
</span><span class="hit">        self.nodes = devicetools.Nodes(nodes)
</span><span class="hit">        self.elements = devicetools.Elements(elements)
</span><span class="noop">
</span><span class="hit">    def select_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Limit the current selection to the network upstream of the given
</span><span class="noop">        starting point, including the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Lowest point
</span><span class="noop">              to be selected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes, self.elements = self.getby_upstream(device)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Remove the network upstream of the given starting point from the
</span><span class="noop">        current selection, including the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Highest point
</span><span class="noop">              to be deselected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes, elements = self.getby_upstream(device)
</span><span class="hit">        self.nodes -= nodes
</span><span class="hit">        self.elements -= elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Returns the network upstream of the given starting point, including
</span><span class="noop">        the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Lowest point
</span><span class="noop">              to be selected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = devicetools.Nodes()
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        if isinstance(device, devicetools.Node):
</span><span class="hit">            nodes, elements = self._nextnode(device, nodes, elements)
</span><span class="miss">        elif isinstance(device, devicetools.Element):
</span><span class="miss">            nodes, elements = self._nextelement(device, nodes, elements)
</span><span class="noop">        else:
</span><span class="miss">            raise AttributeError(&#39;Pass either a `Node` or an `Element` &#39;
</span><span class="noop">                                 &#39;instance to the function.  The given &#39;
</span><span class="noop">                                 &#39;`device` value `%s` is of type `%s`.&#39;
</span><span class="noop">                                 % (device, type(device)))
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def _nextnode(self, node, nodes, elements):
</span><span class="noop">        &#34;&#34;&#34;First recursion method for :func:`~Selection.getupstreamnetwork`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * node (:class:`~hydpy.core.devicetools.Node`): The node which
</span><span class="noop">              is selected currently.
</span><span class="noop">            * nodes (:class:`~hydpy.core.devicetools.Nodes`): All nodes
</span><span class="noop">            which have been selected so far.
</span><span class="noop">            * elements (:class:`~hydpy.core.devicetools.Elements`): All
</span><span class="noop">            elements which have been selected so far.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if (node not in nodes) and (node in self.nodes):
</span><span class="hit">            nodes += node
</span><span class="hit">            for (name, element) in node.entries:
</span><span class="hit">                nodes, elements = self._nextelement(element, nodes, elements)
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def _nextelement(self, element, nodes, elements):
</span><span class="noop">        &#34;&#34;&#34;Second recursion method for :func:`~Selection.getupstreamnetwork`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * element (:class:`~hydpy.core.devicetools.Element`): The
</span><span class="noop">              element which is selected currently.
</span><span class="noop">            * nodes (:class:`~hydpy.core.devicetools.Nodes`): All nodes
</span><span class="noop">            which have been selected so far.
</span><span class="noop">            * elements (:class:`~hydpy.core.devicetools.Elements`): All
</span><span class="noop">            elements which have been selected so far.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if (element not in elements) and (element in self.elements):
</span><span class="hit">            elements += element
</span><span class="hit">            for (name, node) in element.inlets:
</span><span class="hit">                nodes, elements = self._nextnode(node, nodes, elements)
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def select_modelclasses(self, *modelclass):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements containing the
</span><span class="noop">        given modelclass(es).  (All nodes are removed.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.nodes = devicetools.Nodes()
</span><span class="miss">        self.elements = self.getby_modelclasses(modelclass)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_modelclasses(self, *modelclasses):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements not containing the
</span><span class="noop">        given modelclass(es).  (All nodes are removed.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.nodes = devicetools.Nodes()
</span><span class="miss">        self.elements -= self.getby_modelclasses(*modelclasses)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def getby_modelclasses(self, *modelclasses):
</span><span class="noop">        &#34;&#34;&#34;Returns all elements of the current selection containing the given
</span><span class="noop">        modelclass(es).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        elements = devicetools.Elements()
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            if element.model is None:
</span><span class="miss">                raise RuntimeError(&#39;For element `%s` no model object has been &#39;
</span><span class="noop">                                   &#39;initialized so far, which is a necessary &#39;
</span><span class="noop">                                   &#39;condition to perform (de)selections based &#39;
</span><span class="noop">                                   &#39;on model classes.&#39; % name)
</span><span class="miss">            if isinstance(element.model, modelclasses):
</span><span class="miss">                elements += element
</span><span class="miss">        return elements
</span><span class="noop">
</span><span class="hit">    def select_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all nodes with a name
</span><span class="noop">        containing the given substring(s).  (All elements are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes = self.getby_nodenames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all nodes with a name
</span><span class="noop">        not containing the given substring(s).  (All elements are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes -= self.getby_nodenames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Returns all nodes of the current selection with a name
</span><span class="noop">        containing the given substrings(s).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = devicetools.Nodes()
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            for substring in substrings:
</span><span class="hit">                if substring in name:
</span><span class="hit">                    nodes += node
</span><span class="hit">                    break
</span><span class="hit">        return nodes
</span><span class="noop">
</span><span class="hit">    def select_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements with a name
</span><span class="noop">        containing the given substring(s).  (All nodes are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.elements = self.getby_elementnames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements with a name
</span><span class="noop">        not containing the given substring(s).  (All nodes are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.elements -= self.getby_elementnames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Returns all elements of the current selection with a name
</span><span class="noop">        containing the given substrings(s).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        for (name, element) in self.elements:
</span><span class="hit">            for substring in substrings:
</span><span class="hit">                if substring in name:
</span><span class="hit">                    elements += element
</span><span class="hit">                    break
</span><span class="hit">        return elements
</span><span class="noop">
</span><span class="hit">    def copy(self, name):
</span><span class="noop">        &#34;&#34;&#34;Returns a semi-deep copy of the current selection.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * name (:class:`str`): Name of the new :class:`Selection` instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return Selection(name, self.nodes.copy(), self.elements.copy())
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self.nodes) + len(self.elements)
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.nodes += other.nodes
</span><span class="hit">        self.elements += other.elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.nodes -= other.nodes
</span><span class="hit">        self.elements -= other.elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="miss">        return ((self.nodes &lt; other.nodes) and
</span><span class="noop">                (self.elements &lt; other.elements))
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="miss">        return ((self.nodes &lt;= other.nodes) and
</span><span class="noop">                (self.elements &lt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="miss">        return ((self.nodes == other.nodes) and
</span><span class="noop">                (self.elements == other.elements))
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="miss">        return ((self.nodes != other.nodes) or
</span><span class="noop">                (self.elements != other.elements))
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        return ((self.nodes &gt;= other.nodes) and
</span><span class="noop">                (self.elements &gt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="miss">        return ((self.nodes &gt; other.nodes) and
</span><span class="noop">                (self.elements &gt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return self.name
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        prefixblanks = &#39; &#39; * len(prefix)
</span><span class="miss">        lines = [&#39;%sSelection(&#34;%s&#34;,&#39;% (prefix, self.name)]
</span><span class="miss">        blanks = &#39; &#39; * (len(prefix) + 22)
</span><span class="miss">        names = sorted(self.nodes.names)
</span><span class="miss">        if names:
</span><span class="miss">            lines.append(&#39;%s          nodes=Nodes(&#34;%s&#34;,&#39;
</span><span class="noop">                         % (prefixblanks, names[0]))
</span><span class="miss">            for name in names[1:]:
</span><span class="miss">                lines.append(&#39;%s&#34;%s&#34;,&#39; % (blanks, name))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;),&#39;
</span><span class="noop">        else:
</span><span class="miss">            lines.append(&#39;%sSelection(nodes=Nodes(),&#39;
</span><span class="noop">                         % prefixblanks)
</span><span class="miss">        blanks = &#39; &#39; * (len(prefix) + 28)
</span><span class="miss">        names = sorted(self.elements.names)
</span><span class="miss">        if names:
</span><span class="miss">            lines.append(&#39;%s          elements=Elements(&#34;%s&#34;,&#39;
</span><span class="noop">                         % (prefixblanks, names[0]))
</span><span class="miss">            for name in names[1:]:
</span><span class="miss">                lines.append(&#39;%s&#34;%s&#34;,&#39; % (blanks, name))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;))&#39;
</span><span class="noop">        else:
</span><span class="miss">            lines.append(&#39;%s          elements=Elements())&#39;
</span><span class="noop">                         % prefixblanks)
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return [&#39;copy&#39;, &#39;deselect_elementnames&#39;, &#39;deselect_modelclasses&#39;,
</span><span class="noop">                &#39;deselect_nodenames&#39;, &#39;deselect_upstream&#39;, &#39;elements&#39;,
</span><span class="noop">                &#39;getby_elementnames&#39;, &#39;getby_modelclasses&#39;, &#39;getby_nodenames&#39;,
</span><span class="noop">                &#39;getby_upstream&#39;, &#39;nodes&#39;, &#39;select_elementnames&#39;,
</span><span class="noop">                &#39;select_modelclasses&#39;, &#39;select_nodenames&#39;, &#39;select_upstream&#39;,
</span><span class="noop">                &#39;assignrepr&#39;]</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Created on Tue Dec 27 23:23:53 2016
</span><span class="noop">
</span><span class="noop">@author: tyralla
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import copy
</span><span class="hit">import struct
</span><span class="hit">import textwrap
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.cythons import pointer
</span><span class="noop">
</span><span class="hit">class Sequences(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling all sequences of a specific model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, kwargs):
</span><span class="hit">        self.model = kwargs.get(&#39;model&#39;)
</span><span class="hit">        cythonmodule = kwargs.get(&#39;cythonmodule&#39;)
</span><span class="hit">        cymodel = kwargs.get(&#39;cymodel&#39;)
</span><span class="hit">        for (name, cls) in kwargs.items():
</span><span class="hit">            if name.endswith(&#39;Sequences&#39;) and issubclass(cls, SubSequences):
</span><span class="hit">                if cythonmodule:
</span><span class="hit">                    cls_fastaccess = getattr(cythonmodule, name)
</span><span class="hit">                    subseqs = cls(self, cls_fastaccess, cymodel)
</span><span class="noop">                else:
</span><span class="hit">                    subseqs = cls(self, None, None)
</span><span class="hit">                setattr(self, subseqs.name, subseqs)
</span><span class="noop">
</span><span class="hit">    def set_initvals(self, info, idx_date):
</span><span class="miss">        self.states.set_initvals(info, idx_date)
</span><span class="noop">
</span><span class="hit">    def activate_disk(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;activate_disk&#39;):
</span><span class="miss">                subseqs.activate_disk(names)
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;deactivate_disk&#39;):
</span><span class="miss">                subseqs.deactivate_disk(names)
</span><span class="noop">
</span><span class="hit">    def activate_ram(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;activate_ram&#39;):
</span><span class="miss">                subseqs.activate_ram(names)
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;deactivate_ram&#39;):
</span><span class="miss">                subseqs.deactivate_ram(names)
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;openfiles&#39;):
</span><span class="miss">                subseqs.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;closefiles&#39;):
</span><span class="miss">                subseqs.closefiles()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;loaddata&#39;):
</span><span class="miss">                subseqs.loaddata(idx)
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;savedata&#39;):
</span><span class="hit">                subseqs.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;reset&#39;):
</span><span class="miss">                subseqs.reset()
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (key, value) in vars(self).items():
</span><span class="hit">            if isinstance(value, SubSequences):
</span><span class="hit">                yield key, value
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def conditions(self):
</span><span class="noop">        &#34;&#34;&#34;Generator object yielding all conditions (class:`StateSequence` and
</span><span class="noop">        :class:`LogSequence` objects).
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        for subseqs in (&#39;states&#39;, &#39;logs&#39;):
</span><span class="miss">            for tuple_ in getattr(self, subseqs, ()):
</span><span class="miss">                yield tuple_
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def hasconditions(self):
</span><span class="noop">        &#34;&#34;&#34;True or False, whether the :class:`Sequences` object handles at
</span><span class="noop">        conditions (at least one :class:`StateSequence` or :class:`LogSequence`
</span><span class="noop">        object)  or not.&#34;&#34;&#34;
</span><span class="miss">        for tuple_ in self.conditions:
</span><span class="miss">            return True
</span><span class="miss">        return False
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _conditiondefaultfilename(self):
</span><span class="miss">        filename = objecttools.devicename(self)
</span><span class="miss">        if filename == &#39;?&#39;:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;To load or save the conditions of a model from or to a file, &#39;
</span><span class="noop">                &#39;its filename must be known.  This can be done, by passing &#39;
</span><span class="noop">                &#39;filename to function `loadconditions` or `saveconditions` &#39;
</span><span class="noop">                &#39;directly.  But in complete HydPy applications, it is usally &#39;
</span><span class="noop">                &#39;assumed to be consistent with the name of the element &#39;
</span><span class="noop">                &#39;handling the model.  Actually, neither a filename is given &#39;
</span><span class="noop">                &#39;nor does the model know its master element.&#39;)
</span><span class="noop">        else:
</span><span class="miss">            return filename + &#39;.py&#39;
</span><span class="noop">
</span><span class="hit">    def loadconditions(self, filename=None, dirname=None):
</span><span class="noop">        &#34;&#34;&#34;Load initial conditions from a file and assign them to the
</span><span class="noop">        respective sequences.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.hasconditions:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._conditiondefaultfilename
</span><span class="miss">            namespace = locals()
</span><span class="miss">            for (name, seq) in self.conditions:
</span><span class="miss">                namespace[name] = seq
</span><span class="miss">            namespace[&#39;model&#39;] = self
</span><span class="miss">            code = pub.conditionmanager.loadfile(filename, dirname)
</span><span class="miss">            try:
</span><span class="miss">                exec(code)
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(&#39;While trying to gather initial &#39;
</span><span class="noop">                                              &#39;conditions of element %s&#39;
</span><span class="noop">                                              % objecttools.devicename(self))
</span><span class="noop">
</span><span class="hit">    def saveconditions(self, filename=None, dirname=None):
</span><span class="miss">        if self.hasconditions:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._conditiondefaultfilename
</span><span class="miss">            if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">                filename += &#39;.py&#39;
</span><span class="miss">            if dirname is None:
</span><span class="miss">                dirname = pub.conditionmanager.savepath
</span><span class="miss">            filepath = os.path.join(dirname, filename)
</span><span class="miss">            with file(filepath, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(&#39;from hydpy.models.%s import *\n\n&#39;
</span><span class="noop">                            % self.model.__module__.split(&#39;.&#39;)[2])
</span><span class="miss">                try:
</span><span class="miss">                    line = (&#39;controlcheck(projectdir=&#34;%s&#34;, controldir=&#34;%s&#34;)&#39;
</span><span class="noop">                            % (pub.controlmanager.projectdirectory,
</span><span class="noop">                               pub.controlmanager.controldirectory))
</span><span class="miss">                    file_.write(line + &#39;\n\n&#39;)
</span><span class="miss">                except BaseException:
</span><span class="miss">                    pass
</span><span class="miss">                for (name, seq) in self.conditions:
</span><span class="miss">                    file_.write(repr(seq) + &#39;\n&#39;)
</span><span class="noop">
</span><span class="hit">    def trimconditions(self):
</span><span class="miss">        for (name, seq) in self.conditions:
</span><span class="miss">            seq.trim()
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(dict(self))
</span><span class="noop">
</span><span class="hit">class SubSequences(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling subgroups of sequences.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">      * seqs: The parent :class:`Sequences` object.
</span><span class="noop">      * fastaccess: The  :class:`FastAccess` object allowing fast access to
</span><span class="noop">        the sequence values. In `Cython` mode, model specific cdef
</span><span class="noop">        classes are applied.
</span><span class="noop">
</span><span class="noop">    Additional attributes are the actual :class:`Sequence` instances,
</span><span class="noop">    representing the individual time series.  These need to be defined in
</span><span class="noop">    :class:`SubSequences` subclass.  Therefore, one needs to collect the
</span><span class="noop">    appropriate :class:`Sequence` subclasses in the (hidden) class attribute
</span><span class="noop">    :attr:`~SubSequences._SEQCLASSES`, as shown in the following example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.sequencetools import *
</span><span class="noop">    &gt;&gt;&gt; class Temperature(Sequence):
</span><span class="noop">    ...    NDIM, NUMERIC = 0, False
</span><span class="noop">    &gt;&gt;&gt; class Precipitation(Sequence):
</span><span class="noop">    ...    NDIM, NUMERIC = 0, True
</span><span class="noop">    &gt;&gt;&gt; class InputSequences(SubSequences):
</span><span class="noop">    ...     _SEQCLASSES = (Temperature, Precipitation)
</span><span class="noop">    &gt;&gt;&gt; inputs = InputSequences(None) # Assign `None` for brevity.
</span><span class="noop">    &gt;&gt;&gt; inputs
</span><span class="noop">    temperature(0.0)
</span><span class="noop">    precipitation(0.0)
</span><span class="noop">
</span><span class="noop">    The order within the tuple determines the order of iteration, hence:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; for (name, sequence) in inputs:
</span><span class="noop">    ...     print(sequence)
</span><span class="noop">    temperature(0.0)
</span><span class="noop">    precipitation(0.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self, seqs, cls_fastaccess=None, cymodel=None):
</span><span class="hit">        self.seqs = seqs
</span><span class="hit">        self._initfastaccess(cls_fastaccess, cymodel)
</span><span class="hit">        self._initsequences()
</span><span class="noop">
</span><span class="hit">    def _initfastaccess(self, cls_fastaccess, cymodel):
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess = FastAccess()
</span><span class="noop">        else:
</span><span class="hit">            self.fastaccess = cls_fastaccess()
</span><span class="hit">            setattr(cymodel, self.name, self.fastaccess)
</span><span class="noop">
</span><span class="hit">    def _initsequences(self):
</span><span class="hit">        for cls_seq in self._SEQCLASSES:
</span><span class="hit">            setattr(self, objecttools.instancename(cls_seq), cls_seq())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return objecttools.instancename(cls)[:-8]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def name(self):
</span><span class="hit">        return self.getname()
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="noop">        &#34;&#34;&#34;Attributes and methods should usually not be replaced.  Existing
</span><span class="noop">        :class:`Sequence` attributes are protected in a way, that only their
</span><span class="noop">        values are changed through assignements.  For new :class:`Sequence`
</span><span class="noop">        attributes, additional `fastaccess` references are defined.  If you
</span><span class="noop">        actually want to replace a sequence, you have to delete it first.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            attr = getattr(self, name)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            object.__setattr__(self, name, value)
</span><span class="hit">            if isinstance(value, Sequence):
</span><span class="hit">                value.connect2subseqs(self)
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                attr.values = value
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;`%s` instances do not allow the direct&#39;
</span><span class="noop">                                   &#39;replacement of their members.  After &#39;
</span><span class="noop">                                   &#39;initialization you should usually only &#39;
</span><span class="noop">                                   &#39;change parameter values through &#39;
</span><span class="noop">                                   &#39;assignements.  If you really need to &#39;
</span><span class="noop">                                   &#39;replace a object member, delete it &#39;
</span><span class="noop">                                   &#39;beforehand.&#39; % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for seqclass in self._SEQCLASSES:
</span><span class="hit">            name = objecttools.instancename(seqclass)
</span><span class="hit">            yield name, getattr(self, name)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = []
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="miss">            lines.append(&#39;#%s object defined in module %s.&#39;
</span><span class="noop">                         % (objecttools.classname(self),
</span><span class="noop">                            objecttools.modulename(self)))
</span><span class="miss">            lines.append(&#39;#The implemented sequences with their actual &#39;
</span><span class="noop">                         &#39;values are:&#39;)
</span><span class="hit">        for (name, sequence) in self:
</span><span class="hit">            try:
</span><span class="hit">                lines.append(&#39;%s&#39; % repr(sequence))
</span><span class="miss">            except BaseException:
</span><span class="miss">                lines.append(&#39;%s(?)&#39; % name)
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="hit">class IOSubSequences(SubSequences):
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="miss">        self.fastaccess.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="miss">        self.fastaccess.closefiles()
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.activate_ram()
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.deactivate_ram()
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.activate_disk()
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.deactivate_disk()
</span><span class="noop">
</span><span class="hit">    def ram2disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.ram2disk()
</span><span class="noop">
</span><span class="hit">    def disk2ram(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.disk2ram()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling input sequences.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="miss">        self.fastaccess.loaddata(idx)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling flux sequences.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return &#39;fluxes&#39;
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="hit">class StateSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling state sequences.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def _initfastaccess(self, cls_fastaccess, cymodel):
</span><span class="hit">        SubSequences._initfastaccess(self, cls_fastaccess, cymodel)
</span><span class="hit">        self.fastaccess_new = self.fastaccess
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess_old = FastAccess()
</span><span class="noop">        else:
</span><span class="hit">            setattr(cymodel, &#39;new_states&#39;, self.fastaccess)
</span><span class="hit">            self.fastaccess_old = cls_fastaccess()
</span><span class="hit">            setattr(cymodel, &#39;old_states&#39;, self.fastaccess_old)
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="noop">        &#34;&#34;&#34;Assign the new/final state values of the actual time step to the
</span><span class="noop">        new/initial state values of the next time step.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for (name, seq) in self:
</span><span class="hit">            seq.new2old()
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="miss">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.reset()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling log sequences.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.reset()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling aide sequences.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LinkSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling link sequences.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sequence(objecttools.ValueMath):
</span><span class="noop">    &#34;&#34;&#34;Only for inheritance.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.subseqs = None
</span><span class="hit">        self.fastaccess = None
</span><span class="noop">
</span><span class="hit">    def connect2subseqs(self, subseqs):
</span><span class="hit">        self.subseqs = subseqs
</span><span class="hit">        self.fastaccess = subseqs.fastaccess
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_ndim&#39; % self.name, self.NDIM)
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_length&#39; % self.name, 0)
</span><span class="hit">        for idx in range(self.NDIM):
</span><span class="hit">            setattr(self.fastaccess, &#39;_%s_length_%d&#39; % (self.name, idx), 0)
</span><span class="hit">        self.diskflag = False
</span><span class="hit">        self.ramflag = False
</span><span class="hit">        try:
</span><span class="hit">            setattr(self.fastaccess, &#39;_%s_file&#39; % self.name, &#39;&#39;)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="hit">        self._initvalues()
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Sequence` instances
</span><span class="noop">        within initial condition files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.values = args
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            setattr(self.fastaccess, self.name, None)
</span><span class="noop">        else:
</span><span class="hit">            setattr(self.fastaccess, self.name, 0.)
</span><span class="noop">
</span><span class="hit">    def _getname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the sequence, which is the name if the instantiating
</span><span class="noop">        subclass of :class:`Sequence` in lower case letters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return objecttools.classname(self).lower()
</span><span class="hit">    name = property(_getname)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual time series value(s) handled by the respective
</span><span class="noop">        :class:`Sequence` instance.  For consistency, `value` and `values`
</span><span class="noop">        can always be used interchangeably.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            raise RuntimeError(&#39;No value/values of sequence %s of element &#39;
</span><span class="noop">                               &#39;%s has/have been defined so far.&#39;
</span><span class="noop">                               % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            if self.NDIM:
</span><span class="hit">                value = numpy.asarray(value)
</span><span class="hit">            return value
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                temp = value[0]
</span><span class="hit">                if len(value) &gt; 1:
</span><span class="miss">                    raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                     &#39;sequence %s of element %s, which is &#39;
</span><span class="noop">                                     &#39;ambiguous.&#39;
</span><span class="noop">                                     % (len(value),
</span><span class="noop">                                        objecttools.devicename(self),
</span><span class="noop">                                        self.name))
</span><span class="hit">                value = temp
</span><span class="hit">            except (TypeError, IndexError):
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = float(value)
</span><span class="miss">            except (ValueError, TypeError):
</span><span class="miss">                raise TypeError(&#39;When trying to set the value of sequence &#39;
</span><span class="noop">                                &#39;%s of element %s, it was not possible to &#39;
</span><span class="noop">                                &#39;convert value `%s` to float .&#39;
</span><span class="noop">                                % (self.name, objecttools.devicename(self),
</span><span class="noop">                                   value))
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                value = value.value
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = numpy.full(self.shape, value, dtype=float)
</span><span class="miss">            except ValueError:
</span><span class="miss">                raise ValueError(&#39;For sequence %s of element %s setting new &#39;
</span><span class="noop">                                 &#39;values failed.  The values `%s` cannot be &#39;
</span><span class="noop">                                 &#39;converted to a numpy ndarray with shape %s &#39;
</span><span class="noop">                                 &#39;containing entries of type float.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    value, self.shape))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple containing the lengths in all dimensions of the sequence
</span><span class="noop">        values at a specific time point.  Note that setting a new shape
</span><span class="noop">        results in a loss of the actual values of the respective sequence.
</span><span class="noop">        For 0-dimensional sequences :attr:`shape` is always an empty tuple.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            try:
</span><span class="hit">                return self.values.shape
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;Shape information for sequence %s of &#39;
</span><span class="noop">                                   &#39;element %s can only be retrieved after &#39;
</span><span class="noop">                                   &#39;it has been defined.&#39;
</span><span class="noop">                                   % (self.name,
</span><span class="noop">                                      objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="miss">            return ()
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            try:
</span><span class="hit">                array = numpy.full(shape, 0.)
</span><span class="miss">            except Exception:
</span><span class="miss">                prefix = (&#39;While trying create a new numpy ndarray` for &#39;
</span><span class="noop">                          &#39;sequence %s of element %s&#39;
</span><span class="noop">                          % (self.name, objecttools.devicename(self)))
</span><span class="miss">                objecttools.augmentexcmessage(prefix)
</span><span class="hit">            if array.ndim == self.NDIM:
</span><span class="hit">                setattr(self.fastaccess, self.name, array)
</span><span class="noop">            else:
</span><span class="miss">                raise ValueError(&#39;Sequence %s of element %s is %d-dimensional &#39;
</span><span class="noop">                                 &#39;but the given shape indicates %d dimensions.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    self.NDIM, array.ndim))
</span><span class="noop">        else:
</span><span class="miss">            if shape:
</span><span class="miss">                raise ValueError(&#39;The shape information of 0-dimensional &#39;
</span><span class="noop">                                 &#39;sequences as %s of element %s can only be &#39;
</span><span class="noop">                                 &#39;`()`, but `%s` is given.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    shape))
</span><span class="noop">            else:
</span><span class="miss">                self.value = 0.
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        try:
</span><span class="miss">            return self.values[key]
</span><span class="miss">        except Exception:
</span><span class="miss">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, values):
</span><span class="hit">        try:
</span><span class="hit">            self.values[key] = values
</span><span class="miss">        except Exception:
</span><span class="miss">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def _raiseitemexception(self):
</span><span class="miss">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` has no values so far.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">        else:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to item access the &#39;
</span><span class="noop">                                          &#39;values of sequence `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            return &#39;%s(%s)&#39; % (self.name, objecttools.repr_(self.value))
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            lines = []
</span><span class="hit">            cols = &#39;, &#39;.join(objecttools.repr_(value) for value in self.values)
</span><span class="hit">            wrappedlines = textwrap.wrap(cols, 80-len(self.name)-2)
</span><span class="hit">            for (idx, line) in enumerate(wrappedlines):
</span><span class="hit">                if not idx:
</span><span class="hit">                    lines.append(&#39;%s(%s&#39; % (self.name, line))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append((len(self.name)+1)*&#39; &#39; + line)
</span><span class="hit">            lines[-1] += &#39;)&#39;
</span><span class="hit">            return &#39;\n&#39;.join(lines)
</span><span class="miss">        elif self.NDIM == 2:
</span><span class="miss">            lines = []
</span><span class="miss">            skip = (1+len(self.name)) * &#39; &#39;
</span><span class="miss">            for (idx, row) in enumerate(self.values):
</span><span class="miss">                cols = &#39;, &#39;.join(objecttools.repr_(value) for value in row)
</span><span class="miss">                if not idx:
</span><span class="miss">                    lines.append(&#39;%s(%s,&#39; % (self.name, cols))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append(&#39;%s%s,&#39; % (skip, cols))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">            return &#39;\n&#39;.join(lines)
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;`repr` does not yet support &#39;
</span><span class="noop">                                      &#39;sequences, which handle %d-&#39;
</span><span class="noop">                                      &#39;dimensional matrices.&#39; % self.NDIM)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="hit">class IOSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34;Only for inheritance.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Sequence.__init__(self)
</span><span class="hit">        self._rawfilename = None
</span><span class="hit">        self._filetype_ext = None
</span><span class="hit">        self._filename_ext = None
</span><span class="hit">        self._dirpath_ext = None
</span><span class="hit">        self._dirpath_int = None
</span><span class="hit">        self._filepath_ext = None
</span><span class="hit">        self._filepath_int = None
</span><span class="noop">
</span><span class="hit">    def _getfiletype_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Ending of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filetype_ext:
</span><span class="miss">            return self._filetype_ext
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                if isinstance(self, InputSequence):
</span><span class="miss">                    return pub.sequencemanager.inputfiletype
</span><span class="miss">                elif isinstance(self, NodeSequence):
</span><span class="miss">                    return pub.sequencemanager.nodefiletype
</span><span class="noop">                else:
</span><span class="miss">                    return pub.sequencemanager.outputfiletype
</span><span class="noop">
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence %s of element %s the type &#39;
</span><span class="noop">                                   &#39;of the external data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % (self.name,
</span><span class="noop">                                      objecttools.devicename(self)))
</span><span class="hit">    def _setfiletype_ext(self, name):
</span><span class="miss">        self._filetype_ext = name
</span><span class="hit">    def _delfiletype_ext(self, name):
</span><span class="miss">        self._filetype_ext = None
</span><span class="hit">    filetype_ext = property(_getfiletype_ext, _setfiletype_ext,
</span><span class="noop">                            _delfiletype_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilename_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Complete filename of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filename_ext:
</span><span class="miss">            return self._filename_ext
</span><span class="noop">        else:
</span><span class="miss">            return &#39;.&#39;.join((self.rawfilename, self.filetype_ext))
</span><span class="hit">    def _setfilename_ext(self, name):
</span><span class="miss">        self._filename_ext = name
</span><span class="hit">    def _delfilename_ext(self):
</span><span class="miss">        self._filename_ext = None
</span><span class="hit">    filename_ext = property(_getfilename_ext, _setfilename_ext,
</span><span class="noop">                            _delfilename_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilename_int(self):
</span><span class="noop">        &#34;&#34;&#34;Complete filename of the internal data file.&#34;&#34;&#34;
</span><span class="miss">        return self.rawfilename + &#39;.bin&#39;
</span><span class="hit">    filename_int = property(_getfilename_int)
</span><span class="noop">
</span><span class="hit">    def _getdirpath_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._dirpath_ext:
</span><span class="miss">            return self._dirpath_ext
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                if isinstance(self, InputSequence):
</span><span class="miss">                    return pub.sequencemanager.inputpath
</span><span class="miss">                elif isinstance(self, NodeSequence):
</span><span class="miss">                    return pub.sequencemanager.nodepath
</span><span class="noop">                else:
</span><span class="miss">                    return pub.sequencemanager.outputpath
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the directory of &#39;
</span><span class="noop">                                   &#39;the external data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="hit">    def _setdirpath_ext(self, name):
</span><span class="miss">        self._dirpath_ext = name
</span><span class="hit">    def _deldirpath_ext(self, name):
</span><span class="miss">        self._dirpath_ext = None
</span><span class="hit">    dirpath_ext = property(_getdirpath_ext, _setdirpath_ext, _deldirpath_ext)
</span><span class="noop">
</span><span class="hit">    def _getdirpath_int(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory of the internal data file.&#34;&#34;&#34;
</span><span class="miss">        if self._dirpath_int:
</span><span class="miss">            return self._dirpath_int
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return pub.sequencemanager.temppath
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the directory of &#39;
</span><span class="noop">                                   &#39;the internal data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="hit">    def _setdirpath_int(self, name):
</span><span class="miss">        self._dirpath_int = name
</span><span class="hit">    def _deldirpath_int(self, name):
</span><span class="miss">        self._dirpath_int = None
</span><span class="hit">    dirpath_int = property(_getdirpath_int, _setdirpath_int, _deldirpath_int)
</span><span class="noop">
</span><span class="hit">    def _getfilepath_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path to the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filepath_ext:
</span><span class="miss">            return self._filepath_ext
</span><span class="noop">        else:
</span><span class="miss">            return os.path.join(self.dirpath_ext, self.filename_ext)
</span><span class="hit">    def _setfilepath_ext(self, name):
</span><span class="miss">        self._filepath_ext = name
</span><span class="hit">    def _delfilepath_ext(self):
</span><span class="miss">        self._filepath_ext = None
</span><span class="hit">    filepath_ext = property(_getfilepath_ext, _setfilepath_ext,
</span><span class="noop">                            _delfilepath_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilepath_int(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path to the internal data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filepath_int:
</span><span class="miss">            return self._filepath_int
</span><span class="noop">        else:
</span><span class="miss">            return os.path.join(self.dirpath_int, self.filename_int)
</span><span class="hit">    def _setfilepath_int(self, name):
</span><span class="miss">        self._filepath_int = name
</span><span class="hit">    def _delfilepath_int(self):
</span><span class="miss">        self._filepath_int = None
</span><span class="hit">    filepath_int = property(_getfilepath_int, _setfilepath_int,
</span><span class="noop">                            _delfilepath_int)
</span><span class="noop">
</span><span class="hit">    def update_fastaccess(self):
</span><span class="noop">        &#34;&#34;&#34;&#34;&#34;&#34;
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            path = self.filepath_int
</span><span class="noop">        else:
</span><span class="hit">            path = None
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_path&#39; % self.name, path)
</span><span class="hit">        length = 1
</span><span class="hit">        for idx in range(self.NDIM):
</span><span class="hit">            length *= self.shape[idx]
</span><span class="hit">            setattr(self.fastaccess, &#39;_%s_length_%d&#39; % (self.name, idx),
</span><span class="noop">                    self.shape[idx])
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_length&#39; % self.name, length)
</span><span class="noop">
</span><span class="hit">    def _getdiskflag(self):
</span><span class="hit">        diskflag = getattr(self.fastaccess, &#39;_%s_diskflag&#39; % self.name, None)
</span><span class="hit">        if diskflag is not None:
</span><span class="hit">            return diskflag
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `diskflag` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="hit">    def _setdiskflag(self, value):
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_diskflag&#39; % self.name,  bool(value))
</span><span class="hit">    diskflag = property(_getdiskflag, _setdiskflag)
</span><span class="noop">
</span><span class="hit">    def _getramflag(self):
</span><span class="miss">        ramflag = getattr(self.fastaccess, &#39;_%s_ramflag&#39; % self.name, None)
</span><span class="miss">        if ramflag is not None:
</span><span class="miss">            return ramflag
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `ramflag` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="hit">    def _setramflag(self, value):
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_ramflag&#39; % self.name,  bool(value))
</span><span class="hit">    ramflag = property(_getramflag, _setramflag)
</span><span class="noop">
</span><span class="hit">    def _getmemoryflag(self):
</span><span class="miss">        return self.ramflag or self.diskflag
</span><span class="hit">    memoryflag = property(_getmemoryflag)
</span><span class="noop">
</span><span class="hit">    def _getarray(self):
</span><span class="miss">        array = getattr(self.fastaccess, &#39;_%s_array&#39; % self.name, None)
</span><span class="miss">        if array is not None:
</span><span class="miss">            return numpy.asarray(array)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `ram array` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="hit">    def _setarray(self, values):
</span><span class="miss">        values = numpy.array(values, dtype=float)
</span><span class="miss">        setattr(self.fastaccess, &#39;_%s_array&#39; % self.name,  values)
</span><span class="noop">
</span><span class="hit">    def _getseriesshape(self):
</span><span class="noop">        &#34;&#34;&#34;Shape of the whole time series (time beeing the first dimension).&#34;&#34;&#34;
</span><span class="miss">        seriesshape = [len(pub.timegrids.init)]
</span><span class="miss">        seriesshape.extend(self.shape)
</span><span class="miss">        return tuple(seriesshape)
</span><span class="hit">    seriesshape = property(_getseriesshape)
</span><span class="noop">
</span><span class="noop">#    def _gettimegrid_init(self):
</span><span class="noop">#        if self._timegrid_init is not None:
</span><span class="noop">#            return self._timegrid_init
</span><span class="noop">#        else:
</span><span class="noop">#            try:
</span><span class="noop">#                return pub.timegrids.init
</span><span class="noop">#            except AttributeError:
</span><span class="noop">#                raise RuntimeError(&#39;Initializing internal data of sequence &#39;
</span><span class="noop">#                                   &#39;`%s` requires information about the &#39;
</span><span class="noop">#                                   &#39;initialization period.  Define an &#39;
</span><span class="noop">#                                   &#39;appropriate `Timegrid` instance and &#39;
</span><span class="noop">#                                   &#39;either pass it to the sequence object &#39;
</span><span class="noop">#                                   &#39;or store it in the `pub` module as &#39;
</span><span class="noop">#                                   &#39;described in the documentation.&#39;
</span><span class="noop">#                                   % self.name)
</span><span class="noop">#    def _settimegrid_init(self, timegrid):
</span><span class="noop">#        self._timegrid_init = timegrid
</span><span class="noop">#    timegrid_init = property(_gettimegrid_init, _settimegrid_init)
</span><span class="noop">
</span><span class="hit">    def _getseries(self):
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            return self._load_int()
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            return self._getarray()
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available to the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="hit">    def _setseries(self, values):
</span><span class="miss">        series = self.series
</span><span class="miss">        series[:] = values
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            self._save_int(series)
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            self._setarray(series)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available to the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="hit">    def _delseries(self):
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            os.remove(self.filepath_int)
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            setattr(self.fastaccess, &#39;_%s_array&#39; %self.name, None)
</span><span class="hit">    series = property(_getseries, _setseries, _delseries)
</span><span class="noop">
</span><span class="hit">    def load_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Load the external data series in accordance with
</span><span class="noop">        :attr:`~IOSequence.timegrid_init` and store it as internal data.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.filetype_ext == &#39;npy&#39;:
</span><span class="miss">            timegrid_data, values = self._load_npy()
</span><span class="noop">        else:
</span><span class="miss">            timegrid_data, values = self._load_asc()
</span><span class="noop">
</span><span class="miss">        if pub.timegrids.init not in timegrid_data:
</span><span class="miss">            raise RuntimeError(&#39;For sequence `%s` the initialization time &#39;
</span><span class="noop">                               &#39;grid (%s) does not define a subset of the &#39;
</span><span class="noop">                               &#39;time grid of the external data file %s (%s).&#39;
</span><span class="noop">                               % (self.name, pub.timegrids.init,
</span><span class="noop">                                  self.filepath_ext, timegrid_data))
</span><span class="miss">        idx1 = timegrid_data[pub.timegrids.init.firstdate]
</span><span class="miss">        idx2 = timegrid_data[pub.timegrids.init.lastdate]
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            self._save_int(values[idx1:idx2])
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            self._setarray(values[idx1:idx2])
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available the the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">
</span><span class="hit">    def save_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Write the internal data into an external data file.&#34;&#34;&#34;
</span><span class="miss">        if self.filetype_ext == &#39;npy&#39;:
</span><span class="miss">            values = pub.timegrids.init.toarray()
</span><span class="miss">            for idx in range(self.NDIM):
</span><span class="miss">                values = numpy.expand_dims(values, idx+1)
</span><span class="miss">            values = values + numpy.zeros(self.shape)
</span><span class="miss">            values = numpy.concatenate((values, self.series))
</span><span class="miss">            numpy.save(self.filepath_ext, values)
</span><span class="noop">        else:
</span><span class="miss">            with file(self.filepath_ext, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(repr(pub.timegrids.init) + &#39;\n&#39;)
</span><span class="miss">                numpy.savetxt(file_, self.series, delimiter=&#39;\t&#39;)
</span><span class="noop">
</span><span class="hit">    def _load_npy(self):
</span><span class="noop">        &#34;&#34;&#34;Return the data timegrid and the complete external data from a
</span><span class="noop">        binary numpy file.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            data = numpy.load(self.filepath_ext)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = (&#39;While trying to load the external data of sequence &#39;
</span><span class="noop">                      &#39;`%s` from file `%s`&#39; % (self.name, self.filepath_ext))
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        try:
</span><span class="miss">            timegrid_data = timetools.Timegrid.fromarray(data)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = (&#39;While trying to retrieve the data timegrid of the &#39;
</span><span class="noop">                      &#39;external data file `%s` of sequence `%s`&#39;
</span><span class="noop">                      % (self.filepath_ext, self.name))
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        return timegrid_data, data[13:]
</span><span class="noop">
</span><span class="hit">    def _load_asc(self):
</span><span class="miss">        with file(self.filepath_ext) as file_:
</span><span class="miss">            header = &#39;\n&#39;.join([file_.readline() for idx in range(3)])
</span><span class="miss">        timegrid_data = eval(header, {}, {&#39;Timegrid&#39;: timetools.Timegrid})
</span><span class="miss">        values = numpy.loadtxt(self.filepath_ext, skiprows=3,
</span><span class="noop">                               ndmin=self.NDIM+1)
</span><span class="miss">        return timegrid_data, values
</span><span class="noop">
</span><span class="hit">    def _load_int(self):
</span><span class="noop">        &#34;&#34;&#34;Load internal data from file and return it.&#34;&#34;&#34;
</span><span class="miss">        values = numpy.fromfile(self.filepath_int)
</span><span class="miss">        if self.NDIM &gt; 0:
</span><span class="miss">            values = values.reshape(self.seriesshape)
</span><span class="miss">        return values
</span><span class="noop">
</span><span class="hit">    def zero_int(self):
</span><span class="noop">        &#34;&#34;&#34;Initialize the internal data series with zero values.&#34;&#34;&#34;
</span><span class="miss">        values = numpy.zeros(self.seriesshape)
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            self._save_int(values)
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            self._setarray(values)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available to the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">
</span><span class="hit">    def _save_int(self, values):
</span><span class="miss">        values.tofile(self.filepath_int)
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="noop">        &#34;&#34;&#34;Demand reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        self.deactivate_ram()
</span><span class="miss">        self.diskflag = True
</span><span class="miss">        if (isinstance(self, InputSequence) or
</span><span class="noop">            (isinstance(self, NodeSequence) and self.use_ext)):
</span><span class="miss">            self.load_ext()
</span><span class="noop">        else:
</span><span class="miss">            self.zero_int()
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self):
</span><span class="noop">        &#34;&#34;&#34;Prevent from reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            del self.series
</span><span class="miss">            self.diskflag = False
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="noop">        &#34;&#34;&#34;Demand reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        self.deactivate_disk()
</span><span class="miss">        self.ramflag = True
</span><span class="miss">        if (isinstance(self, InputSequence) or
</span><span class="noop">            (isinstance(self, NodeSequence) and self.use_ext)):
</span><span class="miss">            self.load_ext()
</span><span class="noop">        else:
</span><span class="miss">            self.zero_int()
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self):
</span><span class="noop">        &#34;&#34;&#34;Prevent from reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        if self.ramflag:
</span><span class="miss">            del self.series
</span><span class="miss">            self.ramflag = False
</span><span class="noop">
</span><span class="hit">    def disk2ram(self):
</span><span class="noop">        &#34;&#34;&#34;Move internal data from disk to RAM.&#34;&#34;&#34;
</span><span class="miss">        values = self.series
</span><span class="miss">        self.deactivate_disk()
</span><span class="miss">        self.ramflag = True
</span><span class="miss">        self._setarray(values)
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def ram2disk(self):
</span><span class="noop">        &#34;&#34;&#34;Move internal data from RAM to disk.&#34;&#34;&#34;
</span><span class="miss">        values = self.series
</span><span class="miss">        self.deactivate_ram()
</span><span class="miss">        self.diskflag = True
</span><span class="miss">        self._save_int(values)
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        Sequence._setshape(self, shape)
</span><span class="hit">        self.update_fastaccess()
</span><span class="hit">    shape = property(Sequence._getshape, _setshape)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ModelIOSequence(IOSequence):
</span><span class="noop">
</span><span class="hit">    def _getrawfilename(self):
</span><span class="noop">        &#34;&#34;&#34;Filename without ending for external and internal date files.&#34;&#34;&#34;
</span><span class="miss">        if self._rawfilename:
</span><span class="miss">            return self._rawfilename
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return &#39;%s_%s_%s&#39; % (
</span><span class="noop">                       self.subseqs.seqs.model.element.name,
</span><span class="noop">                       objecttools.classname(self.subseqs)[:-9].lower(),
</span><span class="noop">                       self.name)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the raw filename cannot &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="hit">    def _setrawfilename(self, name):
</span><span class="miss">        self._rawfilename = str(name)
</span><span class="hit">    def _delrawfilename(self):
</span><span class="miss">        self._rawfilename = None
</span><span class="hit">    rawfilename = property(_getrawfilename, _setrawfilename, _delrawfilename)
</span><span class="noop">
</span><span class="hit">class InputSequence(ModelIOSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">class FluxSequence(ModelIOSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">class ConditionSequence(object):
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="hit">        self.values = args
</span><span class="hit">        self.trim()
</span><span class="hit">        self._oldargs = copy.deepcopy(args)
</span><span class="noop">    
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="hit">        objecttools.trim(self, lower, upper)
</span><span class="noop">        
</span><span class="hit">    def warntrim(self):
</span><span class="miss">        warnings.warn(&#39;For sequence %s of element %s at least one value &#39;
</span><span class="noop">                      &#39;needed to be trimmed.  One possible reason could be &#39;
</span><span class="noop">                      &#39;that the related control parameter and initial &#39;
</span><span class="noop">                      &#39;condition files are inconsistent.&#39;
</span><span class="noop">                      % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        if self._oldargs:
</span><span class="miss">            self(*self._oldargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequence(ModelIOSequence, ConditionSequence):
</span><span class="noop">    &#34;&#34;&#34;Handler for state time series.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        ModelIOSequence.__init__(self)
</span><span class="hit">        self.fastaccess_old = None
</span><span class="hit">        self.fastaccess_new = None
</span><span class="hit">        self._oldargs = None
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Sequence` instances
</span><span class="noop">        within initial condition files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        ConditionSequence.__call__(self, *args)
</span><span class="hit">        self.new2old()
</span><span class="noop">
</span><span class="hit">    def connect2subseqs(self, subseqs):
</span><span class="hit">        ModelIOSequence.connect2subseqs(self, subseqs)
</span><span class="hit">        self.fastaccess_old = subseqs.fastaccess_old
</span><span class="hit">        self.fastaccess_new = subseqs.fastaccess_new
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, None)
</span><span class="noop">        else:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, 0.)
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        ModelIOSequence._setshape(self, shape)
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, self.new.copy())
</span><span class="hit">    shape = property(ModelIOSequence._getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    new = Sequence.values
</span><span class="noop">    &#34;&#34;&#34;Complete access to the state value(s), which will be used in the next
</span><span class="noop">    calculation steps.  Note that :attr:`~StateSequence.new` is a synonym of
</span><span class="noop">    :attr:`~StateSequence.value`.  Use this property to modify the initial
</span><span class="noop">    condition(s) of a single :class:`StateSequence` object.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def _getold(self):
</span><span class="noop">        &#34;&#34;&#34;Assess to the state value(s) at beginning of the time step, which
</span><span class="noop">        has been processed most recently.  When using :ref:`HydPy` in the
</span><span class="noop">        normal manner.  But it can be helpful for demonstration and debugging
</span><span class="noop">        purposes.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess_old, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            raise RuntimeError(&#39;No value/values of sequence `%s` has/have &#39;
</span><span class="noop">                               &#39;not been defined so far.&#39; % self.name)
</span><span class="noop">        else:
</span><span class="hit">            if self.NDIM:
</span><span class="hit">                value = numpy.asarray(value)
</span><span class="hit">            return value
</span><span class="hit">    def _setold(self, value):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                temp = value[0]
</span><span class="miss">                if len(value) &gt; 1:
</span><span class="miss">                    raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                     &#39;sequence `%s`, which is ambiguous.&#39;
</span><span class="noop">                                     % (len(value)), self.name)
</span><span class="miss">                value = temp
</span><span class="hit">            except (TypeError, IndexError):
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = float(value)
</span><span class="miss">            except (ValueError, TypeError):
</span><span class="miss">                raise TypeError(&#39;When trying to set the value of sequence &#39;
</span><span class="noop">                                &#39;`%s`, it was not possible to convert `%s` &#39;
</span><span class="noop">                                &#39;to float .&#39; % (self.name, value))
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                value = value.value
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = numpy.full(self.shape, value, dtype=float)
</span><span class="miss">            except ValueError:
</span><span class="miss">                raise ValueError(&#39;The values `%s` cannot be converted to a &#39;
</span><span class="noop">                                 &#39;numpy ndarray with shape %s containing &#39;
</span><span class="noop">                                 &#39;entries of type float.&#39;
</span><span class="noop">                                 % (value, self.shape))
</span><span class="hit">        setattr(self.fastaccess_old, self.name, value)
</span><span class="hit">    old = property(_getold, _setold)
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            self.old[:] = self.new[:]
</span><span class="noop">        else:
</span><span class="hit">            self.old = self.new
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequence(Sequence, ConditionSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Sequence.__init__(self)
</span><span class="hit">        self._oldargs = None
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        self.values = args
</span><span class="miss">        self.trim()
</span><span class="miss">        self._oldargs = copy.deepcopy(args)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">class LinkSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34;2&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def setpointer(self, double, idx=0):
</span><span class="hit">        pdouble = pointer.PDouble(double)
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                self.fastaccess.setpointer0d(self.name, pdouble)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                setattr(self.fastaccess, self.name, pdouble)
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                self.fastaccess.setpointer1d(self.name, pdouble, idx)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                ppdouble = getattr(self.fastaccess, self.name)
</span><span class="hit">                ppdouble.setpointer(double, idx)
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                setattr(self.fastaccess, self.name, None)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                setattr(self.fastaccess, self.name, pointer.PPDouble())
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="noop">
</span><span class="noop">#    def _getvalue(self):
</span><span class="noop">#        &#34;&#34;&#34;Actual value(s) handled by the sequence.  For consistency,
</span><span class="noop">#        `value` and `values` can always be used interchangeably.&#34;&#34;&#34;
</span><span class="noop">#        try:
</span><span class="noop">#            return getattr(self.fastaccess, self.name)
</span><span class="noop">#        except AttributeError:
</span><span class="noop">#            if self.NDIM == 0:
</span><span class="noop">#                return self.fastaccess.getpointer0d(self.name)
</span><span class="noop">#            elif self.NDIM == 1:
</span><span class="noop">#                return self.fastaccess.getpointer1d(self.name)
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;ToDo&#34;&#34;&#34;
</span><span class="miss">        raise NotImplementedError(&#39;To retrieve a pointer is very likely to &#39;
</span><span class="noop">                                  &#39;result in bugs and is thus not supported &#39;
</span><span class="noop">                                  &#39;at the moment.&#39;)
</span><span class="hit">    def _setvalue(self, value):
</span><span class="noop">        &#34;&#34;&#34;Could be implemented, but is not important at the moment...&#34;&#34;&#34;
</span><span class="miss">        raise NotImplementedError(&#39;To change a pointer is very likely to &#39;
</span><span class="noop">                                  &#39;result in bugs and is thus not supported &#39;
</span><span class="noop">                                  &#39;at the moment.&#39;)
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="miss">            return ()
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                return getattr(self.fastaccess, self.name).shape
</span><span class="miss">            except AttributeError:
</span><span class="miss">                return (getattr(self.fastaccess, &#39;_%s_length_0&#39; % self.name), )
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        if self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                getattr(self.fastaccess, self.name).shape = shape
</span><span class="hit">            except AttributeError:
</span><span class="hit">                self.fastaccess.dealloc()
</span><span class="hit">                self.fastaccess.alloc(self.name, shape)
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NodeSequence(IOSequence):
</span><span class="noop">
</span><span class="hit">    def _getrawfilename(self):
</span><span class="noop">        &#34;&#34;&#34;Filename without ending for external and internal date files.&#34;&#34;&#34;
</span><span class="miss">        if self._rawfilename:
</span><span class="miss">            return self._rawfilename
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return &#39;%s_%s_%s&#39; % (
</span><span class="noop">                       self.subseqs.node.name,
</span><span class="noop">                       self.name,
</span><span class="noop">                       self.subseqs.node.variable.lower())
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the raw filename cannot &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="hit">    def _setrawfilename(self, name):
</span><span class="miss">        self._rawfilename = str(name)
</span><span class="hit">    def _delrawfilename(self):
</span><span class="miss">        self._rawfilename = None
</span><span class="hit">    rawfilename = property(_getrawfilename, _setrawfilename, _delrawfilename)
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        setattr(self.fastaccess, self.name, pointer.Double(0.))
</span><span class="noop">
</span><span class="hit">    def _getvalues(self):
</span><span class="noop">        &#34;&#34;&#34;Actual value(s) handled by the sequence.  For consistency,
</span><span class="noop">        `value` and `values` can always be used interchangeably.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return getattr(self.fastaccess, self.name)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            if self.NDIM == 0:
</span><span class="miss">                return self.fastaccess.getpointer0d(self.name)
</span><span class="miss">            elif self.NDIM == 1:
</span><span class="miss">                return self.fastaccess.getpointer1d(self.name)
</span><span class="hit">    def _setvalues(self, values):
</span><span class="hit">        getattr(self.fastaccess, self.name)[0] = values
</span><span class="hit">    values = property(_getvalues, _setvalues)
</span><span class="hit">    value = values
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sim(NodeSequence):
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        NodeSequence.__init__(self)
</span><span class="hit">        self.use_ext = False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Obs(NodeSequence):
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        NodeSequence.__init__(self)
</span><span class="hit">        self.use_ext = True
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_disk(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.diskflag = False
</span><span class="miss">            warnings.warn(&#39;The option `diskflag` of the observation &#39;
</span><span class="noop">                          &#39;sequence had to be set to `False` due to the &#39;
</span><span class="noop">                          &#39;following problem: %s.&#39; % message)
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_ram(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message= sys.exc_info()[1]
</span><span class="miss">            self.ramflag = False
</span><span class="miss">            warnings.warn(&#39;The option `ramflag` of the simulation &#39;
</span><span class="noop">                          &#39;sequence had to be set to `False` due to the &#39;
</span><span class="noop">                          &#39;following problem: %s.&#39; % message)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def series_complete(self):
</span><span class="miss">        return self.memoryflag and not numpy.any(numpy.isnan(self.series))
</span><span class="noop">
</span><span class="hit">class NodeSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling node sequences.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _SEQCLASSES = (Sim, Obs)
</span><span class="noop">
</span><span class="hit">    def __init__(self, seqs, cls_fastaccess=None):
</span><span class="hit">        IOSubSequences.__init__(self, seqs, cls_fastaccess)
</span><span class="hit">        self.node = seqs
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="miss">        self.fastaccess.loaddata(idx)
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="miss">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FastAccess(object):
</span><span class="noop">    &#34;&#34;&#34;Provides fast access to the values of the sequences of a sequence
</span><span class="noop">    subgroup and supports the handling of internal data series during
</span><span class="noop">    simulations.
</span><span class="noop">
</span><span class="noop">    The following details are of relevance for :ref:`HydPy` developers only.
</span><span class="noop">
</span><span class="noop">    :class:`FastAccess` is applied in Python mode only.  In Cython mode,
</span><span class="noop">    specialized and more efficient cdef classes replace it.  For
</span><span class="noop">    compatibility with these cdef classes, :class:`FastAccess` objects
</span><span class="noop">    work with dynamically set instance members.  Suppose there is a
</span><span class="noop">    sequence named `seq1` which is 2-dimensional, then its associated
</span><span class="noop">    attributes are:
</span><span class="noop">
</span><span class="noop">      * seq1 (:class:`~numpy.ndarray`): The actual sequence values.
</span><span class="noop">      * _seq1_ndim (:class:`int`): Number of dimensions.
</span><span class="noop">      * _seq1_length_0 (:class:`int`): Length in the first dimension.
</span><span class="noop">      * _seq1_length_1 (:class:`int`): Length in the second dimension.
</span><span class="noop">      * _seq1_ramflag (:class:`bool`): Handle internal data in RAM?
</span><span class="noop">      * _seq1_diskflag (:class:`bool`): Handle internal data on disk?
</span><span class="noop">      * _seq1_path (:class:`str`): Path of the internal data file.
</span><span class="noop">      * _seq1_file (:class:`file`): Object handling the internal data file.
</span><span class="noop">
</span><span class="noop">    Note that all these dynamical attributes and the following methods are
</span><span class="noop">    initialised, changed or applied by the respective :class:`SubSequences`
</span><span class="noop">    and :class:`Sequence` objects.  Handling them directly is error prone
</span><span class="noop">    and thus not recommended.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Open all files with an activated disk flag.&#34;&#34;&#34;
</span><span class="miss">        for name in self:
</span><span class="miss">            if getattr(self, &#39;_%s_diskflag&#39; % name):
</span><span class="miss">                path = getattr(self, &#39;_%s_path&#39; % name)
</span><span class="miss">                file_ = open(path, &#39;rb+&#39;)
</span><span class="miss">                ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="miss">                position = 8*idx
</span><span class="miss">                for idim in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%d&#39; % (name, idim))
</span><span class="miss">                    position *= length
</span><span class="miss">                file_.seek(position)
</span><span class="miss">                setattr(self, &#39;_%s_file&#39; % name, file_)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="noop">        &#34;&#34;&#34;Close all files with an activated disk flag.&#34;&#34;&#34;
</span><span class="miss">        for name in self:
</span><span class="miss">            if getattr(self, &#39;_%s_diskflag&#39; % name):
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                file_.close()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Load the internal data of all sequences.  Load from file if the
</span><span class="noop">        corresponding disk flag is activated, otherwise load from RAM.&#34;&#34;&#34;
</span><span class="miss">        for name in self:
</span><span class="miss">            ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="miss">            diskflag = getattr(self, &#39;_%s_diskflag&#39; % name)
</span><span class="miss">            ramflag = getattr(self, &#39;_%s_ramflag&#39; % name)
</span><span class="miss">            if diskflag:
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                length_tot = 1
</span><span class="miss">                shape = []
</span><span class="miss">                for idx in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%s&#39; % (name, idx))
</span><span class="miss">                    length_tot *= length
</span><span class="miss">                    shape.append(length)
</span><span class="miss">                raw = file_.read(length_tot*8)
</span><span class="miss">                values = struct.unpack(length_tot*&#39;d&#39;, raw)
</span><span class="miss">                if ndim:
</span><span class="miss">                    values = numpy.array(values).reshape(shape)
</span><span class="noop">                else:
</span><span class="miss">                    values = values[0]
</span><span class="miss">            elif ramflag:
</span><span class="miss">                array = getattr(self, &#39;_%s_array&#39; % name)
</span><span class="miss">                values = array[idx]
</span><span class="miss">            if (diskflag or ramflag):
</span><span class="miss">                if ndim == 0:
</span><span class="miss">                    setattr(self, name, values)
</span><span class="noop">                else:
</span><span class="miss">                    getattr(self, name)[:] = values
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Save the internal data of all sequences with an activated flag.
</span><span class="noop">        Write to file if the corresponding disk flag is activated; store
</span><span class="noop">        in working memory if the corresponding ram flag is activated.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            actual = getattr(self, name)
</span><span class="hit">            diskflag = getattr(self, &#39;_%s_diskflag&#39; % name)
</span><span class="hit">            ramflag = getattr(self, &#39;_%s_ramflag&#39; % name)
</span><span class="hit">            if diskflag:
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="miss">                length_tot = 1
</span><span class="miss">                for idx in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%s&#39; % (name, idx))
</span><span class="miss">                    length_tot *= length
</span><span class="miss">                if ndim:
</span><span class="miss">                    raw = struct.pack(length_tot*&#39;d&#39;, *actual.flatten())
</span><span class="noop">                else:
</span><span class="miss">                    raw = struct.pack(&#39;d&#39;, actual)
</span><span class="miss">                file_.write(raw)
</span><span class="hit">            elif ramflag:
</span><span class="miss">                array = getattr(self, &#39;_%s_array&#39; % name)
</span><span class="miss">                array[idx] = actual
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="noop">        &#34;&#34;&#34;Iterate over all sequence names.&#34;&#34;&#34;
</span><span class="hit">        for key in vars(self).keys():
</span><span class="hit">            if not key.startswith(&#39;_&#39;):
</span><span class="hit">                yield key
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="hit">&#34;&#34;&#34;This module specifies how  dates and periods are handled in HydPy.
</span><span class="noop">
</span><span class="noop">The following classes are implemented:
</span><span class="noop">    * :class:`Date`: Defines a single time point.
</span><span class="noop">    * :class:`Period`: Defines a single time duration.
</span><span class="noop">    * :class:`Timegrid`: Defines an equidistant sequence of time points.
</span><span class="noop">    * :class:`Timegrids`: Handles all :class:`Timegrid` instances of a
</span><span class="noop">      HydPy project.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Date and Period
</span><span class="noop">===============
</span><span class="noop">
</span><span class="noop">Both classes :class:`Date` and :class:`Period` are build on top of the Python
</span><span class="noop">module :mod:`datetime`. In essence, they wrap the :mod:`datetime` classes
</span><span class="noop">:class:`~datetime.datetime` and :class:`~datetime.timedelta`, and are supposed
</span><span class="noop">to specialise these general classes on the needs of HydPy users.
</span><span class="noop">
</span><span class="noop">Be aware of the different minimum time resolution of module :mod:`datetime`
</span><span class="noop">(microseconds) and module :mod:`~hydpy.core.timetools` (seconds).
</span><span class="noop">
</span><span class="noop">:class:`Date` objects can be initialized via :class:`~datetime.datetime`
</span><span class="noop">objects directly, e.g.::
</span><span class="noop">
</span><span class="noop">    from datetime import datetime
</span><span class="noop">    from hydpy.core.timetools import Date
</span><span class="noop">
</span><span class="noop">    # Initialize a `datetime` object...
</span><span class="noop">    datetime_object = datetime(1996, 11, 1, 0, 0, 0)
</span><span class="noop">    # ...and use it to initialise a `Date` object.
</span><span class="noop">    date1 = Date(datetime_object)
</span><span class="noop">
</span><span class="noop">Alternatively, one can use :class:`str` objects as initialization arguments,
</span><span class="noop">which need to match one of the following format styles::
</span><span class="noop">
</span><span class="noop">    # The `os` style without empty space and colon, which is applied in
</span><span class="noop">    # text files and folder names:
</span><span class="noop">    date2 = Date(&#39;1997_11_01_00_00_00&#39;)
</span><span class="noop">    # The `iso` style, which is more legible and in accordance with the
</span><span class="noop">    # international ISO norm:
</span><span class="noop">    date2 = Date(&#39;1997.11.01 00:00:00&#39;)
</span><span class="noop">    # The `din` style, which is more legible for users in countries where the
</span><span class="noop">    # position of day and year are interchanged (DIN refers to a german norm):
</span><span class="noop">    date2 = Date(&#39;01.11.1997 00:00:00&#39;)
</span><span class="noop">
</span><span class="noop">:class:`Date` keeps the chosen style in mind and uses it for printing.  But
</span><span class="noop">the user is also allowed to change it::
</span><span class="noop">
</span><span class="noop">    # Print in accordance with the `iso` style...
</span><span class="noop">    print(date2.string(&#39;iso&#39;))
</span><span class="noop">    # ...without changing the memorized `din` style:
</span><span class="noop">    print(date2.style)
</span><span class="noop">    # Alternatively, the style property can be set permanentely:
</span><span class="noop">    date2.style = &#39;iso&#39;
</span><span class="noop">    print(date2)
</span><span class="noop">
</span><span class="noop">It is allowed to abbreviate the input strings. Using the `iso` style as an
</span><span class="noop">example::
</span><span class="noop">
</span><span class="noop">    # The following three input arguments...
</span><span class="noop">    test1 = Date(&#39;1996.11.01 00:00:00&#39;)
</span><span class="noop">    test2 = Date(&#39;1996.11.01 00:00&#39;)
</span><span class="noop">    test3 = Date(&#39;1996.11.01 00&#39;)
</span><span class="noop">    test4 = Date(&#39;1996.11.01&#39;)
</span><span class="noop">    # ...all lead to identical `Date` instances.
</span><span class="noop">    print(test1, test2, test3, test4)
</span><span class="noop">
</span><span class="noop">If :class:`Date` has not been initialized via a :class:`str` object and the
</span><span class="noop">style property has not been set manually, the default style `iso` is selected.
</span><span class="noop">
</span><span class="noop">One can change the year, month... of a :class:`Date` object via numbers::
</span><span class="noop">
</span><span class="noop">    # Assign an integer...
</span><span class="noop">    test4.year = 1997
</span><span class="noop">    # ...or something that can be converted to an integer.
</span><span class="noop">    test4.month = &#39;10&#39;
</span><span class="noop">    print(test4)
</span><span class="noop">
</span><span class="noop">One can ask for the actual water year, which depends on the selected
</span><span class="noop">reference month::
</span><span class="noop">
</span><span class="noop">    oct = Date(&#39;1996.10.01&#39;)
</span><span class="noop">    nov = Date(&#39;1996.11.01&#39;)
</span><span class="noop">    # Under the standard settings, the water year is assumed to start November.
</span><span class="noop">    print(oct.wateryear, nov.wateryear)
</span><span class="noop">    # Changing the reference month via one `Date` object affects all objects.
</span><span class="noop">    test4.refmonth = 10
</span><span class="noop">    print(oct.wateryear, nov.wateryear)
</span><span class="noop">    test4.refmonth = &#39;November&#39;
</span><span class="noop">    print(oct.wateryear, nov.wateryear)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">:class:`Period` objects can be directly initialized via
</span><span class="noop">:class:`~datetime.timedelta` objects, e.g.::
</span><span class="noop">
</span><span class="noop">    from datetime import timedelta
</span><span class="noop">    from hydpy.core.timetools import Period
</span><span class="noop">
</span><span class="noop">    # Initialize a `timedelta` object...
</span><span class="noop">    timedelta_object = timedelta(1, 0)
</span><span class="noop">    # ...and use it to initialise a `Period` object
</span><span class="noop">    period = Period(timedelta_object)
</span><span class="noop">
</span><span class="noop">Alternatively, one can initialize from :class:`str` objects.  These must
</span><span class="noop">consist of some characters defining an integer value directly followed by
</span><span class="noop">a single character defining the unit::
</span><span class="noop">
</span><span class="noop">    # 30 seconds:
</span><span class="noop">    period = Period(&#39;30s&#39;)
</span><span class="noop">    # 5 minutes:
</span><span class="noop">    period = Period(&#39;5m&#39;)
</span><span class="noop">    # 6 hours:
</span><span class="noop">    period = Period(&#39;6h&#39;)
</span><span class="noop">    # 1 day:
</span><span class="noop">    period = Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">:class:`Period` always determines the unit leading to the most legigible
</span><span class="noop">print out::
</span><span class="noop">
</span><span class="noop">    # Print using the unit leading to the smallest integer value:
</span><span class="noop">    print(period)
</span><span class="noop">    # Alternatively, the values of all time units are directly available as
</span><span class="noop">    # `float` objects:
</span><span class="noop">    print(period.days)
</span><span class="noop">    print(period.hours)
</span><span class="noop">    print(period.minutes)
</span><span class="noop">    print(period.seconds)
</span><span class="noop">
</span><span class="noop">If considered useful, logic and arithmetic operations are supported.
</span><span class="noop">Some examples::
</span><span class="noop">
</span><span class="noop">    # Determine the period length between two dates.
</span><span class="noop">    wholeperiod = date2 - date1
</span><span class="noop">    print(wholeperiod)
</span><span class="noop">    # Determine, how often one period fits into the other.
</span><span class="noop">    print(wholeperiod / period)
</span><span class="noop">    # Get one sixths of period:
</span><span class="noop">    print(period / 6)
</span><span class="noop">    # But when trying to get one seventh of period:
</span><span class="noop">    print(period / 7)
</span><span class="noop">    # Double a period duration.
</span><span class="noop">    period *= 2
</span><span class="noop">    print(period)
</span><span class="noop">    # Shift a date.
</span><span class="noop">    date1 -= period
</span><span class="noop">    # Note that the modulo operator returns a boolean value, indicating
</span><span class="noop">    # whether the remainder is zero or not:
</span><span class="noop">    # print(Period(&#39;1d&#39;) % Period(&#39;12h&#39;))
</span><span class="noop">    # print(Period(&#39;1d&#39;) % Period(&#39;13h&#39;))
</span><span class="noop">    # Following the same line of thinking, floor division leads to the
</span><span class="noop">    # opposite results:
</span><span class="noop">    # print(Period(&#39;1d&#39;) // Period(&#39;12h&#39;))
</span><span class="noop">    # print(Period(&#39;1d&#39;) // Period(&#39;13h&#39;))
</span><span class="noop">    # Compare dates or periods.
</span><span class="noop">    print(date1 &lt; date2)
</span><span class="noop">    print(min(date1, date2))
</span><span class="noop">    print(period == wholeperiod)
</span><span class="noop">    # Operations on initialisation arguments are supported.
</span><span class="noop">    print(date1 + &#39;5m&#39;)
</span><span class="noop">    print(period != &#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">Note that :class:`Date` and :class:`Period` objects are mutable.  Use their
</span><span class="noop">`copy` methods whenever this might lead to unintentional results::
</span><span class="noop">
</span><span class="noop">    # A date example:
</span><span class="noop">    date1 = Date(&#39;1996.11.01 00:00&#39;)
</span><span class="noop">    date2 = date1
</span><span class="noop">    date3 = date1.copy()
</span><span class="noop">    date1.year = 1997
</span><span class="noop">    print(date1, date2, date3)
</span><span class="noop">    # A period example:
</span><span class="noop">    period1 = Period(&#39;1h&#39;)
</span><span class="noop">    period2 = period1
</span><span class="noop">    period3 = period1.copy()
</span><span class="noop">    period1 -= &#39;2h&#39;
</span><span class="noop">    print(period1, period2, period3)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Timegrid and Timegrids
</span><span class="noop">======================
</span><span class="noop">
</span><span class="noop">In hydrological modelling, input (and output) data are usually only available
</span><span class="noop">with a certain resolution, which also determines the possible resolution
</span><span class="noop">of the actual simulation.  This is reflected by the class :class:`Timegrid`,
</span><span class="noop">which represents the first and the last date of e.g. a simulation period as
</span><span class="noop">well as the intermediate dates. A :class:`Timegrid` object is initialized
</span><span class="noop">by defining its first date, its last date and its stepsize::
</span><span class="noop">
</span><span class="noop">    from hydpy.core.timetools import Date, Period, Timegrid
</span><span class="noop">
</span><span class="noop">    # Either pass the proper attributes directly...
</span><span class="noop">    firstdate = Date(&#39;1996.11.01&#39;)
</span><span class="noop">    lastdate = Date(&#39;1997.11.01&#39;)
</span><span class="noop">    stepsize = Period(&#39;1d&#39;)
</span><span class="noop">    timegrid_sim = Timegrid(firstdate, lastdate, stepsize)
</span><span class="noop">    # ...or pass their initialization arguments:
</span><span class="noop">    timegrid_sim = Timegrid(&#39;1996.11.01&#39;, &#39;1997.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">:class:`Timegrid` provides functionalities to ease and secure the handling
</span><span class="noop">of dates in HydPy. Here some examples::
</span><span class="noop">
</span><span class="noop">    # Retrieve a date via indexing, e.g. the second one:
</span><span class="noop">    date = timegrid_sim[1]
</span><span class="noop">    print(date)
</span><span class="noop">    # Or the other way round, retrieve the index belonging to a date:
</span><span class="noop">    print(timegrid_sim[date])
</span><span class="noop">    # Indexing beyond the ranges of the actual time period is allowed:
</span><span class="noop">    print(timegrid_sim[-366])
</span><span class="noop">    print(timegrid_sim[timegrid_sim[date+&#39;365d&#39;]])
</span><span class="noop">    # Iterate through all time grid points (e.g. to print the first day of
</span><span class="noop">    # each month):
</span><span class="noop">    for date in timegrid_sim:
</span><span class="noop">        if date.day == 1:
</span><span class="noop">            print date
</span><span class="noop">
</span><span class="noop">After doing some changes one should call the :func:`~Timegrid.verify` method::
</span><span class="noop">
</span><span class="noop">    # `verify` keeps silent if everything seems to be alright...
</span><span class="noop">    timegrid_sim.verify()
</span><span class="noop">    # ...but raises an suitable exception otherwise:
</span><span class="noop">    timegrid_sim.firstdate.minute = 30
</span><span class="noop">    timegrid_sim.verify()
</span><span class="noop">
</span><span class="noop">One can check two :class:`Timegrid` instances for equality::
</span><span class="noop">
</span><span class="noop">    # Make a deep copy of the timegrid already existing.
</span><span class="noop">    timegrid_test = timegrid_sim.copy()
</span><span class="noop">    # Test for equality and non-equality.
</span><span class="noop">    print(timegrid_sim == timegrid_test)
</span><span class="noop">    print(timegrid_sim != timegrid_test)
</span><span class="noop">    # Modify one date of the new timegrid.
</span><span class="noop">    timegrid_test.firstdate += &#39;1d&#39;
</span><span class="noop">    # Again, test for equality and non-equality.
</span><span class="noop">    print(timegrid_sim == timegrid_test)
</span><span class="noop">    print(timegrid_sim != timegrid_test)
</span><span class="noop">
</span><span class="noop">Also, one can check if a date or even whole timegrid lies within a span
</span><span class="noop">defined by a :class:`Timegrid` instance::
</span><span class="noop">
</span><span class="noop">    # Define a long timegrid...
</span><span class="noop">    timegrid_long = Timegrid(&#39;1996.11.01&#39;, &#39;2006.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">    # ...and check different dates for lying in the defined time period:
</span><span class="noop">    print(&#39;1996.10.31&#39; in timegrid_long)
</span><span class="noop">    print(&#39;1996.11.01&#39; in timegrid_long)
</span><span class="noop">    print(&#39;1996.11.02&#39; in timegrid_long)
</span><span class="noop">    # For dates not alligned on the grid `False` is returned:
</span><span class="noop">    print(&#39;1996.11.01 12:00&#39; in timegrid_long)
</span><span class="noop">
</span><span class="noop">    # Now define a timegrid containing only the first year of the long one:
</span><span class="noop">    timegrid_short = Timegrid(&#39;1996.11.01&#39;, &#39;1997.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">    # Check which timegrid is contained by the other:
</span><span class="noop">    print(timegrid_short in timegrid_long)
</span><span class="noop">    print(timegrid_long in timegrid_short)
</span><span class="noop">    # For timegrids with different stepsizes `False` is returned:
</span><span class="noop">    timegrid_short.stepsize = Period(&#39;1h&#39;)
</span><span class="noop">    print(timegrid_short in timegrid_long)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">The HydPy framework distinguishes three `time frames`, one associated with the
</span><span class="noop">input date available on disk (`data`), one associated, with the initialisation
</span><span class="noop">period (`init`) and and one associated with the actual simulation period
</span><span class="noop">(`sim`).  Each time frame is represented by a single :class:`Timegrid` object
</span><span class="noop">and all together are handled by one class :class:`Timegrids` object.
</span><span class="noop">
</span><span class="noop">There is usually only one :class:`Timegrids` object required within each
</span><span class="noop">HydPy project.  It is automatically added to the module
</span><span class="noop">:mod:`~hydpy.core.pub` during the initialization of a
</span><span class="noop">:class:`~hydpy.core.hydpy.HydPy` object::
</span><span class="noop">
</span><span class="noop">    from hydpy import HydPy
</span><span class="noop">    from hydpy.core import pub
</span><span class="noop">
</span><span class="noop">    hydpy = HydPy(&#39;tutorial_1&#39;)
</span><span class="noop">    print(pub.timegrids)
</span><span class="noop">
</span><span class="noop">Some examples on the usage of this :class:`Timegrids` instance::
</span><span class="noop">
</span><span class="noop">    # Get the factor to convert `mm/stepsize` to m^3/s for an area of 36 km^2:
</span><span class="noop">    print(pub.timegrids.qfactor(36.))
</span><span class="noop">    # Get the index of the first values of the `data time frame` which belong
</span><span class="noop">    # to the `initialisation time frame`.
</span><span class="noop">    print(pub.timegrids.data[pub.timegrids.init.firstdate])
</span><span class="noop">    # Or, as a similar example, get the index of the first values of the
</span><span class="noop">    # `initialisation time frame` which belong to the `simulation time frame`.
</span><span class="noop">    print(pub.timegrids.init[pub.timegrids.sim.firstdate])
</span><span class="noop">
</span><span class="noop">Notice, that the latter index is zero.  This is due to the simulation time
</span><span class="noop">frame beeing identical with the initialisation time frame, if not specified
</span><span class="noop">otherwise in the main control file or by manually changing the simulation time
</span><span class="noop">frame.
</span><span class="noop">
</span><span class="noop">Each manual change should be followed by calling the
</span><span class="noop">:func:`~Timegrids.verify` method, which calls the :func:`~Timegrid.verify`
</span><span class="noop">method of the single :class:`Timegrid` instances and performs some additional
</span><span class="noop">tests::
</span><span class="noop">
</span><span class="noop">    # Postponing the `simulation time frame` one stepsize is fine...
</span><span class="noop">    pub.timegrids.sim.firstdate += pub.timegrids.stepsize
</span><span class="noop">    pub.timegrids.verify()
</span><span class="noop">    # ...but shifting it outside the `initialisation time frame` or setting
</span><span class="noop">    # it in  between the time grid points results in an error:
</span><span class="noop">    pub.timegrids.sim.firstdate -= 2*pub.timegrids.stepsize
</span><span class="noop">    pub.timegrids.verify()
</span><span class="noop">    pub.timegrids.sim.firstdate += pub.timegrids.stepsize
</span><span class="noop">    pub.timegrids.sim.firstdate.minute = 1
</span><span class="noop">    pub.timegrids.verify()
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">To facilitate printing to configuration files, both classes :class:`Timegrid`
</span><span class="noop">and :class:`Timegrids` allow for a extended canonical string representations
</span><span class="noop">of their objects::
</span><span class="noop">
</span><span class="noop">    # The string representation is generally formated with indentation.
</span><span class="noop">    print(repr(pub.timegrids.data))
</span><span class="noop">    print(repr(pub.timegrids))
</span><span class="noop">    # The class specific `assignrepr` methods allow for inserting assignements.
</span><span class="noop">    print(pub.timegrids.data.assignrepr(&#39;timegrid_data = &#39;))
</span><span class="noop">    print(pub.timegrids.assignrepr(&#39;timegrids_all = &#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Details
</span><span class="noop">=======
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import datetime
</span><span class="hit">import copy
</span><span class="hit">import time
</span><span class="noop"># ...from third party packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop"># The import of `_strptime` is not thread save.  The following call of
</span><span class="noop"># `strptime` is supposed to prevent possible problems arising from this bug.
</span><span class="hit">time.strptime(&#39;1999&#39;, &#39;%Y&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Date(object):
</span><span class="noop">    &#34;&#34;&#34;Handles a single date.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">        * date (:class:`~datetime.datetime` or :class:`str`): Initialization
</span><span class="noop">          date.
</span><span class="noop">
</span><span class="noop">    Attribute:
</span><span class="noop">        * datetime (:class:`~datetime.datetime`): The core of :class:`Date`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # These are the so far accepted date format strings.
</span><span class="hit">    _formatstrings = {&#39;os&#39;: &#39;%Y_%m_%d_%H_%M_%S&#39;,
</span><span class="noop">                      &#39;iso&#39;: &#39;%Y.%m.%d %H:%M:%S&#39;,
</span><span class="noop">                      &#39;din&#39;: &#39;%d.%m.%Y %H:%M:%S&#39;}
</span><span class="noop">    # The first month of the hydrological year (e.g. November in Germany)
</span><span class="hit">    _firstmonth_wateryear = 11
</span><span class="noop">
</span><span class="hit">    def __init__(self, date):
</span><span class="hit">        self.datetime = None
</span><span class="hit">        self._style = None
</span><span class="hit">        if isinstance(date, Date):
</span><span class="hit">            self.datetime = date.datetime
</span><span class="hit">        elif isinstance(date, datetime.datetime):
</span><span class="hit">            if date.microsecond:
</span><span class="miss">                raise ValueError(&#39;For `Date` instances, the microsecond must &#39;
</span><span class="noop">                                 &#39;be `0`.  For the given `datetime` object, &#39;
</span><span class="noop">                                 &#39;it is `%d` instead.&#39; % date.microsecond)
</span><span class="hit">            self.datetime = date
</span><span class="hit">        elif isinstance(date, str):
</span><span class="hit">            self._initfromstr(date)
</span><span class="noop">        else:
</span><span class="hit">            raise TypeError(&#39;The supplied argument must be either an &#39;
</span><span class="noop">                            &#39;instance of `datetime.datetime` or of `str`.  &#39;
</span><span class="noop">                            &#39;The given arguments type is %s.&#39; % type(date))
</span><span class="noop">
</span><span class="hit">    def _initfromstr(self, date):
</span><span class="noop">        &#34;&#34;&#34;Try to initialize `datetime` from the given :class:`str` instance.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * date (:class:`str`): Initialization date.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for (style, string) in self._formatstrings.items():
</span><span class="hit">            for idx in range(4):
</span><span class="hit">                try:
</span><span class="hit">                    self.datetime = datetime.datetime.strptime(date, string)
</span><span class="hit">                    self._style = style
</span><span class="hit">                except ValueError:
</span><span class="hit">                    string = string[:-3]
</span><span class="hit">        if self.datetime is None:
</span><span class="hit">            raise ValueError(&#39;Date could not be identified out of the given &#39;
</span><span class="noop">                             &#39;string %s.  The available formats are %s.&#39;
</span><span class="noop">                             % (date, self._formatstrings))
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromarray(cls, array):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Date` instance based on date information (year,
</span><span class="noop">        month, day, hour, minute, second) stored as the first entries of the
</span><span class="noop">        successive rows of a :class:`~numpy.ndarray` object.&#34;&#34;&#34;
</span><span class="miss">        intarray = numpy.array(array, dtype=int)
</span><span class="miss">        for idx in range(1, array.ndim):
</span><span class="miss">            intarray = intarray[:,0]
</span><span class="miss">        return cls(datetime.datetime(*intarray))
</span><span class="noop">
</span><span class="hit">    def toarray(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a 1-dimensional :mod:`numpy` :class:`~numpy.ndarray` with
</span><span class="noop">        six entries defining the actual date (year, month, day, hour, minute,
</span><span class="noop">        second).&#34;&#34;&#34;
</span><span class="miss">        return numpy.array([self.year, self.month, self.day, self.hour,
</span><span class="noop">                            self.minute, self.second], dtype=float)
</span><span class="noop">
</span><span class="hit">    def _getrefmonth(self):
</span><span class="noop">        &#34;&#34;&#34;First month of the hydrological year. The default value is 11
</span><span class="noop">        (November which is the german reference month). Setting it e.g. to 10
</span><span class="noop">        (October is another common reference month many different countries)
</span><span class="noop">        affects all :class:`Date` instances.&#34;&#34;&#34;
</span><span class="hit">        return Date._firstmonth_wateryear
</span><span class="hit">    def _setrefmonth(self, value):
</span><span class="hit">        try:
</span><span class="hit">            Date._firstmonth_wateryear = int(value)
</span><span class="hit">        except ValueError:
</span><span class="hit">            string = str(value)[:3].lower()
</span><span class="hit">            try:
</span><span class="hit">                months = [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;, &#39;may&#39;, &#39;jun&#39;,
</span><span class="noop">                          &#39;jul&#39;, &#39;aug&#39;, &#39;sew&#39;, &#39;oct&#39;, &#39;nov&#39;, &#39;dec&#39;]
</span><span class="hit">                Date._firstmonth_wateryear = months.index(string) + 1
</span><span class="hit">            except ValueError:
</span><span class="hit">                raise ValueError(&#39;The given value `%s` cannot be interpreted &#39;
</span><span class="noop">                                 &#39;as a month. Supply e.g. a number between 1 &#39;
</span><span class="noop">                                 &#39;and 12 or a month name instead.&#39; % value)
</span><span class="hit">    refmonth = property(_getrefmonth, _setrefmonth)
</span><span class="noop">
</span><span class="hit">    def _getstyle(self):
</span><span class="noop">        &#34;&#34;&#34;Date format style to be applied in printing.&#34;&#34;&#34;
</span><span class="hit">        if self._style is None:
</span><span class="hit">            return &#39;iso&#39;
</span><span class="noop">        else:
</span><span class="hit">            return self._style
</span><span class="hit">    def _setstyle(self, style):
</span><span class="hit">        if style in self._formatstrings:
</span><span class="hit">            self._style = style
</span><span class="noop">        else:
</span><span class="miss">            self._style = None
</span><span class="miss">            raise KeyError(&#39;Date format style `%s` is not available.&#39; % style)
</span><span class="hit">    style = property(_getstyle, _setstyle)
</span><span class="noop">
</span><span class="hit">    def _setthing(self, thing, value):
</span><span class="noop">        &#34;&#34;&#34;Convenience method for `_setyear`, `_setmonth`...&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            value = int(value)
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            raise ValueError(&#39;Changing the %s of a `Date` instance is only &#39;
</span><span class="noop">                             &#39;allowed via numbers, but the given value `%s` &#39;
</span><span class="noop">                             &#39;is of type `%s` instead.&#39;
</span><span class="noop">                             % (thing, value, type(value)))
</span><span class="hit">        kwargs = {}
</span><span class="hit">        for unit in (&#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;):
</span><span class="hit">            kwargs[unit] = getattr(self, unit)
</span><span class="hit">        kwargs[thing] = value
</span><span class="hit">        self.datetime = datetime.datetime(**kwargs)
</span><span class="noop">
</span><span class="hit">    def _getsecond(self):
</span><span class="noop">        &#34;&#34;&#34;The actual second.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.second
</span><span class="hit">    def _setsecond(self, second):
</span><span class="hit">        self._setthing(&#39;second&#39;, second)
</span><span class="hit">    second = property(_getsecond, _setsecond)
</span><span class="noop">
</span><span class="hit">    def _getminute(self):
</span><span class="noop">        &#34;&#34;&#34;The actual minute.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.minute
</span><span class="hit">    def _setminute(self, minute):
</span><span class="hit">        self._setthing(&#39;minute&#39;, minute)
</span><span class="hit">    minute = property(_getminute, _setminute)
</span><span class="noop">
</span><span class="hit">    def _gethour(self):
</span><span class="noop">        &#34;&#34;&#34;The actual hour.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.hour
</span><span class="hit">    def _sethour(self, hour):
</span><span class="hit">        self._setthing(&#39;hour&#39;, hour)
</span><span class="hit">    hour = property(_gethour, _sethour)
</span><span class="noop">
</span><span class="hit">    def _getday(self):
</span><span class="noop">        &#34;&#34;&#34;The actual day.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.day
</span><span class="hit">    def _setday(self, day):
</span><span class="hit">        self._setthing(&#39;day&#39;, day)
</span><span class="hit">    day = property(_getday, _setday)
</span><span class="noop">
</span><span class="hit">    def _getmonth(self):
</span><span class="noop">        &#34;&#34;&#34;The actual month.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.month
</span><span class="hit">    def _setmonth(self, month):
</span><span class="hit">        self._setthing(&#39;month&#39;, month)
</span><span class="hit">    month = property(_getmonth, _setmonth)
</span><span class="noop">
</span><span class="hit">    def _getyear(self):
</span><span class="noop">        &#34;&#34;&#34;The actual year.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.year
</span><span class="hit">    def _setyear(self, year):
</span><span class="hit">        self._setthing(&#39;year&#39;, year)
</span><span class="hit">    year = property(_getyear, _setyear)
</span><span class="noop">
</span><span class="hit">    def _getwateryear(self):
</span><span class="noop">        &#34;&#34;&#34;The actual hydrological year according selected reference month.&#34;&#34;&#34;
</span><span class="hit">        if self.month &lt; self._firstmonth_wateryear:
</span><span class="hit">            return self.year
</span><span class="noop">        else:
</span><span class="hit">            return self.year + 1
</span><span class="hit">    wateryear = property(_getwateryear)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def dayofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Day of year as an integer value.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.timetuple().tm_yday
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def leapyear(self):
</span><span class="noop">        &#34;&#34;&#34;Return whether the actual date falls in a leap year or not.&#34;&#34;&#34;
</span><span class="hit">        year = self.year
</span><span class="hit">        return (((year % 4) == 0) and
</span><span class="noop">                (((year % 100) != 0) or ((year % 400) == 0)))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Date` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        new = Date(self.datetime + Period(other).timedelta)
</span><span class="hit">        new.style = self.style
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.datetime += Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return Period(self.datetime-Date(other).datetime)
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            try:
</span><span class="hit">                new = Date(self.datetime-Period(other).timedelta)
</span><span class="hit">                new.style = self.style
</span><span class="hit">                return new
</span><span class="miss">            except (TypeError, ValueError):
</span><span class="miss">                raise Exception(&#39;Object `%s` of type `%s` can not be &#39;
</span><span class="noop">                                &#39;substracted from a `Date` instance.&#39;
</span><span class="noop">                                % (str(other), type(other)))
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.datetime -= Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.datetime &lt; Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.datetime &lt;= Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.datetime == Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.datetime != Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.datetime &gt; Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.datetime &gt;= Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def string(self, style):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`str` object representing the actual date in
</span><span class="noop">        accordance with the given style.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        retain = self.style
</span><span class="hit">        try:
</span><span class="hit">            self.style = style
</span><span class="hit">            return str(self)
</span><span class="noop">        finally:
</span><span class="hit">            self.style = retain
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return self.datetime.strftime(self._formatstrings[self.style])
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return &#39;Date(&#34;%s&#34;)&#39; % str(self)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Period(object):
</span><span class="noop">    &#34;&#34;&#34;Handles the length of a single time period.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">        * period (:class:`~datetime.timedelta` or :class:`str`): Period length.
</span><span class="noop">
</span><span class="noop">    Attribute:
</span><span class="noop">        * datetime (:class:`~datetime.timedelta`): The core of :class:`Period`.
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, period):
</span><span class="hit">        self.timedelta = None
</span><span class="hit">        self._unit = None
</span><span class="hit">        if isinstance(period, Period):
</span><span class="hit">            self.timedelta = period.timedelta
</span><span class="hit">        elif isinstance(period, datetime.timedelta):
</span><span class="hit">            if period.microseconds:
</span><span class="miss">                raise ValueError(&#39;For `Period` instances, microseconds must &#39;
</span><span class="noop">                                 &#39;`0`.  For the given `timedelta` object, it &#39;
</span><span class="noop">                                 &#39;is `%d` instead.&#39; % period.microseconds)
</span><span class="hit">            self.timedelta = period
</span><span class="hit">        elif isinstance(period, str):
</span><span class="hit">            self._initfromstr(period)
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;The supplied argument must be either an &#39;
</span><span class="noop">                             &#39;instance of `datetime.timedelta` or `str`.  &#39;
</span><span class="noop">                             &#39;The given arguments type is %s.&#39;
</span><span class="noop">                             % str(type(period)))
</span><span class="noop">
</span><span class="hit">    def _initfromstr(self, period):
</span><span class="noop">        &#34;&#34;&#34;Try to initialize `timedelta` from the given :class:`str` instance.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * period (:class:`str`): Period length.
</span><span class="noop">         &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            number = int(period[:-1])
</span><span class="miss">        except ValueError:
</span><span class="miss">            raise ValueError(&#39;All characters of the given period string, &#39;
</span><span class="noop">                             &#39;except the last one which represents the unit, &#39;
</span><span class="noop">                             &#39;need to define a whole decimal number.  Instead,&#39;
</span><span class="noop">                             &#39; these characters are `%s`.&#39; % period[:-1])
</span><span class="hit">        self._unit = period[-1]
</span><span class="hit">        if self._unit not in (&#39;d&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;):
</span><span class="miss">            raise ValueError(&#39;The last character of the given period string &#39;
</span><span class="noop">                             &#39;needs to be either `d` (days), `h` (hours) or &#39;
</span><span class="noop">                             &#39;`m` (minutes).  Instead, the last character is &#39;
</span><span class="noop">                             &#39;`%s`.&#39; % self._unit)
</span><span class="hit">        if self._unit == &#39;d&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(number, 0)
</span><span class="hit">        elif self._unit == &#39;h&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number*3600)
</span><span class="hit">        elif self._unit == &#39;m&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number*60)
</span><span class="hit">        elif self._unit == &#39;s&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromseconds(cls, seconds):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Period` instance based on a given number of
</span><span class="noop">        seconds.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            seconds = int(seconds)
</span><span class="miss">        except TypeError:
</span><span class="miss">            seconds = int(seconds.flatten()[0])
</span><span class="miss">        return cls(datetime.timedelta(0, int(seconds)))
</span><span class="noop">
</span><span class="hit">    def _guessunit(self):
</span><span class="noop">        &#34;&#34;&#34;Guess the unit of the period as the largest one, which results in
</span><span class="noop">        an integer duration.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if not self.days % 1:
</span><span class="hit">            return &#39;d&#39;
</span><span class="hit">        elif not self.hours % 1:
</span><span class="hit">            return &#39;h&#39;
</span><span class="hit">        elif not self.minutes % 1:
</span><span class="hit">            return &#39;m&#39;
</span><span class="hit">        elif not self.seconds % 1:
</span><span class="hit">            return &#39;s&#39;
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;The stepsize is not a multiple of one &#39;
</span><span class="noop">                             &#39;second, which is not allowed.&#39;)
</span><span class="hit">    unit = property(_guessunit)
</span><span class="noop">
</span><span class="hit">    def _getseconds(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in seconds.&#34;&#34;&#34;
</span><span class="hit">        return self.timedelta.total_seconds()
</span><span class="hit">    seconds = property(_getseconds)
</span><span class="noop">
</span><span class="hit">    def _getminutes(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in minutes.&#34;&#34;&#34;
</span><span class="hit">        return self.seconds / 60
</span><span class="hit">    minutes = property(_getminutes)
</span><span class="noop">
</span><span class="hit">    def _gethours(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in hours.&#34;&#34;&#34;
</span><span class="hit">        return self.minutes / 60
</span><span class="hit">    hours = property(_gethours)
</span><span class="noop">
</span><span class="hit">    def _getdays(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in days.&#34;&#34;&#34;
</span><span class="hit">        return self.hours / 24
</span><span class="hit">    days = property(_getdays)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Period` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            new = Date(Date(other).datetime + self.timedelta)
</span><span class="hit">            new.style = other.style
</span><span class="hit">            return new
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            try:
</span><span class="hit">                return Period(self.timedelta + Period(other).timedelta)
</span><span class="miss">            except (TypeError, ValueError):
</span><span class="miss">                raise Exception(&#39;Object `%s` of type `%s` can not be &#39;
</span><span class="noop">                                &#39;added to a `Period` instance.&#39;
</span><span class="noop">                                % (str(other), type(other)))
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.timedelta += Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="miss">        return Period(self.timedelta - Period(other).timedelta)
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.timedelta -= Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __mul__(self, value):
</span><span class="hit">        return Period(self.timedelta * value)
</span><span class="noop">
</span><span class="hit">    def __rmul__(self, value):
</span><span class="hit">        return self * value
</span><span class="noop">
</span><span class="hit">    def __imul__(self, value):
</span><span class="hit">        self.timedelta *= value
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __truediv__(self, other):
</span><span class="hit">        if isinstance(other, int):
</span><span class="hit">            return Period(self.timedelta // other)
</span><span class="noop">        else:
</span><span class="hit">            return self.seconds / Period(other).seconds
</span><span class="noop">
</span><span class="hit">    def __itruediv__(self, value):
</span><span class="hit">        return self / value
</span><span class="noop">
</span><span class="hit">    def __mod__(self, other):
</span><span class="hit">        return (self.seconds % Period(other).seconds) != 0.
</span><span class="noop">
</span><span class="hit">    def __floordiv__(self, other):
</span><span class="hit">        return (self.seconds % Period(other).seconds) == 0.
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.timedelta &lt; Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.timedelta &lt;= Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.timedelta == Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.timedelta != Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.timedelta &gt; Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.timedelta &gt;= Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        if self.unit == &#39;d&#39;:
</span><span class="hit">            return &#39;%dd&#39; % self.days
</span><span class="miss">        elif self.unit == &#39;h&#39;:
</span><span class="miss">            return &#39;%dh&#39; % self.hours
</span><span class="miss">        elif self.unit == &#39;m&#39;:
</span><span class="miss">            return &#39;%dm&#39; % self.minutes
</span><span class="miss">        elif self.unit == &#39;s&#39;:
</span><span class="miss">            return &#39;%ds&#39; % self.seconds
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#39;Period(&#34;%s&#34;)&#39; % str(self)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Timegrid(object):
</span><span class="noop">    &#34;&#34;&#34;Handle a time period defined by to dates and a step size in between.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, firstdate, lastdate, stepsize):
</span><span class="hit">        self._firstdate = None
</span><span class="hit">        self._lastdate = None
</span><span class="hit">        self._stepsize = None
</span><span class="hit">        self.firstdate = firstdate
</span><span class="hit">        self.lastdate = lastdate
</span><span class="hit">        self.stepsize = stepsize
</span><span class="hit">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getfirstdate(self):
</span><span class="hit">        return self._firstdate
</span><span class="hit">    def _setfirstdate(self, firstdate):
</span><span class="hit">        self._firstdate = Date(firstdate)
</span><span class="hit">    firstdate = property(_getfirstdate, _setfirstdate)
</span><span class="noop">
</span><span class="hit">    def _getlastdate(self):
</span><span class="hit">        return self._lastdate
</span><span class="hit">    def _setlastdate(self, lastdate):
</span><span class="hit">        self._lastdate = Date(lastdate)
</span><span class="hit">    lastdate = property(_getlastdate, _setlastdate)
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="hit">        return self._stepsize
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="hit">        self._stepsize = Period(stepsize)
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromarray(cls, array):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Timegrid` instance based on two date and one
</span><span class="noop">        period information stored in the first 13 rows of a
</span><span class="noop">        :class:`~numpy.ndarray` object.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            return cls(firstdate=Date.fromarray(array[:6]),
</span><span class="noop">                       lastdate=Date.fromarray(array[6:12]),
</span><span class="noop">                       stepsize=Period.fromseconds(array[12]))
</span><span class="miss">        except IndexError:
</span><span class="miss">            raise IndexError(&#39;To define a Timegrid instance via an array, 13 &#39;
</span><span class="noop">                             &#39;numbers are required.  However, the given array &#39;
</span><span class="noop">                             &#39;consist of %d entries/rows only.&#39; % len(array))
</span><span class="noop">
</span><span class="hit">    def toarray(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a 1-dimensional :mod:`numpy` :class:`~numpy.ndarray` with
</span><span class="noop">        thirteen entries first defining the start date, secondly defining the
</span><span class="noop">        end date and thirdly the step size.&#34;&#34;&#34;
</span><span class="miss">        values = numpy.empty(13, dtype=float)
</span><span class="miss">        values[:6] = self.firstdate.toarray()
</span><span class="miss">        values[6:12] = self.lastdate.toarray()
</span><span class="miss">        values[12] = self.stepsize.seconds
</span><span class="miss">        return values
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.ValueError` if the dates or the
</span><span class="noop">        step size of the time frame are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.firstdate &gt;= self.lastdate:
</span><span class="hit">            raise ValueError(&#39;Unplausible timegrid. The first given &#39;
</span><span class="noop">                             &#39;date %s, the second given date is %s. &#39;
</span><span class="noop">                             % (self.firstdate, self.lastdate))
</span><span class="hit">        if (self.lastdate-self.firstdate) % self.stepsize:
</span><span class="hit">            raise ValueError(&#39;Unplausible timegrid. The period span &#39;
</span><span class="noop">                             &#39;between the given dates %s and %s is not &#39;
</span><span class="noop">                             &#39;a multiple of the given step size %s.&#39; %
</span><span class="noop">                             (self.firstdate, self.lastdate, self.stepsize))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrid` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return int((self.lastdate-self.firstdate) / self.stepsize)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        if isinstance(key, int):
</span><span class="hit">            return Date(self.firstdate + key*self.stepsize)
</span><span class="noop">        else:
</span><span class="hit">            key = Date(key)
</span><span class="hit">            index = (key-self.firstdate) / self.stepsize
</span><span class="hit">            if index % 1.:
</span><span class="hit">                raise ValueError(&#39;The given date `%s` is not properly &#39;
</span><span class="noop">                                 &#39;alligned on the indexed timegrid.&#39; %  key)
</span><span class="noop">            else:
</span><span class="hit">                return int(index)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        date = self.firstdate.copy()
</span><span class="hit">        while date &lt; self.lastdate:
</span><span class="hit">            yield date
</span><span class="hit">            date = date + self.stepsize
</span><span class="noop">
</span><span class="hit">    def _containsdate(self, date):
</span><span class="hit">        date = Date(date)
</span><span class="hit">        return ((self.firstdate &lt;= date &lt;= self.lastdate) and
</span><span class="noop">                ((date-self.firstdate) // self.stepsize))
</span><span class="noop">
</span><span class="hit">    def _containstimegrid(self, timegrid):
</span><span class="hit">        return (self._containsdate(timegrid.firstdate) and
</span><span class="noop">                self._containsdate(timegrid.lastdate) and
</span><span class="noop">                (timegrid.stepsize == self.stepsize))
</span><span class="noop">
</span><span class="hit">    def __contains__(self, other):
</span><span class="hit">        if isinstance(other, Timegrid):
</span><span class="hit">            return self._containstimegrid(other)
</span><span class="noop">        else:
</span><span class="hit">            return self._containsdate(other)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return ((self.firstdate == other.firstdate) and
</span><span class="noop">                (self.lastdate == other.lastdate) and
</span><span class="noop">                (self.stepsize == other.stepsize))
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return ((self.firstdate != other.firstdate) or
</span><span class="noop">                (self.lastdate != other.lastdate) or
</span><span class="noop">                (self.stepsize != other.stepsize))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return (&#39;from %s to %s in %s steps&#39;
</span><span class="noop">                % (self.firstdate, self.lastdate, self.stepsize))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        skip = len(prefix) + 9
</span><span class="hit">        blanks = &#39; &#39; * skip
</span><span class="hit">        lines = [&#39;%sTimegrid(&#34;%s&#34;,&#39; % (prefix, str(self.firstdate)),
</span><span class="noop">                 &#39;%s&#34;%s&#34;,&#39; % (blanks, str(self.lastdate)),
</span><span class="noop">                 &#39;%s&#34;%s&#34;)&#39; % (blanks, str(self.stepsize))]
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _Timegrids(object):
</span><span class="noop">    &#34;&#34;&#34;Handle all :class:`Timegrid` instances of a HydPy application.
</span><span class="noop">
</span><span class="noop">    Arguments:
</span><span class="noop">        * info (:class:`dict`): Dictionary containing initialisation
</span><span class="noop">          information, usually defined within the main project file.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * data (:class:`Timegrid`): For the available data stored on disk.
</span><span class="noop">        * init (:class:`Timegrid`): For the initialisation period.
</span><span class="noop">        * sim (:class:`Timegrid`): For the simulation period.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, info):
</span><span class="miss">        args = []
</span><span class="miss">        for key in (&#39;date_startdata&#39;, &#39;date_enddata&#39;, &#39;timestep&#39;):
</span><span class="miss">            try:
</span><span class="miss">                args.append(info[key])
</span><span class="miss">            except KeyError:
</span><span class="miss">                raise KeyError(&#39;The information `%s` is missing. Usually, &#39;
</span><span class="noop">                               &#39;it is defined within the main project file.&#39;
</span><span class="noop">                               % key)
</span><span class="miss">        self.data = Timegrid(*args)
</span><span class="miss">        self.init = Timegrid(info.get(&#39;date_startinit&#39;,
</span><span class="noop">                                      self.data.firstdate.copy()),
</span><span class="noop">                             info.get(&#39;date_endinit&#39;,
</span><span class="noop">                                      self.data.lastdate.copy()),
</span><span class="noop">                             self.data.stepsize)
</span><span class="miss">        self.sim = Timegrid(info.get(&#39;date_startsim&#39;,
</span><span class="noop">                                     self.init.firstdate.copy()),
</span><span class="noop">                            info.get(&#39;date_endsim&#39;,
</span><span class="noop">                                     self.init.lastdate.copy()),
</span><span class="noop">                            self.init.stepsize)
</span><span class="miss">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="noop">        &#34;&#34;&#34;Stepsize of all handled :class:`Timegrid` objects.&#34;&#34;&#34;
</span><span class="miss">        return self.data.stepsize
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="miss">        stepsize = Period(stepsize)
</span><span class="miss">        for (name, timegrid) in self:
</span><span class="miss">            timegrid.stepsize = stepsize
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.RuntimeError` it the different
</span><span class="noop">        time grids are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.data.firstdate &gt; self.init.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be later than the first date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.firstdate, self.init.firstdate))
</span><span class="miss">        if self.data.lastdate &lt; self.init.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be earlier than the last date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.lastdate, self.init.lastdate))
</span><span class="miss">        if self.init.firstdate &gt; self.sim.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be later than the first date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.firstdate, self.sim.firstdate))
</span><span class="miss">        if self.init.lastdate &lt; self.sim.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be earlier than the last date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.lastdate, self.sim.lastdate))
</span><span class="miss">        if self.data.stepsize != self.init.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The data stepsize (%s) must be identical with &#39;
</span><span class="noop">                               &#39;the initialisation stepsize (%s).&#39;
</span><span class="noop">                               % (self.data.stepsize, self.init.stepsize))
</span><span class="miss">        if self.init.stepsize != self.sim.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The initialization stepsize (%s) must be &#39;
</span><span class="noop">                               &#39;identical with the simulation stepsize (%s).&#39;
</span><span class="noop">                               % (self.init.stepsize, self.sim.stepsize))
</span><span class="miss">        if self.data[self.init.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The initialization time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the data time grid.&#39;)
</span><span class="miss">        if self.init[self.sim.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The simulation time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the initialization time grid.&#39;)
</span><span class="noop">
</span><span class="hit">    def qfactor(self, area):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting `mm/stepsize` to `m^3/s`.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * area (:class:`float`): Reference area, which must be given in
</span><span class="noop">              the unit `km^2`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return area * 1000. / self.stepsize.seconds
</span><span class="noop">
</span><span class="hit">    def parfactor(self, stepsize):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting parameter to simulation step size.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * stepsize (:class:`Period` or an suitable initialization argument
</span><span class="noop">              thereof): Time interval, to which the parameter values refer.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self.stepsize / Period(stepsize)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrids` instance.&#34;&#34;&#34;
</span><span class="miss">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, timegrid) in dict(self).items():
</span><span class="miss">            yield (name, timegrid)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return &#39;All timegrids of the current project.&#39;
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        dic = {&#39;timestep&#39;: self.sim.stepsize,
</span><span class="noop">               &#39;date_startdata&#39;: self.data.firstdate,
</span><span class="noop">               &#39;date_enddata&#39;: self.data.lastdate,
</span><span class="noop">               &#39;date_startinit&#39;: self.init.firstdate,
</span><span class="noop">               &#39;date_endinit&#39;: self.init.lastdate,
</span><span class="noop">               &#39;date_startsim&#39;: self.sim.firstdate,
</span><span class="noop">               &#39;date_endsim&#39;: self.sim.lastdate}
</span><span class="miss">        return &#39;Timegrids(%s)&#39; % dic.__repr__()
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Timegrids(object):
</span><span class="noop">    &#34;&#34;&#34;Handle all :class:`Timegrid` instances of a HydPy application.
</span><span class="noop">
</span><span class="noop">    Arguments and Attributes:
</span><span class="noop">        * data (:class:`Timegrid`): For the available data stored on disk.
</span><span class="noop">        * init (:class:`Timegrid`, optional): For the initialisation
</span><span class="noop">          period.  If not supplied, the specifications of the `data`
</span><span class="noop">          :class:`Timegrid` are applied.
</span><span class="noop">        * sim (:class:`Timegrid`, optional): For the simulation period.
</span><span class="noop">          If not supplied, the specifications of the `init` :class:`Timegrid`
</span><span class="noop">          are applied.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, data, init=None, sim=None):
</span><span class="hit">        self.data = data
</span><span class="hit">        if init is None:
</span><span class="hit">            self.init = self.data.copy()
</span><span class="noop">        else:
</span><span class="miss">            self.init = init
</span><span class="hit">        if sim is None:
</span><span class="hit">            self.sim = self.init.copy()
</span><span class="noop">        else:
</span><span class="miss">            self.sim = sim
</span><span class="hit">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="noop">        &#34;&#34;&#34;Stepsize of all handled :class:`Timegrid` objects.&#34;&#34;&#34;
</span><span class="hit">        return self.data.stepsize
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="miss">        stepsize = Period(stepsize)
</span><span class="miss">        for (name, timegrid) in self:
</span><span class="miss">            timegrid.stepsize = stepsize
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.RuntimeError` it the different
</span><span class="noop">        time grids are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.data.firstdate &gt; self.init.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be later than the first date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.firstdate,
</span><span class="noop">                                  self.init.firstdate))
</span><span class="hit">        if self.data.lastdate &lt; self.init.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be earlier than the last date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.lastdate,
</span><span class="noop">                                  self.init.lastdate))
</span><span class="hit">        if self.init.firstdate &gt; self.sim.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be later than the first date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.firstdate,
</span><span class="noop">                                  self.sim.firstdate))
</span><span class="hit">        if self.init.lastdate &lt; self.sim.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be earlier than the last date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.lastdate,
</span><span class="noop">                                  self.sim.lastdate))
</span><span class="hit">        if self.data.stepsize != self.init.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The data stepsize (%s) must be identical with &#39;
</span><span class="noop">                               &#39;the initialisation stepsize (%s).&#39;
</span><span class="noop">                               % (self.data.stepsize,
</span><span class="noop">                                  self.init.stepsize))
</span><span class="hit">        if self.init.stepsize != self.sim.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The initialization stepsize (%s) must be &#39;
</span><span class="noop">                               &#39;identical with the simulation stepsize (%s).&#39;
</span><span class="noop">                               % (self.init.stepsize,
</span><span class="noop">                                  self.sim.stepsize))
</span><span class="hit">        if self.data[self.init.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The initialization time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the data time grid.&#39;)
</span><span class="hit">        if self.init[self.sim.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The simulation time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the initialization time grid.&#39;)
</span><span class="noop">
</span><span class="hit">    def qfactor(self, area):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting `mm/stepsize` to `m^3/s`.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * area (:class:`float`): Reference area, which must be given in
</span><span class="noop">              the unit `km^2`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return area * 1000. / self.stepsize.seconds
</span><span class="noop">
</span><span class="hit">    def parfactor(self, stepsize):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting parameter to simulation step size.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * stepsize (:class:`Period` or an suitable initialization argument
</span><span class="noop">              thereof): Time interval, to which the parameter values refer.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.stepsize / Period(stepsize)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrids` instance.&#34;&#34;&#34;
</span><span class="miss">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, timegrid) in dict(self).items():
</span><span class="miss">            yield (name, timegrid)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return &#39;All timegrids of the actual HydPy project.&#39;
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        caller = &#39;NewTimegrids(&#39;
</span><span class="miss">        blanks = &#39; &#39; * (len(prefix) + len(caller))
</span><span class="miss">        prefix = &#39;%s%sdata=&#39; % (prefix, caller)
</span><span class="miss">        lines = [&#39;%s,&#39; % self.data.assignrepr(prefix)]
</span><span class="miss">        if self.init != self.data:
</span><span class="miss">            prefix = &#39;%sinit=&#39; % blanks
</span><span class="miss">            lines.append(&#39;%s,&#39; % self.init.assignrepr(prefix))
</span><span class="miss">        if self.sim != self.init:
</span><span class="miss">            prefix = &#39;%ssim=&#39; % blanks
</span><span class="miss">            lines.append(&#39;%s,&#39; %  self.init.assignrepr(prefix))
</span><span class="miss">        lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Created on Mon Jan 30 14:23:11 2017
</span><span class="noop">
</span><span class="noop">@author: tyralla
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="hit">&#34;&#34;&#34; This module provides utilities to build and apply cython models.
</span><span class="noop">
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import platform
</span><span class="hit">import shutil
</span><span class="hit">import copy
</span><span class="hit">import inspect
</span><span class="hit">import importlib
</span><span class="hit">import distutils.core
</span><span class="hit">import distutils.extension
</span><span class="hit">import Cython.Build
</span><span class="noop"># ...third party modules
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy import cythons
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import magictools
</span><span class="noop">
</span><span class="hit">if platform.system().lower() == &#39;windows&#39;:
</span><span class="miss">    dllextension = &#39;.pyd&#39;
</span><span class="miss">    &#34;&#34;&#34;The dll file extension on the respective system.&#34;&#34;&#34;
</span><span class="noop">else:
</span><span class="hit">    dllextension = &#39;.so&#39;
</span><span class="noop">
</span><span class="hit">TYPE2STR = {bool: &#39;bint&#39;,
</span><span class="noop">            int: &#39;numpy.&#39;+str(numpy.array([1]).dtype)+&#39;_t&#39;,
</span><span class="noop">            float: &#39;double&#39;,
</span><span class="noop">            str: &#39;str&#39;,
</span><span class="noop">            None: &#39;void&#39;}
</span><span class="noop">&#34;&#34;&#34;Maps Python types to Cython compatible type declarations.
</span><span class="noop">
</span><span class="noop">The Cython type belonging to Python&#39;s :class:`int` is selected to be in
</span><span class="noop">agreement with numpy&#39;s default integer type on the respective platform/system.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="hit">NDIM2STR = {0: &#39;&#39;,
</span><span class="noop">            1: &#39;[:]&#39;,
</span><span class="noop">            2: &#39;[:,:]&#39;,
</span><span class="noop">            3: &#39;[:,:,:]&#39;}
</span><span class="noop">
</span><span class="hit">class Lines(list):
</span><span class="noop">    &#34;&#34;&#34;Handles lines to be written into a `.pyx` file.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, *args):
</span><span class="hit">        list.__init__(self, args)
</span><span class="noop">
</span><span class="hit">    def add(self, indent, line):
</span><span class="noop">        &#34;&#34;&#34;Appends the given text line with prefixed spaces in accordance with
</span><span class="noop">        the given number of indentation levels.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        list.append(self, indent*4*&#39; &#39; + line)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#39;\n&#39;.join(self) + &#39;\n&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Cythonizer(object):
</span><span class="noop">    &#34;&#34;&#34;Handles the writing, compiling and initialization of cython models.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        frame = inspect.currentframe().f_back
</span><span class="hit">        self.pymodule = frame.f_globals[&#39;__name__&#39;]
</span><span class="hit">        for (key, value) in frame.f_locals.items():
</span><span class="hit">            setattr(self, key, value)
</span><span class="noop">
</span><span class="hit">    def complete(self):
</span><span class="hit">        if self.outdated:
</span><span class="hit">            if not pub.options.skipdoctests:
</span><span class="miss">                pub.options.usecython = False
</span><span class="miss">                self.tester.doit()
</span><span class="hit">            self.doit()
</span><span class="hit">            if not pub.options.skipdoctests:
</span><span class="miss">                pub.options.usecython = True
</span><span class="miss">                self.tester.doit()
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="hit">        with magictools.PrintStyle(color=33, font=4):
</span><span class="hit">            print(&#39;Translate module/package %s.&#39;% self.pyname)
</span><span class="hit">        with magictools.PrintStyle(color=33, font=2):
</span><span class="hit">            self.pyxwriter.write()
</span><span class="hit">        with magictools.PrintStyle(color=31, font=4):
</span><span class="hit">            print(&#39;Compile module %s.&#39; % self.cyname)
</span><span class="hit">        with magictools.PrintStyle(color=31, font=2):
</span><span class="hit">            self.compile_()
</span><span class="hit">            self.movedll()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        if self.pymodule.endswith(&#39;__init__&#39;):
</span><span class="hit">            return self.pymodule.split(&#39;.&#39;)[-2]
</span><span class="noop">        else:
</span><span class="hit">            return self.pymodule.split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cyname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        return &#39;c_&#39; + self.pyname
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cydirpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory containing the compiled modules.&#34;&#34;&#34;
</span><span class="hit">        return cythons.__path__[0]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cymodule(self):
</span><span class="noop">        &#34;&#34;&#34;The compiled module.&#34;&#34;&#34;
</span><span class="hit">        return importlib.import_module(&#39;hydpy.cythons.&#39;+self.cyname)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cyfilepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        return os.path.join(self.cydirpath, self.cyname+&#39;.pyx&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def buildpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path for temporarily build files.&#34;&#34;&#34;
</span><span class="hit">        return os.path.join(self.cydirpath, &#39;_build&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyxwriter(self):
</span><span class="noop">        &#34;&#34;&#34;Update the pyx file.&#34;&#34;&#34;
</span><span class="hit">        model = self.Model()
</span><span class="hit">        model.parameters = self.Parameters(vars(self))
</span><span class="hit">        model.sequences = self.Sequences(vars(self))
</span><span class="hit">        return PyxWriter(self, model, self.cyfilepath)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pysourcefiles(self):
</span><span class="noop">        &#34;&#34;&#34;All source files of the actual models Python classes and their
</span><span class="noop">        respective base classes.&#34;&#34;&#34;
</span><span class="hit">        sourcefiles = set()
</span><span class="hit">        for (name, child) in vars(self).items():
</span><span class="hit">            try:
</span><span class="hit">                parents = inspect.getmro(child)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                continue
</span><span class="hit">            for parent in parents:
</span><span class="hit">                try:
</span><span class="hit">                    sourcefile = inspect.getfile(parent)
</span><span class="hit">                except TypeError:
</span><span class="hit">                    break
</span><span class="hit">                sourcefiles.add(sourcefile)
</span><span class="hit">        return Lines(*sourcefiles)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def outdated(self):
</span><span class="noop">        &#34;&#34;&#34;True if at least one of the :attr:`~Cythonizer.pysourcefiles`
</span><span class="noop">        is newer than the compiled file under :attr:`~Cythonizer.cyfilepath`,
</span><span class="noop">        otherwise False.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if not os.path.exists(self.cyfilepath):
</span><span class="hit">            return True
</span><span class="hit">        cydate = os.stat(self.cyfilepath).st_mtime
</span><span class="hit">        for pysourcefile in self.pysourcefiles:
</span><span class="hit">            pydate = os.stat(pysourcefile).st_mtime
</span><span class="hit">            if pydate &gt; cydate:
</span><span class="miss">                return True
</span><span class="hit">        return False
</span><span class="noop">
</span><span class="hit">    def compile_(self):
</span><span class="noop">        &#34;&#34;&#34;Translate cython code to C code and compile it.&#34;&#34;&#34;
</span><span class="hit">        argv = copy.deepcopy(sys.argv)
</span><span class="hit">        sys.argv = [sys.argv[0], &#39;build_ext&#39;, &#39;--build-lib=&#39;+self.buildpath]
</span><span class="hit">        exc_modules = Cython.Build.cythonize(self.cyfilepath)
</span><span class="hit">        distutils.core.setup(ext_modules=exc_modules,
</span><span class="noop">                             include_dirs=[numpy.get_include()])
</span><span class="hit">        sys.argv = argv
</span><span class="noop">
</span><span class="hit">    def movedll(self):
</span><span class="noop">        &#34;&#34;&#34;Try to find the resulting dll file and to move it into the
</span><span class="noop">        `cythons` package.
</span><span class="noop">
</span><span class="noop">        Things to be aware of:
</span><span class="noop">          * The file extension either `pyd` (Window) or `so` (Linux).
</span><span class="noop">          * The folder containing the dll file is system dependend, but is
</span><span class="noop">            always a subfolder of the `cythons` package.
</span><span class="noop">          * Under Linux, the filename might contain system information, e.g.
</span><span class="noop">            ...cpython-36m-x86_64-linux-gnu.so.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        dirinfos = os.walk(self.buildpath)
</span><span class="hit">        next(dirinfos)
</span><span class="hit">        system_dependend_filename = None
</span><span class="hit">        for dirinfo in dirinfos:
</span><span class="hit">            for filename in dirinfo[2]:
</span><span class="hit">                if (filename.startswith(self.cyname) and
</span><span class="noop">                        filename.endswith(dllextension)):
</span><span class="hit">                    system_dependend_filename = filename
</span><span class="hit">                    break
</span><span class="hit">            if system_dependend_filename:
</span><span class="hit">                try:
</span><span class="hit">                    shutil.move(os.path.join(dirinfo[0],
</span><span class="noop">                                             system_dependend_filename),
</span><span class="noop">                                os.path.join(self.cydirpath,
</span><span class="noop">                                             self.cyname+dllextension))
</span><span class="hit">                    break
</span><span class="miss">                except BaseException:
</span><span class="miss">                    prefix = (&#39;After trying to cythonize module %s, when &#39;
</span><span class="noop">                              &#39;trying to move the final cython module %s &#39;
</span><span class="noop">                              &#39;from directory %s to directory %s&#39;
</span><span class="noop">                              % (self.pyname, system_dependend_filename,
</span><span class="noop">                                 self.buildpath, self.cydirpath))
</span><span class="miss">                    suffix = (&#39;A likely error cause is that the cython module &#39;
</span><span class="noop">                              &#39;%s does already exist in this directory and is &#39;
</span><span class="noop">                              &#39;currently blocked by another Python process.  &#39;
</span><span class="noop">                              &#39;Maybe it helps to close all Python processes &#39;
</span><span class="noop">                              &#39;and restart the cyhonization afterwards.&#39;
</span><span class="noop">                              % self.cyname+dllextension)
</span><span class="miss">                    objecttools.augmentexcmessage(prefix, suffix)
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;After trying to cythonize module %s, the resulting &#39;
</span><span class="noop">                          &#39;file %s could neither be found in directory %s nor &#39;
</span><span class="noop">                          &#39;its subdirectories.  The distul report should tell &#39;
</span><span class="noop">                          &#39;whether the file has been stored somewhere else,&#39;
</span><span class="noop">                          &#39;is named somehow else, or could not be build at &#39;
</span><span class="noop">                          &#39;all.&#39; % self.buildpath)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PyxWriter(object):
</span><span class="noop">    &#34;&#34;&#34;Writes a new pyx file into framework.models.cython when initialized.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, cythonizer, model, pyxpath):
</span><span class="hit">        self.cythonizer = cythonizer
</span><span class="hit">        self.model = model
</span><span class="hit">        self.pyxpath = pyxpath
</span><span class="noop">
</span><span class="hit">    def write(self):
</span><span class="hit">        with open(self.pyxpath, &#39;w&#39;) as pxf:
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* cython options&#39;)
</span><span class="hit">            pxf.write(repr(self.cythonoptions))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* C imports&#39;)
</span><span class="hit">            pxf.write(repr(self.cimports))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* constants (if defined)&#39;)
</span><span class="hit">            pxf.write(repr(self.constants))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* parameter classes&#39;)
</span><span class="hit">            pxf.write(repr(self.parameters))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* sequence classes&#39;)
</span><span class="hit">            pxf.write(repr(self.sequences))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* model class&#39;)
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- model attributes&#39;)
</span><span class="hit">            pxf.write(repr(self.modeldeclarations))
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- standard functions&#39;)
</span><span class="hit">            pxf.write(repr(self.modelstandardfunctions))
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- additional functions&#39;)
</span><span class="hit">            pxf.write(repr(self.modeluserfunctions))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cythonoptions(self):
</span><span class="noop">        &#34;&#34;&#34;Cython option lines.&#34;&#34;&#34;
</span><span class="hit">        return Lines(&#39;#!python&#39;,
</span><span class="noop">                     &#39;#cython: boundscheck=False&#39;,
</span><span class="noop">                     &#39;#cython: wraparound=False&#39;,
</span><span class="noop">                     &#39;#cython: initializedcheck=False&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cimports(self):
</span><span class="noop">        &#34;&#34;&#34;Import command lines.&#34;&#34;&#34;
</span><span class="hit">        return Lines(&#39;import numpy&#39;,
</span><span class="noop">                     &#39;cimport numpy&#39;,
</span><span class="noop">                     &#39;from libc.math cimport exp&#39;,
</span><span class="noop">                     &#39;from libc.stdio cimport *&#39;,
</span><span class="noop">                     &#39;from libc.stdlib cimport *&#39;,
</span><span class="noop">                     &#39;import cython&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Malloc&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Realloc&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Free&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons cimport pointer&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons import pointer&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def constants(self):
</span><span class="noop">        &#34;&#34;&#34;Constants declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, member) in vars(self.cythonizer).items():
</span><span class="hit">            if name.isupper() and not inspect.isclass(member):
</span><span class="hit">                ndim = numpy.array(member).ndim
</span><span class="hit">                ctype = TYPE2STR[type(member)] + NDIM2STR[ndim]
</span><span class="hit">                lines.add(0, &#39;cdef public %s %s = %s&#39;
</span><span class="noop">                             % (ctype, name, member))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def parameters(self):
</span><span class="noop">        &#34;&#34;&#34;Parameter declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name1, subpars) in self.model.parameters:
</span><span class="hit">            print(&#39;        - %s&#39; % name1)
</span><span class="hit">            lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class %s(object):&#39;
</span><span class="noop">                         % objecttools.classname(subpars))
</span><span class="hit">            for (name2, par) in subpars:
</span><span class="hit">                ctype = TYPE2STR[par.TYPE] + NDIM2STR[par.NDIM]
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39; % (ctype, name2))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def sequences(self):
</span><span class="noop">        &#34;&#34;&#34;Sequence declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name1, subseqs) in self.model.sequences:
</span><span class="hit">            print(&#39;        - %s&#39; % name1)
</span><span class="hit">            lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class %s(object):&#39;
</span><span class="noop">                         % objecttools.classname(subseqs))
</span><span class="hit">            for (name2, seq) in subseqs:
</span><span class="hit">                ctype = &#39;double&#39; + NDIM2STR[seq.NDIM]
</span><span class="hit">                if isinstance(subseqs, sequencetools.LinkSequences):
</span><span class="hit">                    if seq.NDIM == 0:
</span><span class="hit">                        lines.add(1, &#39;cdef double *%s&#39; % name2)
</span><span class="hit">                    elif seq.NDIM == 1:
</span><span class="hit">                        lines.add(1, &#39;cdef double **%s&#39; % name2)
</span><span class="noop">                else:
</span><span class="hit">                    lines.add(1, &#39;cdef public %s %s&#39; % (ctype, name2))
</span><span class="hit">                lines.add(1, &#39;cdef public int _%s_ndim&#39; % name2)
</span><span class="hit">                lines.add(1, &#39;cdef public int _%s_length&#39; % name2)
</span><span class="hit">                for idx in range(seq.NDIM):
</span><span class="hit">                    lines.add(1, &#39;cdef public int _%s_length_%d&#39;
</span><span class="noop">                                 % (seq.name, idx))
</span><span class="hit">                if isinstance(subseqs, sequencetools.IOSubSequences):
</span><span class="hit">                    lines.extend(self.iosequence(seq))
</span><span class="hit">            if isinstance(subseqs, sequencetools.InputSequences):
</span><span class="hit">                lines.extend(self.loaddata(subseqs))
</span><span class="hit">            if isinstance(subseqs, sequencetools.IOSubSequences):
</span><span class="hit">                lines.extend(self.openfiles(subseqs))
</span><span class="hit">                lines.extend(self.closefiles(subseqs))
</span><span class="hit">                if not isinstance(subseqs, sequencetools.InputSequence):
</span><span class="hit">                    lines.extend(self.savedata(subseqs))
</span><span class="hit">            if isinstance(subseqs, sequencetools.LinkSequences):
</span><span class="hit">                lines.extend(self.setpointer(subseqs))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def iosequence(self, seq):
</span><span class="noop">        &#34;&#34;&#34;Special declaration lines for the given
</span><span class="noop">        :class:`~hydpy.core.sequencetools.IOSequence` object.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cdef public bint _%s_diskflag&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef public str _%s_path&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef FILE *_%s_file&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef public bint _%s_ramflag&#39; % seq.name)
</span><span class="hit">        ctype = &#39;double&#39; + NDIM2STR[seq.NDIM+1]
</span><span class="hit">        lines.add(1, &#39;cdef public %s _%s_array&#39; % (ctype, seq.name))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def openfiles(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Open file statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . openfiles&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef openfiles(self, int idx):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self._%s_file = fopen(str(self._%s_path), &#34;rb+&#34;)&#39;
</span><span class="noop">                         % (2*(name,)))
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;fseek(self._%s_file, idx*8, SEEK_SET)&#39; % name)
</span><span class="noop">            else:
</span><span class="hit">                lines.add(3, &#39;fseek(self._%s_file, idx*self._%s_length*8, &#39;
</span><span class="noop">                             &#39;SEEK_SET)&#39; % (2*(name,)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def closefiles(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Close file statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . closefiles&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline closefiles(self):&#39;)
</span><span class="hit">        for (name, seq) in sorted(subseqs):
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;fclose(self._%s_file)&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def loaddata(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Load data statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . loaddata&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1 ,&#39;cpdef inline loaddata(self, int idx):&#39;)
</span><span class="hit">        lines.add(2 ,&#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2 ,&#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3 ,&#39;fread(&amp;self.%s, 8, 1, self._%s_file)&#39;
</span><span class="noop">                             % (2*(name,)))
</span><span class="noop">            else:
</span><span class="miss">                lines.add(3 ,&#39;fread(&amp;self.%s[0], 8, self._%s_length, &#39;
</span><span class="noop">                             &#39;self._%s_file)&#39; % (3*((name,))))
</span><span class="hit">            lines.add(2 ,&#39;elif self._%s_ramflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3 ,&#39;self.%s = self._%s_array[idx]&#39; % (2*(name,)))
</span><span class="noop">            else:
</span><span class="miss">                indexing = &#39;&#39;
</span><span class="miss">                for idx in range(seq.NDIM):
</span><span class="miss">                    lines.add(3+idx ,&#39;for jdx%d in range(self._%s_length_%d):&#39;
</span><span class="noop">                                     % (idx, name, idx))
</span><span class="miss">                    indexing += &#39;jdx%d,&#39; % idx
</span><span class="miss">                indexing = indexing[:-1]
</span><span class="miss">                lines.add(3+seq.NDIM,&#39;self.%s[%s] = self._%s_array[idx,%s]&#39;
</span><span class="noop">                                     % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def savedata(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Save data statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . savedata&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1 ,&#39;cpdef inline savedata(self, int idx):&#39;)
</span><span class="hit">        lines.add(2 ,&#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2 ,&#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3 ,&#39;fwrite(&amp;self.%s, 8, 1, self._%s_file)&#39;
</span><span class="noop">                             % (2*(name,)))
</span><span class="noop">            else:
</span><span class="hit">                lines.add(3 ,&#39;fwrite(&amp;self.%s[0], 8, self._%s_length, &#39;
</span><span class="noop">                             &#39;self._%s_file)&#39; % (3*(name,)))
</span><span class="hit">            lines.add(2 ,&#39;elif self._%s_ramflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3 ,&#39;self._%s_array[idx] = self.%s&#39; % (2*(name,)))
</span><span class="noop">            else:
</span><span class="hit">                indexing = &#39;&#39;
</span><span class="hit">                for idx in range(seq.NDIM):
</span><span class="hit">                    lines.add(3+idx ,&#39;for jdx%d in range(self._%s_length_%d):&#39;
</span><span class="noop">                                     % (idx, name, idx))
</span><span class="hit">                    indexing += &#39;jdx%d,&#39; % idx
</span><span class="hit">                indexing = indexing[:-1]
</span><span class="hit">                lines.add(3+seq.NDIM,&#39;self._%s_array[idx,%s] = self.%s[%s]&#39;
</span><span class="noop">                                     % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer functions for link sequences.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.extend(self.setpointer0d(subseqs))
</span><span class="noop">                #lines.extend(self.getpointer0d(subseqs))
</span><span class="hit">            break
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            if seq.NDIM == 1:
</span><span class="hit">                lines.extend(self.alloc(subseqs))
</span><span class="hit">                lines.extend(self.dealloc(subseqs))
</span><span class="hit">                lines.extend(self.setpointer1d(subseqs))
</span><span class="noop">                #lines.extend(self.getpointer1d(subseqs))
</span><span class="hit">            break
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer0d(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer function for 0-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setpointer0d&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1 ,&#39;cpdef inline setpointer0d&#39;
</span><span class="noop">                     &#39;(self, str name, pointer.PDouble value):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2 ,&#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3 ,&#39;self.%s = value.p_value&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="noop">#    def getpointer0d(self, subseqs):
</span><span class="noop">#        &#34;&#34;&#34;Get the pointer of the selected 0-dimensional link sequence.&#34;&#34;&#34;
</span><span class="noop">#        print(&#39;            . getpointer0d&#39;)
</span><span class="noop">#        lines = Lines()
</span><span class="noop">#        lines.add(1 ,&#39;cpdef inline getpointer0d(self, str name):&#39;)
</span><span class="noop">#        lines.add(2, &#39;cdef pointer.PDouble value&#39;)
</span><span class="noop">#        lines.add(2, &#39;value = pointer.PDouble(pointer.Double(0.))&#39;)
</span><span class="noop">#        for (name, seq) in subseqs:
</span><span class="noop">#            lines.add(2 ,&#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="noop">#            lines.add(3, &#39;value.p_value = self.%s&#39; % name)
</span><span class="noop">#        lines.add(2, &#39;return value&#39;)
</span><span class="noop">#        return lines
</span><span class="noop">
</span><span class="hit">    def alloc(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Allocate memory for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setlength&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1 ,&#39;cpdef inline alloc(self, name, int length):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2 ,&#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self._%s_length_0 = length&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self.%s = &lt;double**&gt; &#39;
</span><span class="noop">                         &#39;PyMem_Malloc(length * sizeof(double*))&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def dealloc(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Deallocate memory for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . dealloc&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1 ,&#39;cpdef inline dealloc(self):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;PyMem_Free(self.%s)&#39; %name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer1d(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer function for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setpointer1d&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1 ,&#39;cpdef inline setpointer1d&#39;
</span><span class="noop">                     &#39;(self, str name, pointer.PDouble value, int idx):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2 ,&#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3 ,&#39;self.%s[idx] = value.p_value&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="noop">#    def getpointer1d(self, subseqs):
</span><span class="noop">#        &#34;&#34;&#34;Get the pointer of the selected 1-dimensional link sequence.&#34;&#34;&#34;
</span><span class="noop">#        print(&#39;            . getpointer1d&#39;)
</span><span class="noop">#        lines = Lines()
</span><span class="noop">#        lines.add(1 ,&#39;cpdef inline getpointer1d(self, str name):&#39;)
</span><span class="noop">#        lines.add(2, &#39;cdef pointer.PPDouble values&#39;)
</span><span class="noop">#        lines.add(2, &#39;values = pointer.PPDouble()&#39;)
</span><span class="noop">#        for (name, seq) in subseqs:
</span><span class="noop">#            lines.add(2 ,&#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="noop">#            lines.add(3, &#39;values.length = self._%s_length_0&#39; % name)
</span><span class="noop">#            lines.add(3, &#39;values.pp_value = &lt;double**&gt; &#39;
</span><span class="noop">#                         &#39;PyMem_Malloc(values.length * sizeof(double*))&#39;)
</span><span class="noop">#            lines.add(3, &#39;values.pp_value = self.%s&#39; % name)
</span><span class="noop">#        lines.add(2, &#39;return values&#39;)
</span><span class="noop">#        return lines
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modeldeclarations(self):
</span><span class="noop">        &#34;&#34;&#34;Attribute declarations of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(0 ,&#39;@cython.final&#39;)
</span><span class="hit">        lines.add(0 ,&#39;cdef class Model(object):&#39;)
</span><span class="hit">        for things in (self.model.parameters, self.model.sequences):
</span><span class="hit">            for (name, thing) in things:
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39;
</span><span class="noop">                             % (objecttools.classname(thing), name))
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            lines.add(1, &#39;cdef public StateSequences old_states&#39;)
</span><span class="hit">            lines.add(1, &#39;cdef public StateSequences new_states&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modelstandardfunctions(self):
</span><span class="noop">        &#34;&#34;&#34;Standard functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.extend(self.doit)
</span><span class="hit">        lines.extend(self.iofunctions)
</span><span class="hit">        lines.extend(self.new2old)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def doit(self):
</span><span class="noop">        &#34;&#34;&#34;Do (most of) it function of the model class.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;                . doit&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline void doit(self, int idx):&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;inputs&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.loaddata(idx)&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;inlets&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.updateinlets(idx)&#39;)
</span><span class="hit">        lines.add(2, &#39;self.run(idx)&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;outlets&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.updateoutlets(idx)&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.new2old()&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;senders&#39;, None) is not None:
</span><span class="miss">            lines.add(2, &#39;self.updatesenders(idx)&#39;)
</span><span class="hit">        if ((getattr(self.model.sequences, &#39;fluxes&#39;, None) is not None) or
</span><span class="noop">            (getattr(self.model.sequences, &#39;states&#39;, None) is not None)):
</span><span class="hit">                lines.add(2, &#39;self.savedata(idx)&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def iofunctions(self):
</span><span class="noop">        &#34;&#34;&#34;Input/output functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for func in (&#39;openfiles&#39;, &#39;closefiles&#39;, &#39;loaddata&#39;, &#39;savedata&#39;):
</span><span class="hit">            if ((func == &#39;loaddata&#39;) and
</span><span class="noop">                (getattr(self.model.sequences, &#39;inputs&#39;, None) is None)):
</span><span class="hit">                continue
</span><span class="hit">            if ((func == &#39;savedata&#39;) and
</span><span class="noop">                ((getattr(self.model.sequences, &#39;fluxes&#39;, None) is None) and
</span><span class="noop">                 (getattr(self.model.sequences, &#39;states&#39;, None) is None))):
</span><span class="miss">                continue
</span><span class="hit">            print(&#39;            . %s&#39; % func)
</span><span class="hit">            if func == &#39;closefiles&#39;:
</span><span class="hit">                args = &#39;self&#39;, &#39;&#39;
</span><span class="noop">            else:
</span><span class="hit">                args = &#39;self, int idx&#39;, &#39;idx&#39;
</span><span class="hit">            lines.add(1, &#39;cpdef inline void %s(%s):&#39; % (func, args[0]))
</span><span class="hit">            for (name, subseqs) in self.model.sequences:
</span><span class="hit">                if func == &#39;loaddata&#39;:
</span><span class="hit">                    applyfuncs = (&#39;inputs&#39;,)
</span><span class="hit">                elif func == &#39;savedata&#39;:
</span><span class="hit">                     applyfuncs = (&#39;fluxes&#39;, &#39;states&#39;)
</span><span class="noop">                else:
</span><span class="hit">                    applyfuncs = (&#39;inputs&#39;, &#39;fluxes&#39;, &#39;states&#39;)
</span><span class="hit">                if name in applyfuncs:
</span><span class="hit">                    lines.add(2, &#39;self.%s.%s(%s)&#39; % (name, func, args[1]))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def new2old(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            print(&#39;                . new2old&#39;)
</span><span class="hit">            lines.add(1 ,&#39;cpdef inline void new2old(self):&#39;)
</span><span class="hit">            lines.add(2 ,&#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">            for (name, seq) in sorted(self.model.sequences.states):
</span><span class="hit">                if seq.NDIM == 0:
</span><span class="hit">                    lines.add(2, &#39;self.old_states.%s = self.new_states.%s&#39;
</span><span class="noop">                                 % (2*(name,)))
</span><span class="noop">                else:
</span><span class="hit">                    indexing = &#39;&#39;
</span><span class="hit">                    for idx in range(seq.NDIM):
</span><span class="hit">                        lines.add(2+idx ,
</span><span class="noop">                                  &#39;for jdx%d in range(self.states._%s_length_%d):&#39;
</span><span class="noop">                                  % (idx, name, idx))
</span><span class="hit">                        indexing += &#39;jdx%d,&#39; % idx
</span><span class="hit">                    indexing = indexing[:-1]
</span><span class="hit">                    lines.add(2+seq.NDIM,&#39;self.old_states.%s[%s] = self.new_states.%s[%s]&#39;
</span><span class="noop">                                         % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def listofmodeluserfunctions(self):
</span><span class="noop">        &#34;&#34;&#34;User functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = []
</span><span class="hit">        for (name, member) in vars(self.model.__class__).items():
</span><span class="hit">            if (inspect.isfunction(member) and
</span><span class="noop">                    (name not in  (&#39;run&#39;, &#39;new2old&#39;)) and
</span><span class="noop">                    (&#39;fastaccess&#39; in inspect.getsource(member))):
</span><span class="hit">                lines.append((name, member))
</span><span class="hit">        lines.append((&#39;run&#39;, vars(self.model.__class__)[&#39;run&#39;]))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modeluserfunctions(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, func) in self.listofmodeluserfunctions:
</span><span class="hit">            print(&#39;            . %s&#39; % name)
</span><span class="hit">            funcconverter = FuncConverter(self.model, func)
</span><span class="hit">            lines.extend(funcconverter.pyxlines)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FuncConverter(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, model, func):
</span><span class="hit">        self.model = model
</span><span class="hit">        self.func = func
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def funcname(self):
</span><span class="miss">        return self.func.func_name
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def argnames(self):
</span><span class="miss">        return inspect.getargs(self.func.__code__)[0]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def varnames(self):
</span><span class="hit">        return self.func.__code__.co_varnames
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def locnames(self):
</span><span class="miss">        return [vn for vn in self.varnames if vn not in self.argnames]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def sourcelines(self):
</span><span class="miss">        return Lines(*inspect.getsourcelines(self.func)[0])
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def collectornames(self):
</span><span class="hit">        names = []
</span><span class="hit">        for things in (self.model.parameters, self.model.sequences):
</span><span class="hit">            for (name, thing) in things:
</span><span class="hit">                if name[:3] in self.varnames:
</span><span class="hit">                    names.append(name)
</span><span class="hit">        if &#39;old&#39; in self.varnames:
</span><span class="hit">            names.append(&#39;old_states&#39;)
</span><span class="hit">        if &#39;new&#39; in self.varnames:
</span><span class="hit">            names.append(&#39;new_states&#39;)
</span><span class="hit">        return names
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def collectorshortcuts(self):
</span><span class="hit">        return [name[:3] for name in self.collectornames]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedvarnames(self):
</span><span class="hit">        return [name for name in self.varnames
</span><span class="noop">                if name not in (self.collectorshortcuts + [&#39;self&#39;])]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedarguments(self):
</span><span class="hit">        defline = self.cleanlines[0]
</span><span class="hit">        return [name for name in self.untypedvarnames
</span><span class="noop">                if ((&#39;, %s,&#39; % name in defline) or
</span><span class="noop">                    (&#39;, %s)&#39; % name in defline))]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedinternalvarnames(self):
</span><span class="hit">        return [name for name in self.untypedvarnames if
</span><span class="noop">                name not in self.untypedarguments]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cleanlines(self):
</span><span class="noop">        &#34;&#34;&#34;Cleaned code lines.
</span><span class="noop">
</span><span class="noop">        Implemented cleanups:
</span><span class="noop">          * remove docstrings
</span><span class="noop">          * remove comments
</span><span class="noop">          * remove empty lines
</span><span class="noop">          * replace `modelutils` with nothing
</span><span class="noop">          * remove complete lines containing `fastaccess`
</span><span class="noop">          * replace shortcuts with complete references
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        code = inspect.getsource(self.func)
</span><span class="hit">        code = &#39;\n&#39;.join(code.split(&#39;&#34;&#34;&#34;&#39;)[::2])
</span><span class="hit">        code = code.replace(&#39;modelutils.&#39;, &#39;&#39;)
</span><span class="hit">        for (name, shortcut) in zip(self.collectornames,
</span><span class="noop">                                    self.collectorshortcuts):
</span><span class="hit">            code = code.replace(&#39;%s.&#39; % shortcut, &#39;self.%s.&#39; % name)
</span><span class="hit">        lines = code.splitlines()
</span><span class="hit">        lines = [l.split(&#39;#&#39;)[0] for l in lines]
</span><span class="hit">        lines = [l for l in lines  if not &#39;fastaccess&#39; in l]
</span><span class="hit">        lines = [l.rstrip() for l in lines if l.rstrip()]
</span><span class="hit">        return Lines(*lines)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyxlines(self):
</span><span class="noop">        &#34;&#34;&#34;Cython code lines.
</span><span class="noop">
</span><span class="noop">        Assumptions:
</span><span class="noop">          * Function shall be inlined
</span><span class="noop">          * Function returns nothing
</span><span class="noop">          * Function arguments are of type `int` (except self)
</span><span class="noop">          * Local variables are of type `int`
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = self.cleanlines
</span><span class="hit">        lines[0] = lines[0].replace(&#39;def &#39;, &#39;cpdef inline void &#39;)
</span><span class="hit">        for name in self.untypedarguments:
</span><span class="hit">            lines[0] = lines[0].replace(&#39;, %s &#39; % name, &#39;, int %s &#39; % name)
</span><span class="hit">            lines[0] = lines[0].replace(&#39;, %s)&#39; % name, &#39;, int %s)&#39; % name)
</span><span class="hit">        if self.untypedinternalvarnames:
</span><span class="hit">            lines.insert(1, &#39;        cdef int &#39; +
</span><span class="noop">                            &#39;, &#39;.join(self.untypedinternalvarnames))
</span><span class="hit">        return Lines(*lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def exp(double):
</span><span class="noop">    &#34;&#34;&#34;Cython wrapper for numpys exp function applied on a single float.&#34;&#34;&#34;
</span><span class="hit">    return numpy.exp(double)
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">#
</span><span class="noop"># HydPy documentation build configuration file, created by
</span><span class="noop"># sphinx-quickstart on Thu Jun 09 14:33:31 2016.
</span><span class="noop">#
</span><span class="noop"># This file is execfile()d with the current directory set to its containing dir.
</span><span class="noop">#
</span><span class="noop"># Note that not all possible configuration values are present in this
</span><span class="noop"># autogenerated file.
</span><span class="noop">#
</span><span class="noop"># All configuration values have a default; values that are commented out
</span><span class="noop"># serve to show the default.
</span><span class="noop">
</span><span class="hit">import sys, os
</span><span class="noop">
</span><span class="noop"># If extensions (or modules to document with autodoc) are in another directory,
</span><span class="noop"># add these directories to sys.path here. If the directory is relative to the
</span><span class="noop"># documentation root, use os.path.abspath to make it absolute, like shown here.
</span><span class="hit">sys.path.insert(0, os.path.abspath(&#39;..\\&#39;))
</span><span class="noop">
</span><span class="noop"># -- General configuration -----------------------------------------------------
</span><span class="noop">
</span><span class="noop"># If your documentation needs a minimal Sphinx version, state it here.
</span><span class="noop">#needs_sphinx = &#39;1.0&#39;
</span><span class="noop">
</span><span class="noop"># Add any Sphinx extension module names here, as strings. They can be extensions
</span><span class="noop"># coming with Sphinx (named &#39;sphinx.ext.*&#39;) or your custom ones.
</span><span class="hit">extensions = [&#39;sphinx.ext.autodoc&#39;,
</span><span class="noop">              &#39;sphinx.ext.napoleon&#39;,
</span><span class="noop">              &#39;sphinx.ext.intersphinx&#39;,
</span><span class="noop">              &#39;sphinx.ext.viewcode&#39;,
</span><span class="noop">              &#39;sphinx.ext.inheritance_diagram&#39;,
</span><span class="noop">              &#39;sphinx.ext.mathjax&#39;]
</span><span class="noop">
</span><span class="hit">autoclass_content = &#39;class&#39;
</span><span class="hit">autodoc_default_flags = [&#39;members&#39;, &#39;undoc-members&#39;]
</span><span class="hit">autodoc_member_order = &#39;bysource&#39;
</span><span class="noop">
</span><span class="noop"># Napoleon settings
</span><span class="hit">napoleon_google_docstring = False
</span><span class="hit">napoleon_numpy_docstring = False
</span><span class="hit">napoleon_include_private_with_doc = False
</span><span class="hit">napoleon_include_special_with_doc = False
</span><span class="hit">napoleon_use_admonition_for_examples = False
</span><span class="hit">napoleon_use_admonition_for_notes = False
</span><span class="hit">napoleon_use_admonition_for_references = False
</span><span class="hit">napoleon_use_ivar = False
</span><span class="hit">napoleon_use_param = False
</span><span class="hit">napoleon_use_rtype = False
</span><span class="noop">
</span><span class="hit">intersphinx_mapping = {&#39;python&#39;: (&#39;https://docs.python.org/2.7&#39;, None)}
</span><span class="noop">
</span><span class="noop"># Add any paths that contain templates here, relative to this directory.
</span><span class="hit">templates_path = [&#39;_templates&#39;]
</span><span class="noop">
</span><span class="noop"># The suffix of source filenames.
</span><span class="hit">source_suffix = &#39;.rst&#39;
</span><span class="noop">
</span><span class="noop"># The encoding of source files.
</span><span class="noop">#source_encoding = &#39;utf-8-sig&#39;
</span><span class="noop">
</span><span class="noop"># The master toctree document.
</span><span class="hit">master_doc = &#39;index&#39;
</span><span class="noop">
</span><span class="noop"># General information about the project.
</span><span class="hit">project = u&#39;HydPy&#39;
</span><span class="hit">copyright = u&#39;2017, Christoph Tyralla&#39;
</span><span class="noop">
</span><span class="noop"># The version info for the project you&#39;re documenting, acts as replacement for
</span><span class="noop"># |version| and |release|, also used in various other places throughout the
</span><span class="noop"># built documents.
</span><span class="noop">#
</span><span class="noop"># The short X.Y version.
</span><span class="hit">version = &#39;2.0&#39;
</span><span class="noop"># The full version, including alpha/beta/rc tags.
</span><span class="hit">release = &#39;2.0.0&#39;
</span><span class="noop">
</span><span class="noop"># The language for content autogenerated by Sphinx. Refer to documentation
</span><span class="noop"># for a list of supported languages.
</span><span class="noop">#language = None
</span><span class="noop">
</span><span class="noop"># There are two options for replacing |today|: either, you set today to some
</span><span class="noop"># non-false value, then it is used:
</span><span class="noop">#today = &#39;&#39;
</span><span class="noop"># Else, today_fmt is used as the format for a strftime call.
</span><span class="noop">#today_fmt = &#39;%B %d, %Y&#39;
</span><span class="noop">
</span><span class="noop"># List of patterns, relative to source directory, that match files and
</span><span class="noop"># directories to ignore when looking for source files.
</span><span class="hit">exclude_patterns = [&#39;_build&#39;]
</span><span class="noop">
</span><span class="noop"># The reST default role (used for this markup: `text`) to use for all documents.
</span><span class="noop">#default_role = None
</span><span class="noop">
</span><span class="noop"># If true, &#39;()&#39; will be appended to :func: etc. cross-reference text.
</span><span class="hit">add_function_parentheses = True
</span><span class="noop">
</span><span class="noop"># If true, the current module name will be prepended to all description
</span><span class="noop"># unit titles (such as .. function::).
</span><span class="noop">#add_module_names = True
</span><span class="noop">
</span><span class="noop"># If true, sectionauthor and moduleauthor directives will be shown in the
</span><span class="noop"># output. They are ignored by default.
</span><span class="noop">#show_authors = False
</span><span class="noop">
</span><span class="noop"># The name of the Pygments (syntax highlighting) style to use.
</span><span class="hit">pygments_style = &#39;sphinx&#39;
</span><span class="noop">
</span><span class="noop"># A list of ignored prefixes for module index sorting.
</span><span class="noop">#modindex_common_prefix = []
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for HTML output ---------------------------------------------------
</span><span class="noop">
</span><span class="noop"># The theme to use for HTML and HTML Help pages.  See the documentation for
</span><span class="noop"># a list of builtin themes.
</span><span class="hit">html_theme = &#39;default&#39;
</span><span class="noop">
</span><span class="noop"># Theme options are theme-specific and customize the look and feel of a theme
</span><span class="noop"># further.  For a list of options available for each theme, see the
</span><span class="noop"># documentation.
</span><span class="hit">html_theme_options = {&#39;stickysidebar&#39;: True}
</span><span class="noop">
</span><span class="noop"># Add any paths that contain custom themes here, relative to this directory.
</span><span class="noop">#html_theme_path = []
</span><span class="noop">
</span><span class="noop"># The name for this set of Sphinx documents.  If None, it defaults to
</span><span class="noop"># &#34;&lt;project&gt; v&lt;release&gt; documentation&#34;.
</span><span class="noop">#html_title = None
</span><span class="noop">
</span><span class="noop"># A shorter title for the navigation bar.  Default is the same as html_title.
</span><span class="noop">#html_short_title = None
</span><span class="noop">
</span><span class="noop"># The name of an image file (relative to this directory) to place at the top
</span><span class="noop"># of the sidebar.
</span><span class="noop">#html_logo = None
</span><span class="noop">
</span><span class="noop"># The name of an image file (within the static path) to use as favicon of the
</span><span class="noop"># docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
</span><span class="noop"># pixels large.
</span><span class="noop">#html_favicon = None
</span><span class="noop">
</span><span class="noop"># Add any paths that contain custom static files (such as style sheets) here,
</span><span class="noop"># relative to this directory. They are copied after the builtin static files,
</span><span class="noop"># so a file named &#34;default.css&#34; will overwrite the builtin &#34;default.css&#34;.
</span><span class="hit">html_static_path = []
</span><span class="noop">
</span><span class="noop"># If not &#39;&#39;, a &#39;Last updated on:&#39; timestamp is inserted at every page bottom,
</span><span class="noop"># using the given strftime format.
</span><span class="noop">#html_last_updated_fmt = &#39;%b %d, %Y&#39;
</span><span class="noop">
</span><span class="noop"># If true, SmartyPants will be used to convert quotes and dashes to
</span><span class="noop"># typographically correct entities.
</span><span class="noop">#html_use_smartypants = True
</span><span class="noop">
</span><span class="noop"># Custom sidebar templates, maps document names to template names.
</span><span class="noop">#html_sidebars = {}
</span><span class="noop">
</span><span class="noop"># Additional templates that should be rendered to pages, maps page names to
</span><span class="noop"># template names.
</span><span class="noop">#html_additional_pages = {}
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#html_domain_indices = True
</span><span class="noop">
</span><span class="noop"># If false, no index is generated.
</span><span class="noop">#html_use_index = True
</span><span class="noop">
</span><span class="noop"># If true, the index is split into individual pages for each letter.
</span><span class="noop">#html_split_index = False
</span><span class="noop">
</span><span class="noop"># If true, links to the reST sources are added to the pages.
</span><span class="noop">#html_show_sourcelink = True
</span><span class="noop">
</span><span class="noop"># If true, &#34;Created using Sphinx&#34; is shown in the HTML footer. Default is True.
</span><span class="noop">#html_show_sphinx = True
</span><span class="noop">
</span><span class="noop"># If true, &#34;(C) Copyright ...&#34; is shown in the HTML footer. Default is True.
</span><span class="noop">#html_show_copyright = True
</span><span class="noop">
</span><span class="noop"># If true, an OpenSearch description file will be output, and all pages will
</span><span class="noop"># contain a &lt;link&gt; tag referring to it.  The value of this option must be the
</span><span class="noop"># base URL from which the finished HTML is served.
</span><span class="noop">#html_use_opensearch = &#39;&#39;
</span><span class="noop">
</span><span class="noop"># This is the file name suffix for HTML files (e.g. &#34;.xhtml&#34;).
</span><span class="noop">#html_file_suffix = None
</span><span class="noop">
</span><span class="noop"># Output file base name for HTML help builder.
</span><span class="hit">htmlhelp_basename = &#39;HydPydoc&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for LaTeX output --------------------------------------------------
</span><span class="noop">
</span><span class="hit">latex_elements = {
</span><span class="noop"># The paper size (&#39;letterpaper&#39; or &#39;a4paper&#39;).
</span><span class="noop">#&#39;papersize&#39;: &#39;letterpaper&#39;,
</span><span class="noop">
</span><span class="noop"># The font size (&#39;10pt&#39;, &#39;11pt&#39; or &#39;12pt&#39;).
</span><span class="noop">#&#39;pointsize&#39;: &#39;10pt&#39;,
</span><span class="noop">
</span><span class="noop"># Additional stuff for the LaTeX preamble.
</span><span class="noop">#&#39;preamble&#39;: &#39;&#39;,
</span><span class="noop">}
</span><span class="noop">
</span><span class="noop"># Grouping the document tree into LaTeX files. List of tuples
</span><span class="noop"># (source start file, target name, title, author, documentclass [howto/manual]).
</span><span class="hit">latex_documents = [
</span><span class="noop">  (&#39;index&#39;, &#39;HydPy.tex&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">   u&#39;Christoph Tyralla&#39;, &#39;manual&#39;),
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># The name of an image file (relative to this directory) to place at the top of
</span><span class="noop"># the title page.
</span><span class="noop">#latex_logo = None
</span><span class="noop">
</span><span class="noop"># For &#34;manual&#34; documents, if this is true, then toplevel headings are parts,
</span><span class="noop"># not chapters.
</span><span class="noop">#latex_use_parts = False
</span><span class="noop">
</span><span class="noop"># If true, show page references after internal links.
</span><span class="noop">#latex_show_pagerefs = False
</span><span class="noop">
</span><span class="noop"># If true, show URL addresses after external links.
</span><span class="noop">#latex_show_urls = False
</span><span class="noop">
</span><span class="noop"># Documents to append as an appendix to all manuals.
</span><span class="noop">#latex_appendices = []
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#latex_domain_indices = True
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for manual page output --------------------------------------------
</span><span class="noop">
</span><span class="noop"># One entry per manual page. List of tuples
</span><span class="noop"># (source start file, name, description, authors, manual section).
</span><span class="hit">man_pages = [
</span><span class="noop">    (&#39;index&#39;, &#39;hydpy&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">     [u&#39;Christoph Tyralla&#39;], 1)
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># If true, show URL addresses after external links.
</span><span class="noop">#man_show_urls = False
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for Texinfo output ------------------------------------------------
</span><span class="noop">
</span><span class="noop"># Grouping the document tree into Texinfo files. List of tuples
</span><span class="noop"># (source start file, target name, title, author,
</span><span class="noop">#  dir menu entry, description, category)
</span><span class="hit">texinfo_documents = [
</span><span class="noop">  (&#39;index&#39;, &#39;HydPy&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">   u&#39;Christoph Tyralla&#39;, &#39;HydPy&#39;, &#39;One line description of project.&#39;,
</span><span class="noop">   &#39;Miscellaneous&#39;),
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># Documents to append as an appendix to all manuals.
</span><span class="noop">#texinfo_appendices = []
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#texinfo_domain_indices = True
</span><span class="noop">
</span><span class="noop"># How to display URL addresses: &#39;footnote&#39;, &#39;no&#39;, or &#39;inline&#39;.
</span><span class="noop">#texinfo_show_urls = &#39;footnote&#39;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;Christoph Tyralla, 6 February 2017.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific...
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy import pub
</span><span class="noop"># ...and load the required `magic` functions into the local namespace.
</span><span class="hit">from hydpy.core.magictools import parameterstep
</span><span class="hit">from hydpy.core.magictools import simulationstep
</span><span class="hit">from hydpy.core.magictools import controlcheck
</span><span class="hit">from hydpy.core.magictools import Tester
</span><span class="hit">from hydpy.cythons.modelutils import Cythonizer
</span><span class="noop">
</span><span class="noop">###############################################################################
</span><span class="noop"># Model
</span><span class="noop">###############################################################################
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Branch model.
</span><span class="noop">
</span><span class="noop">    Additional attribute:
</span><span class="noop">      * nodenames (:class:`list`): Names of the outlet node names, the
</span><span class="noop">        actual model shall be connected to.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        modeltools.Model.__init__(self)
</span><span class="hit">        self.nodenames = []
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="noop">        &#34;&#34;&#34;Connect the :class:`~hydpy.core.sequencetools.LinkSequence`
</span><span class="noop">        instances handled by the actual model to the
</span><span class="noop">        :class:`~hydpy.core.sequencetools.NodeSequence` instances
</span><span class="noop">        handled by one inlet node and multiple oulet nodes.
</span><span class="noop">
</span><span class="noop">        The HydPy-H-Branch model passes multiple output values to different
</span><span class="noop">        outlet nodes.  This requires additional information regarding the
</span><span class="noop">        `direction` of each output value.  Therefore, node names are used
</span><span class="noop">        as keywords.  Assume, the discharge value of `n1` shall be branched
</span><span class="noop">        to `n1a` and `n1b` via element `e1`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import *
</span><span class="noop">        &gt;&gt;&gt; n1, n1a, n1b = Node(&#39;n1&#39;), Node(&#39;n1a&#39;), Node(&#39;n1b&#39;)
</span><span class="noop">        &gt;&gt;&gt; e1 = Element(&#39;e1&#39;, inlets=n1, outlets=[n1a, n1b])
</span><span class="noop">
</span><span class="noop">        Then parameter :class:`YPoints` relates different supporting
</span><span class="noop">        points via its keyword arguments to the respective nodes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hbranch import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; xpoints(0., 3.)
</span><span class="noop">        &gt;&gt;&gt; ypoints(n1a=[0., 1.], n1b=[0., 2.])
</span><span class="noop">
</span><span class="noop">        After doing some preparations which are normally handled by
</span><span class="noop">        :ref:`HydPy` automatically ...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.element = e1
</span><span class="noop">        &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">        &gt;&gt;&gt; model.connect()
</span><span class="noop">
</span><span class="noop">        ...you can see that an example discharge value handled by the
</span><span class="noop">        :class:`~hydpy.core.devicetools.Node` instance `n1` is properly
</span><span class="noop">        divided:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n1.sequences.sim = 6.
</span><span class="noop">        &gt;&gt;&gt; model.doit(0)
</span><span class="noop">        &gt;&gt;&gt; print(n1a.sequences.sim, n1b.sequences.sim)
</span><span class="noop">        sim(2.0) sim(4.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = self.element.inlets.slaves
</span><span class="hit">        if len(nodes) == 1:
</span><span class="hit">            double = nodes[0].getdouble_via_exits()
</span><span class="hit">            self.sequences.inlets.total.setpointer(double)
</span><span class="noop">        else:
</span><span class="miss">            RuntimeError(&#39;The hbranch model must be connected to exactly one &#39;
</span><span class="noop">                         &#39;inlet node, but its parent element `%s` reverences &#39;
</span><span class="noop">                         &#39;currently %d inlet nodes.&#39;
</span><span class="noop">                         % (self.element.name, len(nodes)))
</span><span class="hit">        for (idx, name) in enumerate(self.nodenames):
</span><span class="hit">            try:
</span><span class="hit">                double = self.element.outlets[name].getdouble_via_entries()
</span><span class="miss">            except KeyError:
</span><span class="miss">                if name in devicetools.Node.registerednames():
</span><span class="miss">                    RuntimeError(&#39;The hbranch model tried to connect to the &#39;
</span><span class="noop">                                 &#39;outlet node `%s`, but its parent element &#39;
</span><span class="noop">                                 &#39;`%s` does not reference this node as an &#39;
</span><span class="noop">                                 &#39;outlet node.&#39; % (name, self.element.name))
</span><span class="noop">                else:
</span><span class="miss">                    RuntimeError(&#39;The hbranch model tried to connect to an &#39;
</span><span class="noop">                                 &#39;outlet node named `%s`, which is not &#39;
</span><span class="noop">                                 &#39;initialized yet.&#39; % name)
</span><span class="hit">            self.sequences.outlets.branched.setpointer(double, idx)
</span><span class="noop">
</span><span class="hit">    def run(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Performs the actual interpolation or extrapolation.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hbranch.XPoints`
</span><span class="noop">          :class:`~hydpy.models.hbranch.YPoints`
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hbranch.NmbPoints`
</span><span class="noop">          :class:`~hydpy.models.hbranch.NmbBranches`
</span><span class="noop">
</span><span class="noop">        Required flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hbranch.Input`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hbranch.Outputs`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            As a simple example, assume a weir directing all discharge into
</span><span class="noop">            `branch1` until the capacity limit of 2 m³/s is reached.  The
</span><span class="noop">            discharge exceeding this threshold is directed into `branch2`:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hbranch import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep()
</span><span class="noop">            &gt;&gt;&gt; xpoints(0., 2., 4.)
</span><span class="noop">            &gt;&gt;&gt; ypoints(branch1=[0., 2., 2.],
</span><span class="noop">            ...         branch2=[0., 0., 2.])
</span><span class="noop">            &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">
</span><span class="noop">            Low discharge example (linear interpolation between the first two
</span><span class="noop">            supporting point pairs):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.input = 1.
</span><span class="noop">            &gt;&gt;&gt; model.run(0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">            outputs(branch1=1.0,
</span><span class="noop">                    branch2=0.0)
</span><span class="noop">
</span><span class="noop">            Medium discharge example (linear interpolation between the second
</span><span class="noop">            two supporting point pairs):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.input = 3.
</span><span class="noop">            &gt;&gt;&gt; model.run(0)
</span><span class="noop">            &gt;&gt;&gt; print(fluxes.outputs)
</span><span class="noop">            outputs(branch1=2.0,
</span><span class="noop">                    branch2=1.0)
</span><span class="noop">
</span><span class="noop">            High discharge example (linear extrapolation beyond the second two
</span><span class="noop">            supporting point pairs):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.input = 5.
</span><span class="noop">            &gt;&gt;&gt; model.run(0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">            outputs(branch1=2.0,
</span><span class="noop">                    branch2=3.0)
</span><span class="noop">
</span><span class="noop">            Non-monotonous relationships and balance violations are allowed,
</span><span class="noop">            e.g.:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; xpoints(0., 2., 4., 6.)
</span><span class="noop">            &gt;&gt;&gt; ypoints(branch1=[0., 2., 0., 0.],
</span><span class="noop">            ...         branch2=[0., 0., 2., 4.])
</span><span class="noop">            &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">            &gt;&gt;&gt; fluxes.input = 7.
</span><span class="noop">            &gt;&gt;&gt; model.run(0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">            outputs(branch1=0.0,
</span><span class="noop">                    branch2=5.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="noop">        # Search for the index of the two relevant x points...
</span><span class="hit">        for pdx in range(1, der.nmbpoints):
</span><span class="hit">            if con.xpoints[pdx] &gt; flu.input:
</span><span class="hit">                break
</span><span class="noop">        # ...and use it for linear interpolation (or extrapolation).
</span><span class="hit">        for bdx in range(der.nmbbranches):
</span><span class="hit">            flu.outputs[bdx] = (
</span><span class="noop">                (flu.input-con.xpoints[pdx-1]) *
</span><span class="noop">                (con.ypoints[bdx, pdx]-con.ypoints[bdx, pdx-1]) /
</span><span class="noop">                (con.xpoints[pdx]-con.xpoints[pdx-1]) +
</span><span class="noop">                con.ypoints[bdx, pdx-1])
</span><span class="noop">
</span><span class="hit">    def updateinlets(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Updates :class:`~hydpy.models.hbranch.Input` based on
</span><span class="noop">        :class:`~hydpy.models.hbranch.Total`.&#34;&#34;&#34;
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        inl = self.sequences.inlets.fastaccess
</span><span class="hit">        flu.input = inl.total[0]
</span><span class="noop">
</span><span class="hit">    def updateoutlets(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Updates :class:`~hydpy.models.hbranch.Branched` based on
</span><span class="noop">        :class:`~hydpy.models.hbranch.Outputs`.&#34;&#34;&#34;
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        out = self.sequences.outlets.fastaccess
</span><span class="hit">        for bdx in range(der.nmbbranches):
</span><span class="hit">            out.branched[bdx][0] += flu.outputs[bdx]
</span><span class="noop">
</span><span class="noop">###############################################################################
</span><span class="noop"># Parameter definitions
</span><span class="noop">###############################################################################
</span><span class="noop">
</span><span class="noop"># Control Parameters ##########################################################
</span><span class="noop">
</span><span class="hit">class XPoints(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Supporting points for the independent input variable [eg. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self.shape = len(args)
</span><span class="hit">        if self.shape[0] &lt; 2:
</span><span class="miss">            raise ValueError(&#39;Branching via linear interpolation requires &#39;
</span><span class="noop">                             &#39;at least two supporting points, but for &#39;
</span><span class="noop">                             &#39;parameter `%s` only %d are given.&#39;
</span><span class="noop">                             % (self.name, self.shape[0]))
</span><span class="hit">        parametertools.MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        if min(numpy.diff(self)) &lt;= 0.:
</span><span class="miss">            raise ValueError(&#39;The values of parameter `xpoints` must be &#39;
</span><span class="noop">                             &#39;arranged in a strictly monotnously manner, &#39;
</span><span class="noop">                             &#39;which is not the case for the given values &#39;
</span><span class="noop">                             &#39;`%s`.&#39; % &#39;, &#39;.join(str(value) for value in self))
</span><span class="noop">
</span><span class="hit">class YPoints(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Supporting points for the dependent output variables [eg. m³/s].
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The documentation on method :func:`~hydpy.models.hbranch.Model.run`
</span><span class="noop">    gives examples on how to set the values of
</span><span class="noop">    :class:`~hydpy.models.hbranch.YPoints` properly.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            self.shape = (len(kwargs), self.subpars.xpoints.shape[0])
</span><span class="miss">        except RuntimeError:
</span><span class="miss">            raise RuntimeError(&#39;The shape of parameter `ypoints` depends on &#39;
</span><span class="noop">                               &#39;the shape of parameter `xpoints`.  Make sure &#39;
</span><span class="noop">                               &#39;parameter `xpoints` is defined first (and is &#39;
</span><span class="noop">                               &#39;integrated into the hmodel as described in &#39;
</span><span class="noop">                               &#39;the documentation).&#39;)
</span><span class="hit">        branched = self.subpars.pars.model.sequences.outlets.branched
</span><span class="hit">        try:
</span><span class="hit">            branched.shape = self.shape[0]
</span><span class="hit">        except RuntimeError:
</span><span class="hit">            if branched.shape[0] != self.shape[0]:
</span><span class="miss">                raise RuntimeError(&#39;The number of branches of the hbranch &#39;
</span><span class="noop">                                   &#39;model should not be changed during run &#39;
</span><span class="noop">                                   &#39;time.  If you really need to do this, &#39;
</span><span class="noop">                                   &#39;first initialize a new `branched` &#39;
</span><span class="noop">                                   &#39;sequence and connect it to the &#39;
</span><span class="noop">                                   &#39;respective outlet nodes properly.&#39;)
</span><span class="hit">        if self.shape[0] == 0:
</span><span class="miss">            raise ValueError(&#39;No branches are defined.  Do this via keyword &#39;
</span><span class="noop">                             &#39;arguments of the same name as the related &#39;
</span><span class="noop">                             &#39;outlet node instances.&#39;)
</span><span class="hit">        self.subpars.pars.model.sequences.fluxes.outputs.shape = self.shape[0]
</span><span class="hit">        for (idx, key) in enumerate(sorted(kwargs)):
</span><span class="hit">            value = kwargs[key]
</span><span class="hit">            if ((key not in devicetools.Node.registerednames()) and
</span><span class="noop">                    (pub.timegrids is not None)):
</span><span class="miss">                raise ValueError(&#39;Node `%s` does not exist so far.  Hence it &#39;
</span><span class="noop">                                 &#39;is not possible to branch to it.&#39; % key)
</span><span class="hit">            try:
</span><span class="hit">                self[idx] = value
</span><span class="miss">            except ValueError:
</span><span class="miss">                if self.shape[1] != len(value):
</span><span class="miss">                    raise ValueError(&#39;Each branch requires the same number of &#39;
</span><span class="noop">                                     &#39;supporting points as given for &#39;
</span><span class="noop">                                     &#39;parameter `xpoints`, which is %d.  But &#39;
</span><span class="noop">                                     &#39;for branch `%s` %d are given.&#39;
</span><span class="noop">                                     % (self.shape[1], key, len(value)))
</span><span class="noop">                else:
</span><span class="miss">                    message = &#39;The affected keyword argument is `%s`&#39; % key
</span><span class="miss">                    objecttools.augmentexcmessage(suffix=message)
</span><span class="hit">            setattr(self, key, self[idx])
</span><span class="hit">            self.subpars.pars.model.nodenames.append(key)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        lines = self.commentrepr()
</span><span class="miss">        nodenames = self.subpars.pars.model.nodenames
</span><span class="miss">        for (idx, values) in enumerate(self):
</span><span class="miss">            line = &#39;%s=%s,&#39; % (nodenames[idx], repr(list(values)))
</span><span class="miss">            if not idx:
</span><span class="miss">                lines.append(&#39;ypoints(&#39;+line)
</span><span class="noop">            else:
</span><span class="miss">                lines.append(&#39;        &#39;+line)
</span><span class="miss">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hbranch, directly defined by the user.
</span><span class="noop">
</span><span class="noop">    Note that the number of supporting points handled parameter
</span><span class="noop">    :class:`~hydpy.models.hbranch.XPoints` and
</span><span class="noop">    :class:`~hydpy.models.hbranch.YPoints` must be identical.  First
</span><span class="noop">    define the values of parameter :class:`~hydpy.models.hbranch.XPoints`,
</span><span class="noop">    then the values  of parameter :class:`~hydpy.models.hbranch.YPoints`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (XPoints, YPoints)
</span><span class="noop">
</span><span class="noop"># Derived Parameters ##########################################################
</span><span class="noop">
</span><span class="hit">class NmbBranches(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of branches [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">class NmbPoints(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of supporting points for linear interpolation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (2, None)
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hbranch, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (NmbBranches, NmbPoints)
</span><span class="noop">
</span><span class="noop"># Parameters ##################################################################
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the hbranch model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Determines the number of branches and number of supporting points
</span><span class="noop">        for convenience.&#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.nmbbranches = con.ypoints.shape[0]
</span><span class="hit">        der.nmbpoints = con.ypoints.shape[1]
</span><span class="noop">
</span><span class="noop">###############################################################################
</span><span class="noop"># Sequence Definitions
</span><span class="noop">###############################################################################
</span><span class="noop">
</span><span class="noop"># Flux Sequences ##############################################################
</span><span class="noop">
</span><span class="hit">class Input(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total input [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class Outputs(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Branched outputs [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        nodenames = self.subseqs.seqs.model.nodenames
</span><span class="hit">        lines = []
</span><span class="hit">        for (idx, value) in enumerate(self.values):
</span><span class="hit">            line = &#39;%s=%s,&#39; % (nodenames[idx], repr(value))
</span><span class="hit">            if not idx:
</span><span class="hit">                lines.append(&#39;outputs(&#39;+line)
</span><span class="noop">            else:
</span><span class="hit">                lines.append(&#39;        &#39;+line)
</span><span class="hit">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Input, Outputs)
</span><span class="noop">
</span><span class="noop"># Link Sequences ##############################################################
</span><span class="noop">
</span><span class="hit">class Total(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Total input [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Total,)
</span><span class="noop">
</span><span class="hit">class Branched(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Branched outputs [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Branched,)
</span><span class="noop">
</span><span class="noop"># Sequences ###################################################################
</span><span class="noop">
</span><span class="hit">class Sequences(sequencetools.Sequences):
</span><span class="noop">    &#34;&#34;&#34;All sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># Load the required `magic` functions into the local namespace.
</span><span class="hit">from hydpy.core.magictools import parameterstep
</span><span class="hit">from hydpy.core.magictools import simulationstep
</span><span class="hit">from hydpy.core.magictools import controlcheck
</span><span class="hit">from hydpy.core.magictools import Tester
</span><span class="hit">from hydpy.cythons.modelutils import Cythonizer
</span><span class="noop">
</span><span class="noop">###############################################################################
</span><span class="noop"># Model
</span><span class="noop">###############################################################################
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Stream model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def run(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Apply the routing equation.
</span><span class="noop">
</span><span class="noop">        Required derived parameters:
</span><span class="noop">          :class:`NmbSegments`
</span><span class="noop">          :class:`C1`
</span><span class="noop">          :class:`C2`
</span><span class="noop">          :class:`C3`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`QJoints`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`Q_{space+1,time+1} =
</span><span class="noop">          c1 \\cdot Q_{space,time+1} +
</span><span class="noop">          c2 \\cdot Q_{space,time} +
</span><span class="noop">          c3 \\cdot Q_{space+1,time}`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            Firstly, define a reach divided into 4 segments:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; derived.nmbsegments(4)
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.shape = 5
</span><span class="noop">
</span><span class="noop">            Zero damping is achieved through the following coefficients:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; derived.c1(0.)
</span><span class="noop">            &gt;&gt;&gt; derived.c2(1.)
</span><span class="noop">            &gt;&gt;&gt; derived.c3(0.)
</span><span class="noop">
</span><span class="noop">            For initialization, assume a base flow of 2m³/s:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.old = 2.
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.new = 2.
</span><span class="noop">
</span><span class="noop">            Through successive assignements of different discharge values
</span><span class="noop">            to the upper junction one can see, that these discharge values
</span><span class="noop">            are simply shifted from each junction to the respective lower
</span><span class="noop">            junction at each time step:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.qjoints[0] = 5.
</span><span class="noop">            &gt;&gt;&gt; model.run(0)
</span><span class="noop">            &gt;&gt;&gt; model.new2old()
</span><span class="noop">            &gt;&gt;&gt; states.qjoints
</span><span class="noop">            qjoints(5.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; states.qjoints[0] = 8.
</span><span class="noop">            &gt;&gt;&gt; model.run(1)
</span><span class="noop">            &gt;&gt;&gt; model.new2old()
</span><span class="noop">            &gt;&gt;&gt; states.qjoints
</span><span class="noop">            qjoints(8.0, 5.0, 2.0, 2.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; states.qjoints[0] = 6.
</span><span class="noop">            &gt;&gt;&gt; model.run(1)
</span><span class="noop">            &gt;&gt;&gt; model.new2old()
</span><span class="noop">            &gt;&gt;&gt; states.qjoints
</span><span class="noop">            qjoints(6.0, 8.0, 5.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">            With the maximum damping allowed, the values of the derived
</span><span class="noop">            parameters are:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; derived.c1(.5)
</span><span class="noop">            &gt;&gt;&gt; derived.c2(.0)
</span><span class="noop">            &gt;&gt;&gt; derived.c3(.5)
</span><span class="noop">
</span><span class="noop">            Assuming again a base flow of 2m³/s and the same input values
</span><span class="noop">            results in:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.old = 2.
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.new = 2.
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.qjoints[0] = 5.
</span><span class="noop">            &gt;&gt;&gt; model.run(0)
</span><span class="noop">            &gt;&gt;&gt; model.new2old()
</span><span class="noop">            &gt;&gt;&gt; states.qjoints
</span><span class="noop">            qjoints(5.0, 3.5, 2.75, 2.375, 2.1875)
</span><span class="noop">            &gt;&gt;&gt; states.qjoints[0] = 8.
</span><span class="noop">            &gt;&gt;&gt; model.run(1)
</span><span class="noop">            &gt;&gt;&gt; model.new2old()
</span><span class="noop">            &gt;&gt;&gt; states.qjoints
</span><span class="noop">            qjoints(8.0, 5.75, 4.25, 3.3125, 2.75)
</span><span class="noop">            &gt;&gt;&gt; states.qjoints[0] = 6.
</span><span class="noop">            &gt;&gt;&gt; model.run(1)
</span><span class="noop">            &gt;&gt;&gt; model.new2old()
</span><span class="noop">            &gt;&gt;&gt; states.qjoints
</span><span class="noop">            qjoints(6.0, 5.875, 5.0625, 4.1875, 3.46875)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        new = self.sequences.states.fastaccess_new
</span><span class="hit">        old = self.sequences.states.fastaccess_old
</span><span class="hit">        for j in range(der.nmbsegments):
</span><span class="hit">            new.qjoints[j+1] = (der.c1*new.qjoints[j] +
</span><span class="noop">                                der.c2*old.qjoints[j] +
</span><span class="noop">                                der.c3*old.qjoints[j+1])
</span><span class="noop">
</span><span class="hit">    def updateinlets(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Assign the actual value of the inlet sequence to the upper joint
</span><span class="noop">        of the subreach upstream.&#34;&#34;&#34;
</span><span class="miss">        sta = self.sequences.states.fastaccess
</span><span class="miss">        inl = self.sequences.inlets.fastaccess
</span><span class="miss">        sta.qjoints[0] = inl.q[0]
</span><span class="noop">
</span><span class="hit">    def updateoutlets(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Assing the actual value of the lower joint of of the subreach
</span><span class="noop">        downstream to the outlet sequence.&#34;&#34;&#34;
</span><span class="miss">        der = self.parameters.derived.fastaccess
</span><span class="miss">        sta = self.sequences.states.fastaccess
</span><span class="miss">        out = self.sequences.outlets.fastaccess
</span><span class="miss">        out.q[0] += sta.qjoints[der.nmbsegments]
</span><span class="noop">
</span><span class="noop">###############################################################################
</span><span class="noop"># Parameter definitions
</span><span class="noop">###############################################################################
</span><span class="noop">
</span><span class="hit">class Lag(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Time lag between inflow and outflow [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="noop">
</span><span class="hit">class Damp(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Damping of the hydrograph [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hstream, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Lag, Damp)
</span><span class="noop">
</span><span class="noop"># Derived Parameters ##########################################################
</span><span class="noop">
</span><span class="hit">class NmbSegments(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of river segments [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">class C1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;First coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., .5)
</span><span class="noop">
</span><span class="hit">class C2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Second coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class C3(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Third coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., .5)
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hstream, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (NmbSegments, C1, C2, C3)
</span><span class="noop">
</span><span class="noop"># Parameter container #########################################################
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the hstream model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Determines the values of the parameters handled by
</span><span class="noop">        :class:`DerivedParameters` based on the values of the parameters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.calc_nmbsegments()
</span><span class="miss">        self.calc_coefficients()
</span><span class="noop">
</span><span class="hit">    def calc_nmbsegments(self):
</span><span class="noop">        &#34;&#34;&#34;Determines in how many segments the whole reach needs to be
</span><span class="noop">        divided to approximate the desired lag time via integer rounding.
</span><span class="noop">        Adjusts the shape of sequence :class:`QJoints` additionally.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`Lag`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`NmbSegments`
</span><span class="noop">
</span><span class="noop">        Prepared state sequence:
</span><span class="noop">          :class:`QJoints`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            Define a lag time of 1.4 days and a simulation step size of 12
</span><span class="noop">            hours:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; lag(1.4)
</span><span class="noop">
</span><span class="noop">            Then the actual lag value for the simulation step size is 2.8
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; lag
</span><span class="noop">            lag(1.4)
</span><span class="noop">            &gt;&gt;&gt; lag.value
</span><span class="noop">            2.8
</span><span class="noop">
</span><span class="noop">            Through rounding the number of segments is determined:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbsegments()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbsegments
</span><span class="noop">            nmbsegments(3)
</span><span class="noop">
</span><span class="noop">            The number of joints is always the number of segments plus one:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.shape
</span><span class="noop">            (4,)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.nmbsegments = int(round(con.lag))
</span><span class="hit">        self.model.sequences.states.qjoints.shape = der.nmbsegments+1
</span><span class="noop">
</span><span class="hit">    def calc_coefficients(self):
</span><span class="noop">        &#34;&#34;&#34;Calculates the Muskingum coefficients.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`Damp`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`C1`
</span><span class="noop">          :class:`C2`
</span><span class="noop">          :class:`C3`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`c_1 = \\frac{Damp}{1+Damp}`\n
</span><span class="noop">          :math:`c_3 = \\frac{Damp}{1+Damp}`\n
</span><span class="noop">          :math:`c_2 = 1.-c_1-c_3`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            If no damping is required, the coeffients are:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; damp(0.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.0), c2(1.0), c3(0.0))
</span><span class="noop">
</span><span class="noop">            The strongest damping is achieved through:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; damp(1.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.5), c2(0.0), c3(0.5))
</span><span class="noop">
</span><span class="noop">            And finally an intermediate example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; damp(.25)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.2), c2(0.6), c3(0.2))
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.c1 = der.c3 = numpy.clip(con.damp/(1.+con.damp), 0., .5)
</span><span class="hit">        der.c2 = numpy.clip(1.-der.c1-der.c3, 0., 1.)
</span><span class="noop">
</span><span class="noop">###############################################################################
</span><span class="noop"># Sequence Definitions
</span><span class="noop">###############################################################################
</span><span class="noop">
</span><span class="noop"># State Sequences #############################################################
</span><span class="noop">
</span><span class="hit">class QJoints(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff at the segment junctions [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        try:
</span><span class="miss">            sequencetools.StateSequence.__call__(self, *args)
</span><span class="miss">        except BaseException:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            sequencetools.StateSequence.__call__(self, numpy.mean(args))
</span><span class="miss">            warnings.warn(&#39;Note that, due to the following problem, the&#39;
</span><span class="noop">                          &#39;affected HydPy-H-Stream model could be initialised &#39;
</span><span class="noop">                          &#39;with an averaged value only: %s&#39; % message)
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QJoints,)
</span><span class="noop">
</span><span class="noop"># Link Sequences ##############################################################
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span><span class="noop">
</span><span class="noop"># Sequence container ##########################################################
</span><span class="noop">
</span><span class="hit">class Sequences(sequencetools.Sequences):
</span><span class="noop">    &#34;&#34;&#34;All sequences of the hstream model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Constants
</span><span class="noop">---------
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_constants
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Model
</span><span class="noop">-----
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_model
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Parameters
</span><span class="noop">----------
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_parameters
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Control parameters
</span><span class="noop">..................
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_control
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Derived parameters
</span><span class="noop">..................
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_derived
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Sequences
</span><span class="noop">---------
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_sequences
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Input sequences
</span><span class="noop">...............
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_inputs
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Flux sequences
</span><span class="noop">..............
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_fluxes
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">State sequences
</span><span class="noop">...............
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_states
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Log sequences
</span><span class="noop">.............
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_logs
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Aide sequences
</span><span class="noop">..............
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_aides
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">Link sequences
</span><span class="noop">..............
</span><span class="noop">
</span><span class="noop">.. automodule:: hydpy.models.hland.hland_links
</span><span class="noop">    :members:
</span><span class="noop">    :show-inheritance:
</span><span class="noop">
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="hit">from numpy import nan
</span><span class="noop"># ...HydPy specific
</span><span class="noop"># Load the required `magic` functions into the local namespace.
</span><span class="hit">from hydpy.core.magictools import parameterstep
</span><span class="hit">from hydpy.core.magictools import simulationstep
</span><span class="hit">from hydpy.core.magictools import controlcheck
</span><span class="hit">from hydpy.core.magictools import Tester
</span><span class="hit">from hydpy.cythons.modelutils import Cythonizer
</span><span class="noop">
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, GLACIER, ILAKE
</span><span class="hit">from hydpy.models.hland.hland_parameters import Parameters
</span><span class="hit">from hydpy.models.hland.hland_control import ControlParameters
</span><span class="hit">from hydpy.models.hland.hland_derived import DerivedParameters
</span><span class="hit">from hydpy.models.hland.hland_sequences import Sequences
</span><span class="hit">from hydpy.models.hland.hland_inputs import InputSequences
</span><span class="hit">from hydpy.models.hland.hland_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.hland.hland_states import StateSequences
</span><span class="hit">from hydpy.models.hland.hland_aides import AideSequences
</span><span class="hit">from hydpy.models.hland.hland_logs import LogSequences
</span><span class="hit">from hydpy.models.hland.hland_links import OutletSequences
</span><span class="hit">from hydpy.models.hland.hland_model import Model
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="hit">class Perc(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Percolation from the upper to the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class Q0(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Perc, Q0)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-H-Land model (`hland`) allows for the subdivision of subbasins
</span><span class="noop">into zones (hydrological response units).  Some processes, e.g. interception,
</span><span class="noop">are calculated seperately for each zone.  This is why some parameters (e.g.
</span><span class="noop">the interception capacity :class:`~hydpy.models.hland.hland_control.IcMax`)
</span><span class="noop">and some sequences (e.g. the actual interception storage
</span><span class="noop">:class:`~hydpy.models.hland.hland_states.Ic`) are 1-dimensional.  Each entry
</span><span class="noop">represents the value of a different zone.
</span><span class="noop">
</span><span class="noop">In contrasts to the original HBV96 model, the HydPy-H-Land model allows for
</span><span class="noop">arbitrary definitions of zones.  Nevertheless, the original distinction
</span><span class="noop">in accordance with four different zone types is still supported.  The
</span><span class="noop">parameter :class:`~hydpy.models.hland.hland_control.ZoneType` defines,
</span><span class="noop">which entry of e.g. :class:`~hydpy.models.hland.hland_control.IcMax` is
</span><span class="noop">related to which zone type via integer values.  Note that for zones of
</span><span class="noop">type `field` and `forest`, the same equations are applied. (Usually,
</span><span class="noop">larger :class:`~hydpy.models.hland.hland_control.IcMax` values and smaller
</span><span class="noop">:class:`~hydpy.models.hland.hland_control.CFMax` are assigned to `forest`
</span><span class="noop">zones due to their higher leaf area index and the associated decrease in
</span><span class="noop">solar radiation.) On the contrary, zones of type `glacier` and `ilake` are
</span><span class="noop">partly connected to different process equations.
</span><span class="noop">
</span><span class="noop">For comprehensibility, this module introduces the relevant integer constants.
</span><span class="noop">Through performing a wildcard import
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">
</span><span class="noop">these are available in your local namespace:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; FIELD, FOREST, GLACIER, ILAKE
</span><span class="noop">(1, 2, 3, 4)
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">FIELD = 1
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `field`.&#34;&#34;&#34;
</span><span class="hit">FOREST = 2
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `forest.`&#34;&#34;&#34;
</span><span class="hit">GLACIER = 3
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `glacier`.&#34;&#34;&#34;
</span><span class="hit">ILAKE = 4
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `internal lake`.&#34;&#34;&#34;
</span><span class="hit">CONSTANTS = {key: value for key, value in locals().items()
</span><span class="noop">             if (key.isupper() and isinstance(value, int))}
</span><span class="hit">&#34;&#34;&#34;Dictionary containing all constants defined by HydPy-H-Land.&#34;&#34;&#34;</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland import hland_constants
</span><span class="hit">from hydpy.models.hland import hland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Area(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin area [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (1e-10, None)
</span><span class="noop">
</span><span class="hit">class NmbZones(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of zones (hydrological response units) in a subbasin [-].
</span><span class="noop">
</span><span class="noop">    Note that :class:`NmbZones` determines the length of most 1-dimensional
</span><span class="noop">    HydPy-H-Land parameters and sequences.  This required that the value of
</span><span class="noop">    the respective :class:`NmbZones` instance is set before any of the values
</span><span class="noop">    of these 1-dimensional parameters or sequences are set.  Changing the
</span><span class="noop">    value of the :class:`NmbZones` instance necessitates setting their values
</span><span class="noop">    again.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; icmax.shape
</span><span class="noop">        (5,)
</span><span class="noop">        &gt;&gt;&gt; states.ic.shape
</span><span class="noop">        (5,)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass a value to :class:`NmbZones` instances
</span><span class="noop">        within parameter control files.  Sets the shape of most 1-dimensional
</span><span class="noop">        parameter objects (except :class:`UH`) and sequence objects (except
</span><span class="noop">        :class:`QUH`) additionally.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        for (_name, subpars) in self.subpars.pars.model.parameters:
</span><span class="hit">            for (name, par) in subpars:
</span><span class="hit">                if (par.NDIM &gt; 0) and (name != &#39;uh&#39;):
</span><span class="hit">                    par.shape = self.value
</span><span class="hit">        for (_name, subseqs) in self.subpars.pars.model.sequences:
</span><span class="hit">            for (name, seq) in subseqs:
</span><span class="hit">                if (seq.NDIM &gt; 0) and (name != &#39;quh&#39;):
</span><span class="hit">                    seq.shape = self.value
</span><span class="noop">
</span><span class="hit">class ZoneType(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Type of each zone: 1 (FIELD), 2 (FOREST), 3 (GLACIER), or 4 (ILAKE).
</span><span class="noop">
</span><span class="noop">    For increasing legibility, the HydPy-H-Land constants are used for string
</span><span class="noop">    representions of :class:`ZoneType` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nmbzones(8)
</span><span class="noop">    &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, GLACIER, FOREST, FIELD)
</span><span class="noop">    &gt;&gt;&gt; zonetype.values
</span><span class="noop">    array([1, 2, 3, 4, 4, 3, 2, 1])
</span><span class="noop">    &gt;&gt;&gt; zonetype
</span><span class="noop">    zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, GLACIER, FOREST, FIELD)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (1, 4)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list which contains a string representation with zone
</span><span class="noop">        types beeing defined by the constants `FIELD`, `FOREST`...
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        invmap = {value: key for key, value in
</span><span class="noop">                  hland_constants.CONSTANTS.items()}
</span><span class="hit">        return [&#39;, &#39;.join(invmap.get(value, repr(value))
</span><span class="noop">                          for value in self.values)]
</span><span class="noop">
</span><span class="hit">class ZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Zone area [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class ZoneZ(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Zone elevation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class ZRelT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for temperature [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class ZRelP(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for precipitation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class ZRelE(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for evaporation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class PCorr(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;General precipitation correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class PCAlt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for precipitation [-1/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class RfCF(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Rainfall correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class SfCF(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Snowfall correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class TCAlt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for temperature [-1°C/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class ECorr(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;General evaporation correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class ECAlt(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for evaporation [-1/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class EPF(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Decrease in potential evaporation due to precipitation [T/mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, False, (0., None)
</span><span class="noop">
</span><span class="hit">class ETF(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Temperature factor for evaporation [1/°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class ERed(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Factor for restricting actual to potential evaporation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class TTIce(hland_parameters.MultiParameterLake):
</span><span class="noop">    &#34;&#34;&#34;Temperature threshold for lake evaporation [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class IcMax(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Maximum interception storage [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class TT(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperature threshold for snow/rain [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class TTInt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperature interval with a mixture of snow and rain [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class DTTM(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Difference between :class:`TTM` and :class:`TT` [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class CFMax(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Degree day factor for snow (on glaciers or not) [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">class GMelt(hland_parameters.MultiParameterGlacier):
</span><span class="noop">    &#34;&#34;&#34;Degree day factor for glacial ice [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">class CFR(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Refreezing factor for water stored within the snow layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class WHC(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Relative water holding capacity of the snow layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class FC(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Maximum soil moisture content (field capacity) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class LP(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Relative limit for potential evaporation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class Beta(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the soil routine [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class CFlux(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Capacity (maximum) of the capillary return flux [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">class RespArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Flag to enable the contibuting area approach [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, bool, None, (0., None)
</span><span class="noop">
</span><span class="hit">class RecStep(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of internal computation steps per simulation time step [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, True, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        self.value = int(round(self.value))
</span><span class="noop">
</span><span class="hit">class PercMax(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximum percolation rate [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">class K(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Recession coefficient of the upper zone layer [1/T/mm^alpha].
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.SingleParameter` call method, it
</span><span class="noop">    is possible to set the value of parameter :class:`K` in accordance to
</span><span class="noop">    the keyword arguments `khq`, `hq` and (optionally) `alpha`.  If `alpha`
</span><span class="noop">    is not given, the value of the respective :class:`Alpha` instance is
</span><span class="noop">    taken.  This requires the :class:`Alpha` instance to be initialized
</span><span class="noop">    beforehand.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`K = \\frac{HQ}{(HQ/KHQ)^{1+Alpha}}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When directly setting the value of parameter k, one only needs to be
</span><span class="noop">        aware of its time dependence:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">        &gt;&gt;&gt; k(2.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(2.0)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        1.0
</span><span class="noop">
</span><span class="noop">        Alternatively, one can specify the following three keyword
</span><span class="noop">        arguments directly,...
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(hq=10., khq=2., alpha=1.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(0.4)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        0.2
</span><span class="noop">
</span><span class="noop">        ...or define the value of parameter alpha beforehand:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; alpha(2.)
</span><span class="noop">        &gt;&gt;&gt; k(hq=10., khq=2.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(0.08)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        0.04
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`K` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            counter = (&#39;khq&#39; in kwargs) + (&#39;hq&#39; in kwargs)
</span><span class="hit">            if counter == 0:
</span><span class="miss">                raise ValueError(&#39;For parameter `k` a value can be set &#39;
</span><span class="noop">                                 &#39;directly or indirectly by using the &#39;
</span><span class="noop">                                 &#39;keyword arguments `khq` and `hq`.&#39;)
</span><span class="hit">            elif counter == 1:
</span><span class="miss">                raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                 &#39;parameter `k`, at least the keywords &#39;
</span><span class="noop">                                 &#39;arguments `khq` and `hq` must be given.&#39;)
</span><span class="hit">            elif counter == 2:
</span><span class="hit">                try:
</span><span class="hit">                    alpha = float(kwargs[&#39;alpha&#39;])
</span><span class="hit">                except KeyError:
</span><span class="hit">                    try:
</span><span class="hit">                        alpha = self.subpars.alpha.value
</span><span class="miss">                    except (AttributeError, RuntimeError):
</span><span class="miss">                        raise RuntimeError(&#39;For the alternative calculation &#39;
</span><span class="noop">                                           &#39;of parameter `k`, either the &#39;
</span><span class="noop">                                           &#39;keyword argument `alpha` must be &#39;
</span><span class="noop">                                           &#39;given or the value of parameter &#39;
</span><span class="noop">                                           &#39;`alpha` must be defined &#39;
</span><span class="noop">                                           &#39;beforehand.&#39;)
</span><span class="hit">                khq = float(kwargs[&#39;khq&#39;])
</span><span class="hit">                hq = float(kwargs[&#39;hq&#39;])
</span><span class="hit">                self(hq/((hq/khq)**(alpha+1.)))
</span><span class="noop">
</span><span class="hit">class Alpha(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the upper zone layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class K4(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Recession coefficient of the lower zone layer [1/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">class Gamma(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the lower zone layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class MaxBaz(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Base length of the triangle unit hydrograph [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="noop">
</span><span class="hit">class Abstr(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Abstraction of water from computed outflow [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (None, None)
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-H-Land, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Area, NmbZones, ZoneType, ZoneArea, ZoneZ, ZRelP, ZRelT,
</span><span class="noop">                   ZRelE, PCorr, PCAlt, RfCF, SfCF, TCAlt, ECorr, ECAlt, EPF,
</span><span class="noop">                   ETF, ERed, TTIce, IcMax, TT, TTInt, DTTM, CFMax, GMelt, CFR,
</span><span class="noop">                   WHC, FC, LP, Beta, PercMax, CFlux, RespArea, RecStep, Alpha,
</span><span class="noop">                   K, K4, Gamma, MaxBaz, Abstr)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland import hland_parameters
</span><span class="noop">
</span><span class="hit">class RelZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative zone area [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class RelSoilArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Total area of all `field` and `forest` zones [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class RelSoilZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative zone area of all `field` and `forest` zones [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class RelLandZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative Zone area of all `field`, `forest` and `glacier` zones [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class RelLandArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Quotient of the sum of :class:`LandZoneArea` and :class:`Area` [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class TTM(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Threshold temperature for snow melting and refreezing [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">class DT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative time step length for the upper zone layer calculations [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class NmbUH(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of the required unit hydrograph ordinates [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">class UH(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Unit hydrograph ordinates [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="hit">class QFactor(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Factor for converting mm/stepsize to m³/s.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-H-Land, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (RelZoneArea, RelSoilArea, RelSoilZoneArea, RelLandZoneArea,
</span><span class="noop">                   RelLandArea, TTM, DT, NmbUH, UH, QFactor)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TMean(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Mean subbasin temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class TC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class FracRain(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Fraction rainfall / total precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class RfC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual precipitation correction related to liquid precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class SfC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual precipitation correction related to frozen precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class PC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected precipitation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class EP(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class EPC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class EI(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Interception evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class TF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class TFWat(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Liquid throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class TFIce(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Frozen throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class GlMelt(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Glacier melt [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class MeltPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential melting of frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class Melt(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual melting of frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class RefrPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential (re)freezing of liquid water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class Refr(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual (re)freezing of liquid water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class In_(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Snow module release / soil module inflow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class R(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Effective soil response [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class EA(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual soil evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class CFPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential capillary flow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class CF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual capillary flow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class ContriArea(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Fraction of the `soil area` contributing to runoff generation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class InUZ(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Inflow to the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class Perc(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Percolation from the upper to the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class Q0(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class EL(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual lake evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">class Q1(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class InUH(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Input of the triangle unit hydrograph  [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class OutUH(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Output of the triangle unit hydrograph  [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class QT(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total model outflow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the HydPy-H-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (TMean, TC, FracRain, RfC, SfC, PC, EP, EPC, EI, TF, TFWat,
</span><span class="noop">                   TFIce, GlMelt, MeltPot, Melt, RefrPot, Refr, In_, R,
</span><span class="noop">                   EA, CFPot, CF, Perc, ContriArea, InUZ, Q0, EL, Q1,
</span><span class="noop">                   InUH, OutUH, QT)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class P(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Precipitation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class T(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class TN(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Normal temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class EPN(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Normal potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (P, T, TN, EPN)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_links.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_links.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QUH(sequencetools.LogSequence):
</span><span class="noop">    &#34;&#34;&#34;Whole outflow delayed by means of the unit hydrograph [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        try:
</span><span class="miss">            sequencetools.LogSequence.__call__(self, *args)
</span><span class="miss">        except BaseException:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            sequencetools.LogSequence.__call__(self, numpy.sum(args))
</span><span class="miss">            warnings.warn(&#39;Note that, due to the following problem, the &#39;
</span><span class="noop">                          &#39;unit-hydrograph of the affected HydPy-H-Land &#39;
</span><span class="noop">                          &#39;model could be initialised with an summed &#39;
</span><span class="noop">                          &#39;value only: %s&#39; % message)
</span><span class="noop">        # The last value must be zero, otherwise all results were biased:
</span><span class="miss">        self.values[-1] = 0.
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.LogSequences):
</span><span class="noop">    &#34;&#34;&#34;Log sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QUH,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
1596 &nbsp;
1597 &nbsp;
1598 &nbsp;
1599 &nbsp;
1600 &nbsp;
1601 &nbsp;
1602 &nbsp;
1603 &nbsp;
1604 &nbsp;
1605 &nbsp;
1606 &nbsp;
1607 &nbsp;
1608 &nbsp;
1609 &nbsp;
1610 &nbsp;
1611 &nbsp;
1612 &nbsp;
1613 &nbsp;
1614 &nbsp;
1615 &nbsp;
1616 &nbsp;
1617 &nbsp;
1618 &nbsp;
1619 &nbsp;
1620 &nbsp;
1621 &nbsp;
1622 &nbsp;
1623 &nbsp;
1624 &nbsp;
1625 &nbsp;
1626 &nbsp;
1627 &nbsp;
1628 &nbsp;
1629 &nbsp;
1630 &nbsp;
1631 &nbsp;
1632 &nbsp;
1633 &nbsp;
1634 &nbsp;
1635 &nbsp;
1636 &nbsp;
1637 &nbsp;
1638 &nbsp;
1639 &nbsp;
1640 &nbsp;
1641 &nbsp;
1642 &nbsp;
1643 &nbsp;
1644 &nbsp;
1645 &nbsp;
1646 &nbsp;
1647 &nbsp;
1648 &nbsp;
1649 &nbsp;
1650 &nbsp;
1651 &nbsp;
1652 &nbsp;
1653 &nbsp;
1654 &nbsp;
1655 &nbsp;
1656 &nbsp;
1657 &nbsp;
1658 &nbsp;
1659 &nbsp;
1660 &nbsp;
1661 &nbsp;
1662 &nbsp;
1663 &nbsp;
1664 &nbsp;
1665 &nbsp;
1666 &nbsp;
1667 &nbsp;
1668 &nbsp;
1669 &nbsp;
1670 &nbsp;
1671 &nbsp;
1672 &nbsp;
1673 &nbsp;
1674 &nbsp;
1675 &nbsp;
1676 &nbsp;
1677 &nbsp;
1678 &nbsp;
1679 &nbsp;
1680 &nbsp;
1681 &nbsp;
1682 &nbsp;
1683 &nbsp;
1684 &nbsp;
1685 &nbsp;
1686 &nbsp;
1687 &nbsp;
1688 &nbsp;
1689 &nbsp;
1690 &nbsp;
1691 &nbsp;
1692 &nbsp;
1693 &nbsp;
1694 &nbsp;
1695 &nbsp;
1696 &nbsp;
1697 &nbsp;
1698 &nbsp;
1699 &nbsp;
1700 &nbsp;
1701 &nbsp;
1702 &nbsp;
1703 &nbsp;
1704 &nbsp;
1705 &nbsp;
1706 &nbsp;
1707 &nbsp;
1708 &nbsp;
1709 &nbsp;
1710 &nbsp;
1711 &nbsp;
1712 &nbsp;
1713 &nbsp;
1714 &nbsp;
1715 &nbsp;
1716 &nbsp;
1717 &nbsp;
1718 &nbsp;
1719 &nbsp;
1720 &nbsp;
1721 &nbsp;
1722 &nbsp;
1723 &nbsp;
1724 &nbsp;
1725 &nbsp;
1726 &nbsp;
1727 &nbsp;
1728 &nbsp;
1729 &nbsp;
1730 &nbsp;
1731 &nbsp;
1732 &nbsp;
1733 &nbsp;
1734 &nbsp;
1735 &nbsp;
1736 &nbsp;
1737 &nbsp;
1738 &nbsp;
1739 &nbsp;
1740 &nbsp;
1741 &nbsp;
1742 &nbsp;
1743 &nbsp;
1744 &nbsp;
1745 &nbsp;
1746 &nbsp;
1747 &nbsp;
1748 &nbsp;
1749 &nbsp;
1750 &nbsp;
1751 &nbsp;
1752 &nbsp;
1753 &nbsp;
1754 &nbsp;
1755 &nbsp;
1756 &nbsp;
1757 &nbsp;
1758 &nbsp;
1759 &nbsp;
1760 &nbsp;
1761 &nbsp;
1762 &nbsp;
1763 &nbsp;
1764 &nbsp;
1765 &nbsp;
1766 &nbsp;
1767 &nbsp;
1768 &nbsp;
1769 &nbsp;
1770 &nbsp;
1771 &nbsp;
1772 &nbsp;
1773 &nbsp;
1774 &nbsp;
1775 &nbsp;
1776 &nbsp;
1777 &nbsp;
1778 &nbsp;
1779 &nbsp;
1780 &nbsp;
1781 &nbsp;
1782 &nbsp;
1783 &nbsp;
1784 &nbsp;
1785 &nbsp;
1786 &nbsp;
1787 &nbsp;
1788 &nbsp;
1789 &nbsp;
1790 &nbsp;
1791 &nbsp;
1792 &nbsp;
1793 &nbsp;
1794 &nbsp;
1795 &nbsp;
1796 &nbsp;
1797 &nbsp;
1798 &nbsp;
1799 &nbsp;
1800 &nbsp;
1801 &nbsp;
1802 &nbsp;
1803 &nbsp;
1804 &nbsp;
1805 &nbsp;
1806 &nbsp;
1807 &nbsp;
1808 &nbsp;
1809 &nbsp;
1810 &nbsp;
1811 &nbsp;
1812 &nbsp;
1813 &nbsp;
1814 &nbsp;
1815 &nbsp;
1816 &nbsp;
1817 &nbsp;
1818 &nbsp;
1819 &nbsp;
1820 &nbsp;
1821 &nbsp;
1822 &nbsp;
1823 &nbsp;
1824 &nbsp;
1825 &nbsp;
1826 &nbsp;
1827 &nbsp;
1828 &nbsp;
1829 &nbsp;
1830 &nbsp;
1831 &nbsp;
1832 &nbsp;
1833 &nbsp;
1834 &nbsp;
1835 &nbsp;
1836 &nbsp;
1837 &nbsp;
1838 &nbsp;
1839 &nbsp;
1840 &nbsp;
1841 &nbsp;
1842 &nbsp;
1843 &nbsp;
1844 &nbsp;
1845 &nbsp;
1846 &nbsp;
1847 &nbsp;
1848 &nbsp;
1849 &nbsp;
1850 &nbsp;
1851 &nbsp;
1852 &nbsp;
1853 &nbsp;
1854 &nbsp;
1855 &nbsp;
1856 &nbsp;
1857 &nbsp;
1858 &nbsp;
1859 &nbsp;
1860 &nbsp;
1861 &nbsp;
1862 &nbsp;
1863 &nbsp;
1864 &nbsp;
1865 &nbsp;
1866 &nbsp;
1867 &nbsp;
1868 &nbsp;
1869 &nbsp;
1870 &nbsp;
1871 &nbsp;
1872 &nbsp;
1873 &nbsp;
1874 &nbsp;
1875 &nbsp;
1876 &nbsp;
1877 &nbsp;
1878 &nbsp;
1879 &nbsp;
1880 &nbsp;
1881 &nbsp;
1882 &nbsp;
1883 &nbsp;
1884 &nbsp;
1885 &nbsp;
1886 &nbsp;
1887 &nbsp;
1888 &nbsp;
1889 &nbsp;
1890 &nbsp;
1891 &nbsp;
1892 &nbsp;
1893 &nbsp;
1894 &nbsp;
1895 &nbsp;
1896 &nbsp;
1897 &nbsp;
1898 &nbsp;
1899 &nbsp;
1900 &nbsp;
1901 &nbsp;
1902 &nbsp;
1903 &nbsp;
1904 &nbsp;
1905 &nbsp;
1906 &nbsp;
1907 &nbsp;
1908 &nbsp;
1909 &nbsp;
1910 &nbsp;
1911 &nbsp;
1912 &nbsp;
1913 &nbsp;
1914 &nbsp;
1915 &nbsp;
1916 &nbsp;
1917 &nbsp;
1918 &nbsp;
1919 &nbsp;
1920 &nbsp;
1921 &nbsp;
1922 &nbsp;
1923 &nbsp;
1924 &nbsp;
1925 &nbsp;
1926 &nbsp;
1927 &nbsp;
1928 &nbsp;
1929 &nbsp;
1930 &nbsp;
1931 &nbsp;
1932 &nbsp;
1933 &nbsp;
1934 &nbsp;
1935 &nbsp;
1936 &nbsp;
1937 &nbsp;
1938 &nbsp;
1939 &nbsp;
1940 &nbsp;
1941 &nbsp;
1942 &nbsp;
1943 &nbsp;
1944 &nbsp;
1945 &nbsp;
1946 &nbsp;
1947 &nbsp;
1948 &nbsp;
1949 &nbsp;
1950 &nbsp;
1951 &nbsp;
1952 &nbsp;
1953 &nbsp;
1954 &nbsp;
1955 &nbsp;
1956 &nbsp;
1957 &nbsp;
1958 &nbsp;
1959 &nbsp;
1960 &nbsp;
1961 &nbsp;
1962 &nbsp;
1963 &nbsp;
1964 &nbsp;
1965 &nbsp;
1966 &nbsp;
1967 &nbsp;
1968 &nbsp;
1969 &nbsp;
1970 &nbsp;
1971 &nbsp;
1972 &nbsp;
1973 &nbsp;
1974 &nbsp;
1975 &nbsp;
1976 &nbsp;
1977 &nbsp;
1978 &nbsp;
1979 &nbsp;
1980 &nbsp;
1981 &nbsp;
1982 &nbsp;
1983 &nbsp;
1984 &nbsp;
1985 &nbsp;
1986 &nbsp;
1987 &nbsp;
1988 &nbsp;
1989 &nbsp;
1990 &nbsp;
1991 &nbsp;
1992 &nbsp;
1993 &nbsp;
1994 &nbsp;
1995 &nbsp;
1996 &nbsp;
1997 &nbsp;
1998 &nbsp;
1999 &nbsp;
2000 &nbsp;
2001 &nbsp;
2002 &nbsp;
2003 &nbsp;
2004 &nbsp;
2005 &nbsp;
2006 &nbsp;
2007 &nbsp;
2008 &nbsp;
2009 &nbsp;
2010 &nbsp;
2011 &nbsp;
2012 &nbsp;
2013 &nbsp;
2014 &nbsp;
2015 &nbsp;
2016 &nbsp;
2017 &nbsp;
2018 &nbsp;
2019 &nbsp;
2020 &nbsp;
2021 &nbsp;
2022 &nbsp;
2023 &nbsp;
2024 &nbsp;
2025 &nbsp;
2026 &nbsp;
2027 &nbsp;
2028 &nbsp;
2029 &nbsp;
2030 &nbsp;
2031 &nbsp;
2032 &nbsp;
2033 &nbsp;
2034 &nbsp;
2035 &nbsp;
2036 &nbsp;
2037 &nbsp;
2038 &nbsp;
2039 &nbsp;
2040 &nbsp;
2041 &nbsp;
2042 &nbsp;
2043 &nbsp;
2044 &nbsp;
2045 &nbsp;
2046 &nbsp;
2047 &nbsp;
2048 &nbsp;
2049 &nbsp;
2050 &nbsp;
2051 &nbsp;
2052 &nbsp;
2053 &nbsp;
2054 &nbsp;
2055 &nbsp;
2056 &nbsp;
2057 &nbsp;
2058 &nbsp;
2059 &nbsp;
2060 &nbsp;
2061 &nbsp;
2062 &nbsp;
2063 &nbsp;
2064 &nbsp;
2065 &nbsp;
2066 &nbsp;
2067 &nbsp;
2068 &nbsp;
2069 &nbsp;
2070 &nbsp;
2071 &nbsp;
2072 &nbsp;
2073 &nbsp;
2074 &nbsp;
2075 &nbsp;
2076 &nbsp;
2077 &nbsp;
2078 &nbsp;
2079 &nbsp;
2080 &nbsp;
2081 &nbsp;
2082 &nbsp;
2083 &nbsp;
2084 &nbsp;
2085 &nbsp;
2086 &nbsp;
2087 &nbsp;
2088 &nbsp;
2089 &nbsp;
2090 &nbsp;
2091 &nbsp;
2092 &nbsp;
2093 &nbsp;
2094 &nbsp;
2095 &nbsp;
2096 &nbsp;
2097 &nbsp;
2098 &nbsp;
2099 &nbsp;
2100 &nbsp;
2101 &nbsp;
2102 &nbsp;
2103 &nbsp;
2104 &nbsp;
2105 &nbsp;
2106 &nbsp;
2107 &nbsp;
2108 &nbsp;
2109 &nbsp;
2110 &nbsp;
2111 &nbsp;
2112 &nbsp;
2113 &nbsp;
2114 &nbsp;
2115 &nbsp;
2116 &nbsp;
2117 &nbsp;
2118 &nbsp;
2119 &nbsp;
2120 &nbsp;
2121 &nbsp;
2122 &nbsp;
2123 &nbsp;
2124 &nbsp;
2125 &nbsp;
2126 &nbsp;
2127 &nbsp;
2128 &nbsp;
2129 &nbsp;
2130 &nbsp;
2131 &nbsp;
2132 &nbsp;
2133 &nbsp;
2134 &nbsp;
2135 &nbsp;
2136 &nbsp;
2137 &nbsp;
2138 &nbsp;
2139 &nbsp;
2140 &nbsp;
2141 &nbsp;
2142 &nbsp;
2143 &nbsp;
2144 &nbsp;
2145 &nbsp;
2146 &nbsp;
2147 &nbsp;
2148 &nbsp;
2149 &nbsp;
2150 &nbsp;
2151 &nbsp;
2152 &nbsp;
2153 &nbsp;
2154 &nbsp;
2155 &nbsp;
2156 &nbsp;
2157 &nbsp;
2158 &nbsp;
2159 &nbsp;
2160 &nbsp;
2161 &nbsp;
2162 &nbsp;
2163 &nbsp;
2164 &nbsp;
2165 &nbsp;
2166 &nbsp;
2167 &nbsp;
2168 &nbsp;
2169 &nbsp;
2170 &nbsp;
2171 &nbsp;
2172 &nbsp;
2173 &nbsp;
2174 &nbsp;
2175 &nbsp;
2176 &nbsp;
2177 &nbsp;
2178 &nbsp;
2179 &nbsp;
2180 &nbsp;
2181 &nbsp;
2182 &nbsp;
2183 &nbsp;
2184 &nbsp;
2185 &nbsp;
2186 &nbsp;
2187 &nbsp;
2188 &nbsp;
2189 &nbsp;
2190 &nbsp;
2191 &nbsp;
2192 &nbsp;
2193 &nbsp;
2194 &nbsp;
2195 &nbsp;
2196 &nbsp;
2197 &nbsp;
2198 &nbsp;
2199 &nbsp;
2200 &nbsp;
2201 &nbsp;
2202 &nbsp;
2203 &nbsp;
2204 &nbsp;
2205 &nbsp;
2206 &nbsp;
2207 &nbsp;
2208 &nbsp;
2209 &nbsp;
2210 &nbsp;
2211 &nbsp;
2212 &nbsp;
2213 &nbsp;
2214 &nbsp;
2215 &nbsp;
2216 &nbsp;
2217 &nbsp;
2218 &nbsp;
2219 &nbsp;
2220 &nbsp;
2221 &nbsp;
2222 &nbsp;
2223 &nbsp;
2224 &nbsp;
2225 &nbsp;
2226 &nbsp;
2227 &nbsp;
2228 &nbsp;
2229 &nbsp;
2230 &nbsp;
2231 &nbsp;
2232 &nbsp;
2233 &nbsp;
2234 &nbsp;
2235 &nbsp;
2236 &nbsp;
2237 &nbsp;
2238 &nbsp;
2239 &nbsp;
2240 &nbsp;
2241 &nbsp;
2242 &nbsp;
2243 &nbsp;
2244 &nbsp;
2245 &nbsp;
2246 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop"># ...model specifc
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, GLACIER, ILAKE
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Land model.
</span><span class="noop">
</span><span class="noop">    The equations of HydPy-H-Land model can be differentiated into three
</span><span class="noop">    groups.  First, input data is prepared:
</span><span class="noop">
</span><span class="noop">      * :func:`~Model.calc_tc`
</span><span class="noop">      * :func:`~Model.calc_tmean`
</span><span class="noop">      * :func:`~Model.calc_fracrain`
</span><span class="noop">      * :func:`~Model.calc_rfc_sfc`
</span><span class="noop">      * :func:`~Model.calc_pc`
</span><span class="noop">      * :func:`~Model.calc_ep`
</span><span class="noop">      * :func:`~Model.calc_epc`
</span><span class="noop">
</span><span class="noop">    Secondly, the differential equations are solved in an ad hoc manner:
</span><span class="noop">      * :func:`~Model.calc_tf_ic`
</span><span class="noop">      * :func:`~Model.calc_ei_ic`
</span><span class="noop">      * :func:`~Model.calc_sp_wc`
</span><span class="noop">      * :func:`~Model.calc_melt_sp_wc`
</span><span class="noop">      * :func:`~Model.calc_refr_sp_wc`
</span><span class="noop">      * :func:`~Model.calc_in_wc`
</span><span class="noop">      * :func:`~Model.calc_r_sm`
</span><span class="noop">      * :func:`~Model.calc_cf_sm`
</span><span class="noop">      * :func:`~Model.calc_ea_sm`
</span><span class="noop">      * :func:`~Model.calc_inuz`
</span><span class="noop">      * :func:`~Model.calc_contriarea`
</span><span class="noop">      * :func:`~Model.calc_q0_perc_uz`
</span><span class="noop">      * :func:`~Model.calc_lz`
</span><span class="noop">      * :func:`~Model.calc_el_lz`
</span><span class="noop">      * :func:`~Model.calc_q1_lz`
</span><span class="noop">
</span><span class="noop">    Thirdly, the simulated output runoff is modified:
</span><span class="noop">      * :func:`~Model.calc_inuh`
</span><span class="noop">      * :func:`~Model.calc_outuh_quh`
</span><span class="noop">      * :func:`~Model.calc_qt`
</span><span class="noop">
</span><span class="noop">    Note that all methods are performed sequentially in the :func:`~Model.run`
</span><span class="noop">    method, including the state updates --- order matters!  Let us take the
</span><span class="noop">    interception routine as an example.  First, precipitation is added to the
</span><span class="noop">    interception storage and precipitation exceeding the interception capacity
</span><span class="noop">    is routed as throughfall in method :func:`Model.calc_tf_ic`.  Then, based
</span><span class="noop">    on the already updated interception storage, interception evaporation is
</span><span class="noop">    calculated in method :func:`Model.calc_ei_ic`.  It is, as if evaporation
</span><span class="noop">    would always only occur after precipitation, but never beforehand or
</span><span class="noop">    afterwards.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def run(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Apply all hland simulation equations for the given time step.&#34;&#34;&#34;
</span><span class="noop">        # Prepare input data.
</span><span class="miss">        self.calc_tc()
</span><span class="miss">        self.calc_tmean()
</span><span class="miss">        self.calc_fracrain()
</span><span class="miss">        self.calc_rfc_sfc()
</span><span class="miss">        self.calc_pc()
</span><span class="miss">        self.calc_ep()
</span><span class="miss">        self.calc_epc()
</span><span class="noop">        # Solve process equations.
</span><span class="miss">        self.calc_tf_ic()
</span><span class="miss">        self.calc_ei_ic()
</span><span class="miss">        self.calc_sp_wc()
</span><span class="miss">        self.calc_melt_sp_wc()
</span><span class="miss">        self.calc_refr_sp_wc()
</span><span class="miss">        self.calc_in_wc()
</span><span class="miss">        self.calc_r_sm()
</span><span class="miss">        self.calc_cf_sm()
</span><span class="miss">        self.calc_ea_sm()
</span><span class="miss">        self.calc_inuz()
</span><span class="miss">        self.calc_contriarea()
</span><span class="miss">        self.calc_q0_perc_uz()
</span><span class="miss">        self.calc_lz()
</span><span class="miss">        self.calc_el_lz()
</span><span class="miss">        self.calc_q1_lz()
</span><span class="noop">        # Modify output data.
</span><span class="miss">        self.calc_inuh()
</span><span class="miss">        self.calc_outuh_quh()
</span><span class="miss">        self.calc_qt()
</span><span class="noop">
</span><span class="hit">    def calc_tc(self):
</span><span class="noop">        &#34;&#34;&#34;Adjust the measured air temperature to the altitude of the
</span><span class="noop">        individual zones.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.TCAlt`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZRelT`
</span><span class="noop">
</span><span class="noop">        Required input sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_inputs.T`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`TC = T - TCAlt \\cdot (ZoneZ-ZRelT)`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Prepare two zones, the first one lying at the reference
</span><span class="noop">            height and the second one 200 meters above:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; _ = nmbzones(2), zrelt(2.), zonez(2., 4.)
</span><span class="noop">
</span><span class="noop">            Applying the usual temperature lapse rate of 0.6°C/100m does
</span><span class="noop">            not affect the temperature of the first zone but reduces the
</span><span class="noop">            temperature of the second zone by 1.2°C:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; tcalt(.6)
</span><span class="noop">            &gt;&gt;&gt; inputs.t = 5.
</span><span class="noop">            &gt;&gt;&gt; model.calc_tc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc
</span><span class="noop">            tc(5.0, 3.8)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        inp = self.sequences.inputs.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            flu.tc[k] = inp.t-con.tcalt[k]*(con.zonez[k]-con.zrelt)
</span><span class="noop">
</span><span class="hit">    def calc_tmean(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the areal mean temperature of the subbasin.
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelZoneArea`
</span><span class="noop">
</span><span class="noop">        Required flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TMean`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Prepare sized zones, the first one beeing twice as large
</span><span class="noop">            as the second one:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea(2./3., 1./3.)
</span><span class="noop">
</span><span class="noop">            With temperature values of 5°C and 8°C  of the respective zones,
</span><span class="noop">            the mean temperature is 6°C:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 5., 8.
</span><span class="noop">            &gt;&gt;&gt; model.calc_tmean()
</span><span class="noop">            &gt;&gt;&gt; fluxes.tmean
</span><span class="noop">            tmean(6.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        flu.tmean = 0.
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            flu.tmean += der.relzonearea[k]*flu.tc[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    def calc_fracrain(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the temperature dependend fraction of (liquid) rainfall
</span><span class="noop">        and (total) precipitation.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.TT`,
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.TTInt`
</span><span class="noop">
</span><span class="noop">        Required flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.FracRain`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`FracRain = \\frac{TC-(TT-\\frac{TTInt}{2})}{TTInt}`
</span><span class="noop">
</span><span class="noop">        Restriction:
</span><span class="noop">          :math:`0 \\leq FracRain \\leq 1`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        Examles:  The threshold temperature of five
</span><span class="noop">        zones is 0°C and the corresponding temperature intervall of mixed
</span><span class="noop">        precipitation 2°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; tt(0.)
</span><span class="noop">        &gt;&gt;&gt; ttint(2.)
</span><span class="noop">
</span><span class="noop">        The fraction of rainfall is zero below -1°C, is one above 1°C and
</span><span class="noop">        increases linearly in between:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = -10., -1., -.5, 0., .5, 1., 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_fracrain()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain
</span><span class="noop">        fracrain(0.0, 0.0, 0.25, 0.5, 0.75, 1.0, 1.0)
</span><span class="noop">
</span><span class="noop">        Note the special case of a zero temperature intervall.  With a
</span><span class="noop">        actual temperature beeing equal to the threshold temperature, the
</span><span class="noop">        rainfall fraction is one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ttint(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_fracrain()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain
</span><span class="noop">        fracrain(0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if flu.tc[k] &gt;= (con.tt[k]+con.ttint[k]/2.):
</span><span class="hit">                flu.fracrain[k] = 1.
</span><span class="hit">            elif flu.tc[k] &lt;= (con.tt[k]-con.ttint[k]/2.):
</span><span class="hit">                flu.fracrain[k] = 0.
</span><span class="noop">            else:
</span><span class="hit">                flu.fracrain[k] = ((flu.tc[k]-(con.tt[k]-con.ttint[k]/2.)) /
</span><span class="noop">                                   con.ttint[k])
</span><span class="noop">
</span><span class="hit">    def calc_rfc_sfc(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the corrected fractions rainfall/snowfall and total
</span><span class="noop">        precipitation.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RfCF`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.SfCF`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`RfC = RfCF \\cdot FracRain` \n
</span><span class="noop">          :math:`SfC = SfCF \\cdot (1 - FracRain)`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Assume five zones with different temperatures and hence
</span><span class="noop">            different fractions of rainfall and total precipitation:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">            &gt;&gt;&gt; fluxes.fracrain = 0., .25, .5, .75, 1.
</span><span class="noop">
</span><span class="noop">            With no rainfall and no snowfall correction (implied by the
</span><span class="noop">            respective factors beeing one), the corrected fraction related
</span><span class="noop">            to rainfall is identical with the original fraction and the
</span><span class="noop">            corrected fraction related to snowfall behaves opposite:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; rfcf(1.)
</span><span class="noop">            &gt;&gt;&gt; sfcf(1.)
</span><span class="noop">            &gt;&gt;&gt; model.calc_rfc_sfc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.rfc
</span><span class="noop">            rfc(0.0, 0.25, 0.5, 0.75, 1.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.sfc
</span><span class="noop">            sfc(1.0, 0.75, 0.5, 0.25, 0.0)
</span><span class="noop">
</span><span class="noop">            With a negative rainfall correction of 20% and a positive
</span><span class="noop">            snowfall correction of 20 % the corrected fractions are:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; rfcf(0.8)
</span><span class="noop">            &gt;&gt;&gt; sfcf(1.2)
</span><span class="noop">            &gt;&gt;&gt; model.calc_rfc_sfc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.rfc
</span><span class="noop">            rfc(0.0, 0.2, 0.4, 0.6, 0.8)
</span><span class="noop">            &gt;&gt;&gt; fluxes.sfc
</span><span class="noop">            sfc(1.2, 0.9, 0.6, 0.3, 0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            flu.rfc[k] = flu.fracrain[k]*con.rfcf[k]
</span><span class="hit">            flu.sfc[k] = (1.-flu.fracrain[k])*con.sfcf[k]
</span><span class="noop">
</span><span class="hit">    def calc_pc(self):
</span><span class="noop">        &#34;&#34;&#34;Apply the precipitation correction factors and adjust precipitation
</span><span class="noop">        to the altitude of the individual zones.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.PCorr`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.PCAlt`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZRelP`
</span><span class="noop">
</span><span class="noop">        Required input sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_inputs.P`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Five zones are at an elevation of 200 m.  A precipitation value
</span><span class="noop">            of 5 mm has been measured at a gauge at an elevation of 300 m:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">            &gt;&gt;&gt; zrelp(2.)
</span><span class="noop">            &gt;&gt;&gt; zonez(3.)
</span><span class="noop">            &gt;&gt;&gt; inputs.p = 5.
</span><span class="noop">
</span><span class="noop">            Basic equation:
</span><span class="noop">              :math:`PC = P \\cdot PCorr
</span><span class="noop">              \\cdot (1+PCAlt \\cdot (ZoneZ-ZRelP))
</span><span class="noop">              \\cdot (RfC + SfC)`
</span><span class="noop">
</span><span class="noop">            The first four zones illustrate the individual precipitation
</span><span class="noop">            corrections due to the general precipitation correction factor
</span><span class="noop">            (first zone), the altitude correction (second zone), the rainfall
</span><span class="noop">            related correction factor (third zone), and the snowfall related
</span><span class="noop">            correction factor (fourth zone):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; pcorr(1.3, 1.0, 1.0, 1.0, 1.3)
</span><span class="noop">            &gt;&gt;&gt; pcalt(0.0, 0.1, 0.0, 0.0, 0.1)
</span><span class="noop">            &gt;&gt;&gt; fluxes.rfc = 0.5, 0.5, 0.4, 0.5, 0.4
</span><span class="noop">            &gt;&gt;&gt; fluxes.sfc = 0.5, 0.5, 0.5, 0.7, 0.7
</span><span class="noop">            &gt;&gt;&gt; model.calc_pc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.pc
</span><span class="noop">            pc(6.5, 5.5, 4.5, 6.0, 7.865)
</span><span class="noop">
</span><span class="noop">            The fifth zone illustrates the interaction between all corrections
</span><span class="noop">            --- note that each correction (except the first one) is based the
</span><span class="noop">            corrected precipitation value determined beforehand.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        inp = self.sequences.inputs.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            flu.pc[k] = inp.p*con.pcorr[k]
</span><span class="hit">            flu.pc[k] *= 1.+con.pcalt[k]*(con.zonez[k]-con.zrelp)
</span><span class="hit">            flu.pc[k] *= flu.rfc[k]+flu.sfc[k]
</span><span class="noop">
</span><span class="hit">    def calc_ep(self):
</span><span class="noop">        &#34;&#34;&#34;Adjust potential norm evaporation to the actual temperature.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ETF`
</span><span class="noop">
</span><span class="noop">        Required input sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_inputs.EPN`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_inputs.TN`
</span><span class="noop">
</span><span class="noop">        Required flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TMean`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EP`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`EP = EPN \\cdot (1 + ETF \\cdot (TMean - TN))`
</span><span class="noop">
</span><span class="noop">        Restriction:
</span><span class="noop">          :math:`0 \leq EP \leq 2 \\cdot EPN`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Assume four zones with different values of the temperature
</span><span class="noop">            related factor for the adjustment of evaporation (the
</span><span class="noop">            negative value of the first zone is not meaningful, but used
</span><span class="noop">            for illustration purporses):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">            &gt;&gt;&gt; etf(-0.5, 0.0, 0.1, 0.5)
</span><span class="noop">            &gt;&gt;&gt; inputs.tn = 20.
</span><span class="noop">            &gt;&gt;&gt; inputs.epn = 2.
</span><span class="noop">
</span><span class="noop">            With mean temperature equal to norm temperature, actual
</span><span class="noop">            (uncorrected) evaporation is equal to norm evaporation:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.tmean = 20.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ep()
</span><span class="noop">            &gt;&gt;&gt; fluxes.ep
</span><span class="noop">            ep(2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">            With mean temperature 5°C higher than norm temperature, potential
</span><span class="noop">            evaporation is increased by 1 mm for the third zone, which
</span><span class="noop">            possesses a very common adjustment factor.  For the first zone,
</span><span class="noop">            potential evaporation is 0 mm (which is the smallest value
</span><span class="noop">            allowed), and for the fourth zone it is the double value of the
</span><span class="noop">            norm evaporation (which is the largest value allowed):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.tmean  = 25.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ep()
</span><span class="noop">            &gt;&gt;&gt; fluxes.ep
</span><span class="noop">            ep(0.0, 2.0, 3.0, 4.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        inp = self.sequences.inputs.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            flu.ep[k] = inp.epn*(1.+con.etf[k]*(flu.tmean-inp.tn))
</span><span class="hit">            flu.ep[k] = min(max(flu.ep[k], 0.), 2.*inp.epn)
</span><span class="noop">
</span><span class="hit">    def calc_epc(self):
</span><span class="noop">        &#34;&#34;&#34;Apply the evaporation correction factors and adjust evaporation
</span><span class="noop">        to the altitude of the individual zones.
</span><span class="noop">
</span><span class="noop">        Calculate the areal mean of (uncorrected) potential evaporation
</span><span class="noop">        for the subbasin, adjust it to the individual zones in accordance
</span><span class="noop">        with their heights and perform some corrections, among which one
</span><span class="noop">        depends on the actual precipitation.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ECorr`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ECAlt`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZRelE`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.EPF`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EP`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`EPC = EP \\cdot ECorr
</span><span class="noop">          \\cdot (1+ECAlt \\cdot (ZoneZ-ZRelE))
</span><span class="noop">          \\cdot exp(-EPF \\cdot PC)`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Four zones are at an elevation of 200 m.  A (uncorrected)
</span><span class="noop">            potential evaporation value of 2 mm and a (corrected) precipitation
</span><span class="noop">            value of 5 mm have been determined for each zone beforehand:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">            &gt;&gt;&gt; zrele(2.)
</span><span class="noop">            &gt;&gt;&gt; zonez(3.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.ep = 2.
</span><span class="noop">            &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">
</span><span class="noop">            The first three zones  illustrate the individual evaporation
</span><span class="noop">            corrections due to the general evaporation correction factor
</span><span class="noop">            (first zone), the altitude correction (second zone), the
</span><span class="noop">            precipitation related correction (third zone):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; ecorr(1.3, 1.0, 1.0, 1.3)
</span><span class="noop">            &gt;&gt;&gt; ecalt(0.0, 0.1, 0.0, 0.1)
</span><span class="noop">            &gt;&gt;&gt; epf(0.0, 0.0, -numpy.log(.7)/10., -numpy.log(.7)/10.)
</span><span class="noop">            &gt;&gt;&gt; model.calc_epc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.epc
</span><span class="noop">            epc(2.6, 1.8, 1.4, 1.638)
</span><span class="noop">
</span><span class="noop">            The fourth zone illustrates the interaction between all corrections
</span><span class="noop">            --- note that each correction (except the first one) is based the
</span><span class="noop">            corrected evaporation value determined beforehand.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            flu.epc[k] = (flu.ep[k]*con.ecorr[k] *
</span><span class="noop">                          (1. - con.ecalt[k]*(con.zonez[k]-con.zrele)))
</span><span class="hit">            flu.epc[k] *= modelutils.exp(-con.epf[k]*flu.pc[k])
</span><span class="noop">
</span><span class="hit">    def calc_tf_ic(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate throughfall and update the interception storage
</span><span class="noop">        accordingly.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.IcMax`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.Ic`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`TF = \\Bigl \\lbrace
</span><span class="noop">          {
</span><span class="noop">          {PC \\ | \\ Ic = IcMax}
</span><span class="noop">          \\atop
</span><span class="noop">          {0 \\ | \\ Ic &lt; IcMax}
</span><span class="noop">          }`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Initialize six zones of different types.  Assume a
</span><span class="noop">            generall maximum interception capacity of 2 mm. All zones receive
</span><span class="noop">            a 0.5 mm input of precipitation:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(GLACIER, ILAKE, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; icmax(2.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.pc = .5
</span><span class="noop">            &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_tf_ic()
</span><span class="noop">
</span><span class="noop">            For glaciers (first zone) and internal lakes (second zone) the
</span><span class="noop">            interception routine does not apply.  Hence, all precipitation is
</span><span class="noop">            routed as throughfall. For fields and forests, the interception
</span><span class="noop">            routine is identical (usually, only larger capacities for forests
</span><span class="noop">            are assumed, due to their higher leaf area index).  Hence, the
</span><span class="noop">            results of the third and the second zone are equal.  The last
</span><span class="noop">            three zones demonstrate, that all precipitation is stored until
</span><span class="noop">            the interception capacity is reached; afterwards, all precepitation
</span><span class="noop">            is routed as throughfall.  Initial storage reduces the effective
</span><span class="noop">            capacity of the respective simulation step:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.ic
</span><span class="noop">            ic(0.0, 0.0, 0.5, 0.5, 1.5, 2.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.tf
</span><span class="noop">            tf(0.5, 0.5, 0.0, 0.0, 0.0, 0.5)
</span><span class="noop">
</span><span class="noop">            A zero precipitation example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.pc = 0.
</span><span class="noop">            &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_tf_ic()
</span><span class="noop">            &gt;&gt;&gt; states.ic
</span><span class="noop">            ic(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.tf
</span><span class="noop">            tf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">            A high precipitation example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">            &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_tf_ic()
</span><span class="noop">            &gt;&gt;&gt; states.ic
</span><span class="noop">            ic(0.0, 0.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.tf
</span><span class="noop">            tf(5.0, 5.0, 3.0, 3.0, 4.0, 5.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                flu.tf[k] = max(flu.pc[k]-(con.icmax[k]-sta.ic[k]), 0.)
</span><span class="hit">                sta.ic[k] += flu.pc[k]-flu.tf[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.tf[k] = flu.pc[k]
</span><span class="hit">                sta.ic[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_ei_ic(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate interception evaporation and update the interception
</span><span class="noop">        storage accordingly.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EI`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.Ic`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`EI = \\Bigl \\lbrace
</span><span class="noop">          {
</span><span class="noop">          {EPC \\ | \\ Ic &gt; 0}
</span><span class="noop">          \\atop
</span><span class="noop">          {0 \\ | \\ Ic = 0}
</span><span class="noop">          }`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Initialize six zones of different types.  For all zones
</span><span class="noop">            a (corrected) potential evaporation of 0.5 mm is given:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(GLACIER, ILAKE, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; fluxes.epc = .5
</span><span class="noop">            &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ei_ic()
</span><span class="noop">
</span><span class="noop">            For glaciers (first zone) and internal lakes (second zone) the
</span><span class="noop">            interception routine does not apply.  Hence, no interception
</span><span class="noop">            evaporation can occur.  For fields and forests, the interception
</span><span class="noop">            routine is identical (usually, only larger capacities for forests
</span><span class="noop">            are assumed, due to their higher leaf area index).  Hence, the
</span><span class="noop">            results of the third and the second zone are equal.  The last
</span><span class="noop">            three zones demonstrate, that all interception evaporation is equal
</span><span class="noop">            to potential evaporation until the interception storage is empty;
</span><span class="noop">            afterwards, interception evaporation is zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.ic
</span><span class="noop">            ic(0.0, 0.0, 0.0, 0.0, 0.5, 1.5)
</span><span class="noop">            &gt;&gt;&gt; fluxes.ei
</span><span class="noop">            ei(0.0, 0.0, 0.0, 0.0, 0.5, 0.5)
</span><span class="noop">
</span><span class="noop">            A zero evaporation example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.epc = 0.
</span><span class="noop">            &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ei_ic()
</span><span class="noop">            &gt;&gt;&gt; states.ic
</span><span class="noop">            ic(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.ei
</span><span class="noop">            ei(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">            A high evaporation example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.epc = 5.
</span><span class="noop">            &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ei_ic()
</span><span class="noop">            &gt;&gt;&gt; states.ic
</span><span class="noop">            ic(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.ei
</span><span class="noop">            ei(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                flu.ei[k] = min(flu.epc[k], sta.ic[k])
</span><span class="hit">                sta.ic[k] -= flu.ei[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.ei[k] = 0.
</span><span class="hit">                sta.ic[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    def calc_sp_wc(self):
</span><span class="noop">        &#34;&#34;&#34;Add throughfall to the snow layer.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">        Updated state sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dSP}{dt} = TF \\cdot \\frac{SfC}{SfC+RfC}` \n
</span><span class="noop">          :math:`\\frac{dWC}{dt} = TF \\cdot \\frac{RfC}{SfC+RfC}`
</span><span class="noop">
</span><span class="noop">        Exemples:
</span><span class="noop">            Consider the following setting, in which eight zones of
</span><span class="noop">            different type receive a throughfall of 10mm:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(8)
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; fluxes.tf = 10.
</span><span class="noop">            &gt;&gt;&gt; fluxes.sfc = .5, .5, .5, .5, .2, .8, 1., 4.
</span><span class="noop">            &gt;&gt;&gt; fluxes.rfc = .5, .5, .5, .5, .8, .2, 4., 1.
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 5.0, 5.0, 5.0, 2.0, 8.0, 2.0, 8.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 5.0, 5.0, 5.0, 8.0, 2.0, 8.0, 2.0)
</span><span class="noop">
</span><span class="noop">            The snow routine does not apply for internal lakes, which is why
</span><span class="noop">            both  the ice storage and the water storage of the first zone
</span><span class="noop">            remain unchanged.  The snow routine is identical for glaciers,
</span><span class="noop">            fields and forests in the current context, which is why the
</span><span class="noop">            results of the second, third, and fourth zone are equal.  The
</span><span class="noop">            last four zones illustrate that the corrected snowfall fraction
</span><span class="noop">            as well as the corrected rainfall fraction are applied in a
</span><span class="noop">            relative manner, as the total amount of water yield has been
</span><span class="noop">            corrected in the interception module already.
</span><span class="noop">
</span><span class="noop">            When both factors are zero, the neither the water nor the ice
</span><span class="noop">            content of the snow layer changes:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.sfc = 0.
</span><span class="noop">            &gt;&gt;&gt; fluxes.rfc = 0.
</span><span class="noop">            &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if con.zonetype[k] != ILAKE:
</span><span class="hit">                if (flu.rfc[k]+flu.sfc[k]) &gt; 0.:
</span><span class="hit">                    sta.wc[k] += flu.tf[k]*flu.rfc[k]/(flu.rfc[k]+flu.sfc[k])
</span><span class="hit">                    sta.sp[k] += flu.tf[k]*flu.sfc[k]/(flu.rfc[k]+flu.sfc[k])
</span><span class="noop">            else:
</span><span class="hit">                sta.wc[k] = 0.
</span><span class="hit">                sta.sp[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_melt_sp_wc(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate melting of the ice content within the snow layer and
</span><span class="noop">        update both the snow layers ice and the water content.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.CFMax`
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.Melt`
</span><span class="noop">
</span><span class="noop">        Required state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">        Updatet state sequence:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dSP}{dt} = - Melt` \n
</span><span class="noop">          :math:`\\frac{dWC}{dt} = + Melt` \n
</span><span class="noop">          :math:`Melt = min(cfmax \\cdot (TC-TTM), SP)` \n
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Six zones are initialized with the same threshold
</span><span class="noop">            temperature and degree day factor, but  with different zone types
</span><span class="noop">            and initial ice contents:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; cfmax(4.)
</span><span class="noop">            &gt;&gt;&gt; derived.ttm = 2.
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">
</span><span class="noop">            Note that the assumed length of the simulation step is only a
</span><span class="noop">            half day.  Hence the effective value of the degree day factor
</span><span class="noop">            is not 4 but 2:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; cfmax
</span><span class="noop">            cfmax(4.0)
</span><span class="noop">            &gt;&gt;&gt; cfmax.values
</span><span class="noop">            array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">            When the actual temperature is equal to the threshold
</span><span class="noop">            temperature for melting and refreezing, no melting  occurs
</span><span class="noop">            and the states remain unchanged:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_melt_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.melt
</span><span class="noop">            melt(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 10.0, 10.0, 10.0, 5.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">            The same holds true for an actual temperature lower than the
</span><span class="noop">            threshold temperature:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = -1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_melt_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.melt
</span><span class="noop">            melt(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 10.0, 10.0, 10.0, 5.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">            With an actual temperature 3°C above the threshold temperature,
</span><span class="noop">            melting can occur. Actual melting is consistent with potential
</span><span class="noop">            melting, except for the first zone, which is an internal lake,
</span><span class="noop">            and the last two zones, for which potential melting exceeds the
</span><span class="noop">            available frozen water content of the snow layer:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 5.
</span><span class="noop">            &gt;&gt;&gt; model.calc_melt_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.melt
</span><span class="noop">            melt(0.0, 6.0, 6.0, 6.0, 5.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 4.0, 4.0, 4.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 8.0, 8.0, 8.0, 7.0, 2.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if con.zonetype[k] != ILAKE:
</span><span class="hit">                if flu.tc[k] &gt; der.ttm[k]:
</span><span class="hit">                    flu.melt[k] = min(con.cfmax[k] *
</span><span class="noop">                                      (flu.tc[k]-der.ttm[k]), sta.sp[k])
</span><span class="hit">                    sta.sp[k] -= flu.melt[k]
</span><span class="hit">                    sta.wc[k] += flu.melt[k]
</span><span class="noop">                else:
</span><span class="hit">                    flu.melt[k] = 0.
</span><span class="noop">            else:
</span><span class="hit">                flu.melt[k] = 0.
</span><span class="hit">                sta.wc[k] = 0.
</span><span class="hit">                sta.sp[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_refr_sp_wc(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate refreezing of the water content within the snow layer and
</span><span class="noop">        update both the snow layers ice and the water content.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.CFMax`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.CFR`
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.Refr`
</span><span class="noop">
</span><span class="noop">        Required state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dSP}{dt} =  + Refr` \n
</span><span class="noop">          :math:`\\frac{dWC}{dt} =  - Refr` \n
</span><span class="noop">          :math:`Refr = min(cfr \\cdot cfmax \\cdot (TTM-TC), WC)`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Six zones are initialized with the same threshold
</span><span class="noop">            temperature, degree day factor and refreezing coefficient, but
</span><span class="noop">            with different zone types and initial states:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; cfmax(4.)
</span><span class="noop">            &gt;&gt;&gt; cfr(.1)
</span><span class="noop">            &gt;&gt;&gt; derived.ttm = 2.
</span><span class="noop">            &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">
</span><span class="noop">            Note that the assumed length of the simulation step is only
</span><span class="noop">            a half day.  Hence the effective value of the degree day
</span><span class="noop">            factor is not 4 but 2:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; cfmax
</span><span class="noop">            cfmax(4.0)
</span><span class="noop">            &gt;&gt;&gt; cfmax.values
</span><span class="noop">            array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">            When the actual temperature is equal to the threshold
</span><span class="noop">            temperature for melting and refreezing, neither no refreezing
</span><span class="noop">            occurs and the states remain unchanged:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_refr_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.refr
</span><span class="noop">            refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">            The same holds true for an actual temperature higher than the
</span><span class="noop">            threshold temperature:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_refr_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.refr
</span><span class="noop">            refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">            With an actual temperature 3°C above the threshold temperature,
</span><span class="noop">            only melting can occur. Actual melting is consistent with
</span><span class="noop">            potential melting, except for the first zone, which is an
</span><span class="noop">            internal lake, and the last two zones, for which potential
</span><span class="noop">            melting exceeds the available frozen water content of the
</span><span class="noop">            snow layer:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 5.
</span><span class="noop">            &gt;&gt;&gt; model.calc_refr_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.refr
</span><span class="noop">            refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">            With an actual temperature 3°C below the threshold temperature,
</span><span class="noop">            refreezing can occur. Actual refreezing is consistent with
</span><span class="noop">            potential refreezing, except for the first zone, which is an
</span><span class="noop">            internal lake, and the last two zones, for which potential
</span><span class="noop">            refreezing exceeds the available liquid water content of the
</span><span class="noop">            snow layer:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">            &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = -1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_refr_sp_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.refr
</span><span class="noop">            refr(0.0, 0.6, 0.6, 0.6, 0.5, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sp
</span><span class="noop">            sp(0.0, 2.6, 2.6, 2.6, 2.5, 2.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 0.4, 0.4, 0.4, 0.0, 0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if con.zonetype[k] != ILAKE:
</span><span class="hit">                if flu.tc[k] &lt; der.ttm[k]:
</span><span class="hit">                    flu.refr[k] = min(con.cfr[k]*con.cfmax[k] *
</span><span class="noop">                                      (der.ttm[k]-flu.tc[k]), sta.wc[k])
</span><span class="hit">                    sta.sp[k] += flu.refr[k]
</span><span class="hit">                    sta.wc[k] -= flu.refr[k]
</span><span class="noop">                else:
</span><span class="hit">                    flu.refr[k] = 0.
</span><span class="noop">
</span><span class="noop">            else:
</span><span class="hit">                flu.refr[k] = 0.
</span><span class="hit">                sta.wc[k] = 0.
</span><span class="hit">                sta.sp[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_in_wc(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the actual water release from the snow layer due to the
</span><span class="noop">        exceedance of the snow layers capacity for (liquid) water.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.WHC`
</span><span class="noop">
</span><span class="noop">        Required state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dWC}{dt} = -In` \n
</span><span class="noop">          :math:`-In = max(WC - WHC \\cdot SP, 0)`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Initialize six zones of different types and frozen water
</span><span class="noop">            contents of the snow layer and set the relative water holding
</span><span class="noop">            capacity to 20% of the respective frozen water content:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; whc(.2)
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">
</span><span class="noop">            When there is no (liquid) water content in the snow layer, no water
</span><span class="noop">            can be released:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_in_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.in_
</span><span class="noop">            in_(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">            When there is a (liquid) water content in the snow layer, the water
</span><span class="noop">            release depends on the frozen water content.  Note the special
</span><span class="noop">            cases of the first zone beeing an internal lake, for which the snow
</span><span class="noop">            routine does not apply, and of the last zone, which has no ice
</span><span class="noop">            content and thus effectively not really a snow layer:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.wc = 5.
</span><span class="noop">            &gt;&gt;&gt; model.calc_in_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.in_
</span><span class="noop">            in_(0.0, 3.0, 3.0, 3.0, 4.0, 5.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 2.0, 2.0, 2.0, 1.0, 0.0)
</span><span class="noop">
</span><span class="noop">            When the relative water holding capacity is assumed to be zero,
</span><span class="noop">            all liquid water is released:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; whc(0.)
</span><span class="noop">            &gt;&gt;&gt; states.wc = 5.
</span><span class="noop">            &gt;&gt;&gt; model.calc_in_wc()
</span><span class="noop">            &gt;&gt;&gt; fluxes.in_
</span><span class="noop">            in_(0.0, 5.0, 5.0, 5.0, 5.0, 5.0)
</span><span class="noop">            &gt;&gt;&gt; states.wc
</span><span class="noop">            wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if con.zonetype[k] != ILAKE:
</span><span class="hit">                flu.in_[k] = max(sta.wc[k]-con.whc[k]*sta.sp[k], 0.)
</span><span class="hit">                sta.wc[k] -= flu.in_[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.in_[k] = flu.tf[k]
</span><span class="hit">                sta.wc[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_glmelt_in(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate melting from glaciers which are actually not covered by
</span><span class="noop">        a snow layer and add it to the water release of the snow module.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.GMelt`
</span><span class="noop">
</span><span class="noop">        Required state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">        Required flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.GlMelt`
</span><span class="noop">
</span><span class="noop">        Updated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">
</span><span class="noop">          :math:`GlMelt = \\Bigl \\lbrace
</span><span class="noop">          {
</span><span class="noop">          {max(GMelt \\cdot (TC-TTM), 0) \\ | \\ SP = 0}
</span><span class="noop">          \\atop
</span><span class="noop">          {0 \\ | \\ SP &gt; 0}
</span><span class="noop">          }`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Seven zones are prepared, but glacier melting occurs only
</span><span class="noop">            in the fourth one, as the first three zones are no glaciers, the
</span><span class="noop">            fifth zone is covered by a snow layer and the actual temperature
</span><span class="noop">            of the last two zones is not above the threshold temperature:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, ILAKE, GLACIER, GLACIER, GLACIER, GLACIER)
</span><span class="noop">            &gt;&gt;&gt; gmelt(4.)
</span><span class="noop">            &gt;&gt;&gt; derived.ttm(2.)
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0., 0., 0., 0., .1, 0., 0.
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 3., 3., 3., 3., 3., 2., 1.
</span><span class="noop">            &gt;&gt;&gt; fluxes.in_ = 3.
</span><span class="noop">            &gt;&gt;&gt; model.calc_glmelt_in()
</span><span class="noop">            &gt;&gt;&gt; fluxes.glmelt
</span><span class="noop">            glmelt(0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.in_
</span><span class="noop">            in_(3.0, 3.0, 3.0, 5.0, 3.0, 3.0, 3.0)
</span><span class="noop">
</span><span class="noop">            Note that the assumed length of the simulation step is only
</span><span class="noop">            a half day. Hence the effective value of the degree day factor
</span><span class="noop">            is not 4 but 2:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; gmelt
</span><span class="noop">            gmelt(4.0)
</span><span class="noop">            &gt;&gt;&gt; gmelt.values
</span><span class="noop">            array([ 2.,  2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if con.zonetype[k] == GLACIER:
</span><span class="hit">                if (sta.sp[k] &lt;= 0.) and (flu.tc[k] &gt; der.ttm[k]):
</span><span class="hit">                    flu.glmelt[k] = con.gmelt[k]*(flu.tc[k]-der.ttm[k])
</span><span class="hit">                    flu.in_[k] += flu.glmelt[k]
</span><span class="noop">                else:
</span><span class="hit">                    flu.glmelt[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_r_sm(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate effective precipitation and update soil moisture.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Beta`
</span><span class="noop">
</span><span class="noop">        Required fluxes sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dSM}{dt} = IN - R` \n
</span><span class="noop">          :math:`R = IN \\cdot \\left(\\frac{SM}{FC}\\right)^{Beta}`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Initialize six zones of different types.  The field
</span><span class="noop">            capacity of all fields and forests is set to 200mm, the input
</span><span class="noop">            of each zone is 10mm:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; fc(200.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.in_ = 10.
</span><span class="noop">
</span><span class="noop">            With a common nonlinearity parameter value of 2, a relative
</span><span class="noop">            soil moisture of 50%  (zones three and four) results in a
</span><span class="noop">            discharge coefficient of 25%. For a soil completely dried
</span><span class="noop">            (zone five) or completely saturated (one six) the discharge
</span><span class="noop">            coefficient does not depend on the nonlinearity parameter and
</span><span class="noop">            is 0% and 100% respectively.  Glaciers and internal lakes also
</span><span class="noop">            always route 100% of their input as effective precipitation:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; beta(2.)
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">            &gt;&gt;&gt; model.calc_r_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.r
</span><span class="noop">            r(10.0, 10.0, 2.5, 2.5, 0.0, 10.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 107.5, 107.5, 10.0, 200.0)
</span><span class="noop">
</span><span class="noop">            Through decreasing the nonlinearity parameter, the discharge
</span><span class="noop">            coefficient increases.  A parameter value of zero leads to a
</span><span class="noop">            discharge coefficient of 100% for any soil moisture:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; beta(0.)
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">            &gt;&gt;&gt; model.calc_r_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.r
</span><span class="noop">            r(10.0, 10.0, 10.0, 10.0, 10.0, 10.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 100.0, 100.0, 0.0, 200.0)
</span><span class="noop">
</span><span class="noop">            With zero field capacity, the discharge coefficient also always
</span><span class="noop">            equates to 100%:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fc(0.)
</span><span class="noop">            &gt;&gt;&gt; beta(2.)
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_r_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.r
</span><span class="noop">            r(10.0, 10.0, 10.0, 10.0, 10.0, 10.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                if con.fc[k] &gt; 0.:
</span><span class="hit">                    flu.r[k] = flu.in_[k]*(sta.sm[k]/con.fc[k])**con.beta[k]
</span><span class="hit">                    flu.r[k] = max(flu.r[k], sta.sm[k]+flu.in_[k]-con.fc[k])
</span><span class="noop">                else:
</span><span class="hit">                    flu.r[k] = flu.in_[k]
</span><span class="hit">                sta.sm[k] += flu.in_[k]-flu.r[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.r[k] = flu.in_[k]
</span><span class="hit">                sta.sm[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_cf_sm(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate capillary flow and update soil moisture.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.CFlux`
</span><span class="noop">
</span><span class="noop">        Required fluxes sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">
</span><span class="noop">        Required state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.UZ`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.CF`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dSM}{dt} = CF` \n
</span><span class="noop">          :math:`CF = CFLUX \\cdot (1 - \\frac{SM}{FC})`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Initialize six zones of different types.  The field
</span><span class="noop">            capacity of als fields and forests is set to 200mm, the maximum
</span><span class="noop">            capillary flow rate is 4mm/d:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; fc(200.)
</span><span class="noop">            &gt;&gt;&gt; cflux(4.)
</span><span class="noop">
</span><span class="noop">            Note that the assumed length of the simulation step is only
</span><span class="noop">            a half day.  Hence the maximum capillary flow per simulation
</span><span class="noop">            step is 2 instead of 4:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; cflux
</span><span class="noop">            cflux(4.0)
</span><span class="noop">            &gt;&gt;&gt; cflux.values
</span><span class="noop">            array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">            For fields and forests, the actual capillary return flow depends
</span><span class="noop">            on the relative soil moisture deficite, if either the upper zone
</span><span class="noop">            layer provides enough water...
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.r = 0.
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">            &gt;&gt;&gt; states.uz = 20.
</span><span class="noop">            &gt;&gt;&gt; model.calc_cf_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.cf
</span><span class="noop">            cf(0.0, 0.0, 1.0, 1.0, 2.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 101.0, 101.0, 2.0, 200.0)
</span><span class="noop">
</span><span class="noop">            ...our enough effective precipitation is generated, which can be
</span><span class="noop">            rerouted directly:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; cflux(4.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.r = 10.
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">            &gt;&gt;&gt; states.uz = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_cf_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.cf
</span><span class="noop">            cf(0.0, 0.0, 1.0, 1.0, 2.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 101.0, 101.0, 2.0, 200.0)
</span><span class="noop">
</span><span class="noop">            If the upper zone layer is empty and no effective precipitation is
</span><span class="noop">            generated, capillary flow is zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; cflux(4.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.r = 0.
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">            &gt;&gt;&gt; states.uz = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_cf_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.cf
</span><span class="noop">            cf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 100.0, 100.0, 0.0, 200.0)
</span><span class="noop">
</span><span class="noop">            Here an example, where both the upper zone layer and effective
</span><span class="noop">            precipitation provide water for the capillary flow, but less then
</span><span class="noop">            the maximum flow rate times the relative soil moisture:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; cflux(4.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.r = 0.1
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">            &gt;&gt;&gt; states.uz = 0.2
</span><span class="noop">            &gt;&gt;&gt; model.calc_cf_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.cf
</span><span class="noop">            cf(0.0, 0.0, 0.3, 0.3, 0.3, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 100.3, 100.3, 0.3, 200.0)
</span><span class="noop">
</span><span class="noop">            Even unrealistic high maximum capillary flow rates do not result
</span><span class="noop">            in overfilled soils:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; cflux(1000.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.r = 200.
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">            &gt;&gt;&gt; states.uz = 200.
</span><span class="noop">            &gt;&gt;&gt; model.calc_cf_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.cf
</span><span class="noop">            cf(0.0, 0.0, 100.0, 100.0, 200.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 200.0, 200.0, 200.0, 200.0)
</span><span class="noop">
</span><span class="noop">            For (unrealistic) soils with zero field capacity, capillary flow
</span><span class="noop">            is always zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fc(0.)
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_cf_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.cf
</span><span class="noop">            cf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                if con.fc[k] &gt; 0.:
</span><span class="hit">                    flu.cf[k] = con.cflux[k]*(1.-sta.sm[k]/con.fc[k])
</span><span class="hit">                    flu.cf[k] = min(flu.cf[k], sta.uz+flu.r[k])
</span><span class="hit">                    flu.cf[k] = min(flu.cf[k], con.fc[k]-sta.sm[k])
</span><span class="noop">                else:
</span><span class="hit">                    flu.cf[k] = 0.
</span><span class="hit">                sta.sm[k] += flu.cf[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.cf[k] = 0.
</span><span class="hit">                sta.sm[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_ea_sm(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate soil evaporation and update soil moisture.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.LP`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ERed`
</span><span class="noop">
</span><span class="noop">        Required fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EI`
</span><span class="noop">
</span><span class="noop">        Required state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.EA`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dSM}{dt} = - EA` \n
</span><span class="noop">          :math:`EA_{temp} = \\biggl \\lbrace
</span><span class="noop">          {
</span><span class="noop">          {EPC \\cdot min\\left(\\frac{SM}{LP \\cdot FC}, 1\\right)
</span><span class="noop">          \\ | \\ SP = 0}
</span><span class="noop">          \\atop
</span><span class="noop">          {0 \\ | \\ SP &gt; 0}
</span><span class="noop">          }` \n
</span><span class="noop">          :math:`EA = EA_{temp} - max(ERED \\cdot (EA_{temp} + EI - EPC), 0)`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Initialize seven zones of different types.  The field capacity
</span><span class="noop">             of all fields and forests is set to 200mm, potential evaporation
</span><span class="noop">             and interception evaporation are 2mm and 1mm respectively:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; fc(200.)
</span><span class="noop">            &gt;&gt;&gt; lp(.0, .0, .5, .5, .0, .8, 1.)
</span><span class="noop">            &gt;&gt;&gt; ered(0.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.epc = 2.
</span><span class="noop">            &gt;&gt;&gt; fluxes.ei = 1.
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0.
</span><span class="noop">
</span><span class="noop">            Only fields and forests include soils; for glaciers and zones (the
</span><span class="noop">            first two zones) no soil evaporation is performed.  For fields and
</span><span class="noop">            forests, the underlying calculations are the same. In the following
</span><span class="noop">            example, the relative soil moisture is 50% in all field and forest
</span><span class="noop">            zones.  Hence, differences in soil evaporation are related to the
</span><span class="noop">            different soil evaporation parameter values only:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ea_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.ea
</span><span class="noop">            ea(0.0, 0.0, 2.0, 2.0, 2.0, 1.25, 1.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 98.0, 98.0, 98.0, 98.75, 99.0)
</span><span class="noop">
</span><span class="noop">            In the last example, evaporation values of 2mm have been calculated
</span><span class="noop">            for some zones despite the fact, that these 2mm added to the actual
</span><span class="noop">            interception evaporation of 1mm exceed potential evaporation.  This
</span><span class="noop">            behaviour can be reduced...
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">            &gt;&gt;&gt; ered(.5)
</span><span class="noop">            &gt;&gt;&gt; model.calc_ea_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.ea
</span><span class="noop">            ea(0.0, 0.0, 1.5, 1.5, 1.5, 1.125, 1.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 98.5, 98.5, 98.5, 98.875, 99.0)
</span><span class="noop">
</span><span class="noop">            ...or be completely excluded:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">            &gt;&gt;&gt; ered(1.)
</span><span class="noop">            &gt;&gt;&gt; model.calc_ea_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.ea
</span><span class="noop">            ea(0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 99.0, 99.0, 99.0, 99.0, 99.0)
</span><span class="noop">
</span><span class="noop">            Any occurence of a snow layer suppresses soil evaporation
</span><span class="noop">            completely:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sp = 0.01
</span><span class="noop">            &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ea_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.ea
</span><span class="noop">            ea(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 100.0, 100.0, 100.0, 100.0, 100.0)
</span><span class="noop">
</span><span class="noop">            For (unrealistic) soils with zero field capacity, soil evaporation
</span><span class="noop">            is always zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fc(0.)
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_ea_sm()
</span><span class="noop">            &gt;&gt;&gt; fluxes.ea
</span><span class="noop">            ea(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.sm
</span><span class="noop">            sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                if sta.sp[k] &lt;= 0.:
</span><span class="hit">                    if (con.lp[k]*con.fc[k]) &gt; 0.:
</span><span class="hit">                        flu.ea[k] = flu.epc[k]*sta.sm[k]/(con.lp[k]*con.fc[k])
</span><span class="hit">                        flu.ea[k] = min(flu.ea[k], flu.epc[k])
</span><span class="noop">                    else:
</span><span class="hit">                        flu.ea[k] = flu.epc[k]
</span><span class="hit">                    flu.ea[k] -= max(con.ered[k] *
</span><span class="noop">                                     (flu.ea[k]+flu.ei[k]-flu.epc[k]), 0.)
</span><span class="hit">                    flu.ea[k] = min(flu.ea[k], sta.sm[k])
</span><span class="noop">                else:
</span><span class="hit">                    flu.ea[k] = 0.
</span><span class="hit">                sta.sm[k] -= flu.ea[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.ea[k] = 0.
</span><span class="hit">                sta.sm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    def calc_inuz(self):
</span><span class="noop">        &#34;&#34;&#34;Accumulate the total inflow into the upper zone layer.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Required derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandZoneArea`
</span><span class="noop">
</span><span class="noop">        Required fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.CF`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.InUZ`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`InUZ = R - CF`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Initialize three zones of different relative `land sizes`
</span><span class="noop">            (area related to the total size of the subbasin except lake areas):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, ILAKE, GLACIER)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea = 2./3., 0., 1./3.
</span><span class="noop">            &gt;&gt;&gt; fluxes.r = 6., 0., 2.
</span><span class="noop">            &gt;&gt;&gt; fluxes.cf = 2., 0., 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_inuz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuz
</span><span class="noop">            inuz(3.0)
</span><span class="noop">
</span><span class="noop">            Internal lakes do not contribute to the upper zone layer.  Hence
</span><span class="noop">            for a subbasin consisting only of interal lakes a zero input
</span><span class="noop">            value would be calculated:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.calc_inuz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuz
</span><span class="noop">            inuz(0.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        flu.inuz = 0.
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if con.zonetype[k] != ILAKE:
</span><span class="hit">                flu.inuz += der.rellandzonearea[k]*(flu.r[k]-flu.cf[k])
</span><span class="noop">
</span><span class="hit">    def calc_contriarea(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the relative size of the contributing area of the whole
</span><span class="noop">        subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RespArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Beta`
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_derived.RelSoilArea`
</span><span class="noop">
</span><span class="noop">        Required state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.ContriArea`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`ContriArea = \\left( \\frac{SM}{FC} \\right)^{Beta}`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Four zones are initialized, but only the first two zones
</span><span class="noop">            of type field and forest are taken into account in the calculation
</span><span class="noop">            of the relative contributing area of the catchment (even, if also
</span><span class="noop">            glaciers contribute to the inflow of the upper zone layer):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; beta(2.)
</span><span class="noop">            &gt;&gt;&gt; fc(200.)
</span><span class="noop">            &gt;&gt;&gt; resparea(True)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea(.5)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea(1./3., 2./3., 0., 0.)
</span><span class="noop">
</span><span class="noop">            With a relative soil moisture of 100% in the whole subbasin, the
</span><span class="noop">            contributing area is also estimated as 100%,...
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sm = 200.
</span><span class="noop">            &gt;&gt;&gt; model.calc_contriarea()
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">            contriarea(1.0)
</span><span class="noop">
</span><span class="noop">            ...and relative soil moistures of 0% result in an contributing
</span><span class="noop">            area of 0%:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_contriarea()
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">            contriarea(0.0)
</span><span class="noop">
</span><span class="noop">            With the given value 2 of the nonlinearity parameter Beta, soil
</span><span class="noop">            moisture of 50% results in a contributing area estimate of 25%:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">            &gt;&gt;&gt; model.calc_contriarea()
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">            contriarea(0.25)
</span><span class="noop">
</span><span class="noop">            Setting the response area option to False,...
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; resparea(False)
</span><span class="noop">            &gt;&gt;&gt; model.calc_contriarea()
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">            contriarea(1.0)
</span><span class="noop">
</span><span class="noop">            ... setting the soil area (total area of all field and forest
</span><span class="noop">            zones in the subbasin) to zero...,
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; resparea(True)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea(0.)
</span><span class="noop">            &gt;&gt;&gt; model.calc_contriarea()
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">            contriarea(1.0)
</span><span class="noop">
</span><span class="noop">            ...or setting all field capacities to zero...
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea(.5)
</span><span class="noop">            &gt;&gt;&gt; fc(0.)
</span><span class="noop">            &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_contriarea()
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">            contriarea(1.0)
</span><span class="noop">
</span><span class="noop">            ...leads to contributing area values of 100%.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        if con.resparea and (der.relsoilarea &gt; 0.):
</span><span class="hit">            flu.contriarea = 0.
</span><span class="hit">            for k in range(con.nmbzones):
</span><span class="hit">                if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                    if con.fc[k] &gt; 0.:
</span><span class="hit">                        flu.contriarea += (der.relsoilzonearea[k]*
</span><span class="noop">                                           (sta.sm[k]/con.fc[k])**con.beta[k])
</span><span class="noop">                    else:
</span><span class="hit">                        flu.contriarea += der.relsoilzonearea[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.contriarea = 1.
</span><span class="noop">
</span><span class="hit">    def calc_q0_perc_uz(self):
</span><span class="noop">        &#34;&#34;&#34;Perform the upper zone layer routine which determines percolation
</span><span class="noop">        to the lower zone layer and the fast response of the hland model.
</span><span class="noop">        Note that the system behaviour of this method depends strongly on the
</span><span class="noop">        specifications of the options :class:`RespArea` and :class:`RecStep`.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RecStep`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.PercMax`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.K`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Alpha`
</span><span class="noop">
</span><span class="noop">        Required derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.DT`
</span><span class="noop">
</span><span class="noop">        Required fluxes sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.InUZ`
</span><span class="noop">
</span><span class="noop">        Used Aide sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_aides.Perc`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_aides.Q0`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.Perc`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.UZ`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`\\frac{dUZ}{dt} = InUZ - Perc - Q0` \n
</span><span class="noop">          :math:`Perc = PercMax \\cdot ContriArea` \n
</span><span class="noop">          :math:`Q0 = \\left( \\frac{UZ}{ContriArea} \\right)^{1+Alpha}`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            The upper zone layer routine is an exception compared to
</span><span class="noop">            the other routines of the HydPy-H-Land model, regarding its
</span><span class="noop">            consideration of numerical accuracy.  To increase the accuracy of
</span><span class="noop">            the numerical integration of the underlying ordinary differential
</span><span class="noop">            equation, each simulation step can be devided into substeps, which
</span><span class="noop">            are all solved with first order accuracy.  In the first example,
</span><span class="noop">            this option is omitted through setting the RecStep parameter to one:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; recstep(2)
</span><span class="noop">            &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">            &gt;&gt;&gt; percmax(2.)
</span><span class="noop">            &gt;&gt;&gt; alpha(1.)
</span><span class="noop">            &gt;&gt;&gt; k(2.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea = 1.
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuz = 0.
</span><span class="noop">            &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q0_perc_uz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc
</span><span class="noop">            perc(1.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0
</span><span class="noop">            q0(0.0)
</span><span class="noop">            &gt;&gt;&gt; states.uz
</span><span class="noop">            uz(0.0)
</span><span class="noop">
</span><span class="noop">            Due to the sequential calculation of the upper zone routine, the
</span><span class="noop">            upper zone storage is drained completely through percolation and
</span><span class="noop">            no water is left for fast discharge response.  By dividing the
</span><span class="noop">            simulation step in 100 substeps, the results are quite different:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; recstep(200)
</span><span class="noop">            &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">            &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q0_perc_uz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc
</span><span class="noop">            perc(0.786934)
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0
</span><span class="noop">            q0(0.213066)
</span><span class="noop">            &gt;&gt;&gt; states.uz
</span><span class="noop">            uz(0.0)
</span><span class="noop">
</span><span class="noop">            Note that the assumed length of the simulation step is only a
</span><span class="noop">            half day. Hence the effective values of the maximum percolation
</span><span class="noop">            rate and the storage coefficient is not 2 but 1:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; percmax
</span><span class="noop">            percmax(2.0)
</span><span class="noop">            &gt;&gt;&gt; k
</span><span class="noop">            k(2.0)
</span><span class="noop">            &gt;&gt;&gt; percmax.value
</span><span class="noop">            1.0
</span><span class="noop">            &gt;&gt;&gt; k.value
</span><span class="noop">            1.0
</span><span class="noop">
</span><span class="noop">            By decreasing the contributing area one decreases percolation but
</span><span class="noop">            increases fast discharge response:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.contriarea = .5
</span><span class="noop">            &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q0_perc_uz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc
</span><span class="noop">            perc(0.434108)
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0
</span><span class="noop">            q0(0.565892)
</span><span class="noop">            &gt;&gt;&gt; states.uz
</span><span class="noop">            uz(0.0)
</span><span class="noop">
</span><span class="noop">            Resetting RecStep leads to more transparent results.  Note that, due
</span><span class="noop">            to the large value of the storage coefficient and the low accuracy
</span><span class="noop">            of the numerical approximation, direct discharge drains the rest of
</span><span class="noop">            the upper zone storage:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; recstep(2)
</span><span class="noop">            &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">            &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q0_perc_uz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc
</span><span class="noop">            perc(0.5)
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0
</span><span class="noop">            q0(0.5)
</span><span class="noop">            &gt;&gt;&gt; states.uz
</span><span class="noop">            uz(0.0)
</span><span class="noop">
</span><span class="noop">            Applying a more reasonable storage coefficient results in:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; k(.5)
</span><span class="noop">            &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q0_perc_uz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc
</span><span class="noop">            perc(0.5)
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0
</span><span class="noop">            q0(0.25)
</span><span class="noop">            &gt;&gt;&gt; states.uz
</span><span class="noop">            uz(0.25)
</span><span class="noop">
</span><span class="noop">            Adding an input of 0.3 mm results the same percolation value (which,
</span><span class="noop">            in the given example, is determined by the maximum percolation rate
</span><span class="noop">            only), but in an increases value of the direct response (which
</span><span class="noop">            always depends on the actual upper zone storage directly):
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuz = .3
</span><span class="noop">            &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q0_perc_uz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc
</span><span class="noop">            perc(0.5)
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0
</span><span class="noop">            q0(0.64)
</span><span class="noop">            &gt;&gt;&gt; states.uz
</span><span class="noop">            uz(0.16)
</span><span class="noop">
</span><span class="noop">            Due to the same reasons, another increase in numerical accuracy has
</span><span class="noop">            no impact on percolation but decreases the direct response in the
</span><span class="noop">            given example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; recstep(200)
</span><span class="noop">            &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">            &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q0_perc_uz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc
</span><span class="noop">            perc(0.5)
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0
</span><span class="noop">            q0(0.421708)
</span><span class="noop">            &gt;&gt;&gt; states.uz
</span><span class="noop">            uz(0.378292)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        aid = self.sequences.aides.fastaccess
</span><span class="hit">        flu.perc = 0.
</span><span class="hit">        flu.q0 = 0.
</span><span class="hit">        for jdx in range(con.recstep):
</span><span class="noop">            # First state update related to the upper zone input.
</span><span class="hit">            sta.uz += der.dt*flu.inuz
</span><span class="noop">            # Second state update related to percolation.
</span><span class="hit">            aid.perc = min(der.dt*con.percmax*flu.contriarea, sta.uz)
</span><span class="hit">            sta.uz -= aid.perc
</span><span class="hit">            flu.perc += aid.perc
</span><span class="noop">            # Third state update related to fast runoff response.
</span><span class="hit">            if sta.uz &gt; 0.:
</span><span class="hit">                if flu.contriarea &gt; 0.:
</span><span class="hit">                    aid.q0 = (der.dt*con.k *
</span><span class="noop">                              (sta.uz/flu.contriarea)**(1.+con.alpha))
</span><span class="hit">                    aid.q0 = min(aid.q0, sta.uz)
</span><span class="noop">                else:
</span><span class="miss">                    aid.q0 = sta.uz
</span><span class="hit">                sta.uz -= aid.q0
</span><span class="hit">                flu.q0 += aid.q0
</span><span class="noop">            else:
</span><span class="hit">                aid.q0 = 0.
</span><span class="noop">
</span><span class="hit">    def calc_lz(self):
</span><span class="noop">        &#34;&#34;&#34;Update the lower zone layer in accordance with percolation from
</span><span class="noop">        upper groundwater to lower groundwater and/or in accordance with
</span><span class="noop">        lake precipitation.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Required derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RelLandArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RelZoneArea`
</span><span class="noop">
</span><span class="noop">        Required fluxes sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.Perc`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`\\frac{dLZ}{dt} = Perc + Pc`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            At first, a subbasin with two field zones is assumed (the zones
</span><span class="noop">            could be of type forest or glacier as well).  In such zones,
</span><span class="noop">            precipitation does not fall directly into the lower zone layer,
</span><span class="noop">            hence the given precipitation of 2mm has no impact.  Only
</span><span class="noop">            the actual percolation from the upper zone layer (underneath
</span><span class="noop">            both field zones) is added to the lower zone storage:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FIELD)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea = 1.
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea = 2./3., 1./3.
</span><span class="noop">            &gt;&gt;&gt; fluxes.perc = 2.
</span><span class="noop">            &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">            &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">            &gt;&gt;&gt; model.calc_lz()
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(12.0)
</span><span class="noop">
</span><span class="noop">            If the second zone is an internal lake, its precipitation falls
</span><span class="noop">            on the lower zone layer directly.  Note that only 5/3mm
</span><span class="noop">            precipitation are added, due to the relative size of the
</span><span class="noop">            internal lake within the subbasin. Percolation from the upper
</span><span class="noop">            zone layer increases the lower zone storage only by two thirds
</span><span class="noop">            of its original value, due to the larger spatial extend of
</span><span class="noop">            the lower zone layer:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea = 2./3.
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea = 2./3., 1./3.
</span><span class="noop">            &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">            &gt;&gt;&gt; model.calc_lz()
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(13.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        sta.lz += der.rellandarea*flu.perc
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if con.zonetype[k] == ILAKE:
</span><span class="hit">                sta.lz += der.relzonearea[k]*flu.pc[k]
</span><span class="noop">
</span><span class="hit">    def calc_el_lz(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate lake evaporation.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">            :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">            :class:`~hydpy.models.hland.hland_control.TTIce`
</span><span class="noop">
</span><span class="noop">        Required derived parameters:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_control.RelZoneArea`
</span><span class="noop">
</span><span class="noop">        Required fluxes sequences:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">            :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">            :math:`\\frac{dLZ}{dt} = -EL` \n
</span><span class="noop">            :math:`EL = \\Bigl \\lbrace
</span><span class="noop">            {
</span><span class="noop">            {EPC \\ | \\ TC &gt; TTIce}
</span><span class="noop">            \\atop
</span><span class="noop">            {0 \\ | \\ TC \\leq TTIce}
</span><span class="noop">            }`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Six zones of the same size are initialized.  The first three
</span><span class="noop">            zones are no internal lakes, they can not exhibit any lake
</span><span class="noop">            evaporation.  Of the last three zones, which are internal lakes,
</span><span class="noop">            only the last one evaporates water.  For zones five and six,
</span><span class="noop">            evaporation is suppressed due to an assumed ice layer, whenever
</span><span class="noop">            the associated theshold temperature is not exceeded:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; ttice(-1.)
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea = 1./6.
</span><span class="noop">            &gt;&gt;&gt; fluxes.epc = .6
</span><span class="noop">            &gt;&gt;&gt; fluxes.tc = 0., 0., 0., 0., -1., -2.
</span><span class="noop">            &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">            &gt;&gt;&gt; model.calc_el_lz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.el
</span><span class="noop">            el(0.0, 0.0, 0.0, 0.6, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(9.9)
</span><span class="noop">
</span><span class="noop">            Note that internal lakes always contain water.  Hence, the
</span><span class="noop">            HydPy-H-Land model allows for negative values of the lower
</span><span class="noop">            zone storage:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.lz = .05
</span><span class="noop">            &gt;&gt;&gt; model.calc_el_lz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.el
</span><span class="noop">            el(0.0, 0.0, 0.0, 0.6, 0.0, 0.0)
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(-0.05)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == ILAKE) and (flu.tc[k] &gt; con.ttice[k]):
</span><span class="hit">                flu.el[k] = flu.epc[k]
</span><span class="hit">                sta.lz -= der.relzonearea[k]*flu.el[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.el[k] = 0.
</span><span class="noop">
</span><span class="hit">    def calc_q1_lz(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the slow response of the lower zone layer.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_control.K4`
</span><span class="noop">            :class:`~hydpy.models.hland.hland_control.Gamma`
</span><span class="noop">
</span><span class="noop">        Calculated fluxes sequence:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">
</span><span class="noop">        Updated state sequence:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">            :math:`\\frac{dLZ}{dt} = -Q1` \n
</span><span class="noop">            :math:`Q1 = \\Bigl \\lbrace
</span><span class="noop">            {
</span><span class="noop">            {K4 \\cdot LZ^{1+Gamma} \\ | \\ LZ &gt; 0}
</span><span class="noop">            \\atop
</span><span class="noop">            {0 \\ | \\ LZ\\leq 0}
</span><span class="noop">            }`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            As long as the lower zone storage is negative...
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; k4(.2)
</span><span class="noop">            &gt;&gt;&gt; gamma(0.)
</span><span class="noop">            &gt;&gt;&gt; states.lz = -2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q1_lz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.q1
</span><span class="noop">            q1(0.0)
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(-2.0)
</span><span class="noop">
</span><span class="noop">            ...or zero, no slow discharge response occurs:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.lz = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q1_lz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.q1
</span><span class="noop">            q1(0.0)
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(0.0)
</span><span class="noop">
</span><span class="noop">            For storage values above zero the linear...
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.lz = 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q1_lz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.q1
</span><span class="noop">            q1(0.2)
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(1.8)
</span><span class="noop">
</span><span class="noop">            ...or nonlinear storage routing equation applies:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; gamma(1.)
</span><span class="noop">            &gt;&gt;&gt; states.lz = 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_q1_lz()
</span><span class="noop">            &gt;&gt;&gt; fluxes.q1
</span><span class="noop">            q1(0.4)
</span><span class="noop">            &gt;&gt;&gt; states.lz
</span><span class="noop">            lz(1.6)
</span><span class="noop">
</span><span class="noop">            Note that the assumed length of the simulation step is only a
</span><span class="noop">            half day. Hence the effective value of the storage coefficient
</span><span class="noop">            is not 0.2 but 0.1:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; k4
</span><span class="noop">            k4(0.2)
</span><span class="noop">            &gt;&gt;&gt; k4.value
</span><span class="noop">            0.1
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        sta = self.sequences.states.fastaccess
</span><span class="hit">        if sta.lz &gt; 0.:
</span><span class="hit">            flu.q1 = con.k4*sta.lz**(1.+con.gamma)
</span><span class="noop">        else:
</span><span class="hit">            flu.q1 = 0.
</span><span class="hit">        sta.lz -= flu.q1
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    def calc_inuh(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the unit hydrograph input.
</span><span class="noop">
</span><span class="noop">        Required derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandArea`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.InUH`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">            :math:`InUH = Q0 + Q1`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">            The unit hydrographs receives base flow from the whole subbasin
</span><span class="noop">            and direct flow from zones of type field, forest and glacier only.
</span><span class="noop">            In the following example, these occupy only one half of the
</span><span class="noop">            subbasin, which is why the partial input of q0 is halved:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea = 0.5
</span><span class="noop">            &gt;&gt;&gt; fluxes.q0 = 4.
</span><span class="noop">            &gt;&gt;&gt; fluxes.q1 = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_inuh()
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuh
</span><span class="noop">            inuh(3.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        flu.inuh = der.rellandarea*flu.q0+flu.q1
</span><span class="noop">
</span><span class="hit">    def calc_outuh_quh(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the unit hydrograph output (convolution).
</span><span class="noop">
</span><span class="noop">        Required derived parameters:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_derived.UH`
</span><span class="noop">            :class:`~hydpy.models.hland.hland_derived.NmbUH`
</span><span class="noop">
</span><span class="noop">        Required flux sequences:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">            :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">            :class:`~hydpy.models.hland.hland_fluxes.InUH`
</span><span class="noop">
</span><span class="noop">        Updated log sequence:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_logs.QUH`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">            :class:`~hydpy.models.hland.hland_fluxes.OutUH`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Prepare a unit hydrograph with only three ordinates ---
</span><span class="noop">            representing a fast catchment response compared to the selected
</span><span class="noop">            step size:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh = 3
</span><span class="noop">            &gt;&gt;&gt; derived.uh.shape = derived.nmbuh
</span><span class="noop">            &gt;&gt;&gt; derived.uh = 0.3, 0.5, 0.2
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape = 3
</span><span class="noop">            &gt;&gt;&gt; logs.quh = 1., 3., 0.
</span><span class="noop">
</span><span class="noop">            Without new input, the actual output is simply the first value
</span><span class="noop">            stored in the logging sequence and the values of the logging
</span><span class="noop">            sequence are shifted to the left:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuh = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_outuh_quh()
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">            outuh(1.0)
</span><span class="noop">            &gt;&gt;&gt; logs.quh
</span><span class="noop">            quh(3.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">            With an new input of 4mm, the actual output consists of the first
</span><span class="noop">            value stored in the logging sequence and the input value
</span><span class="noop">            multiplied with the first unit hydrograph ordinate.  The updated
</span><span class="noop">            logging sequence values result from the multiplication of the
</span><span class="noop">            input values and the remaining ordinates:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">            &gt;&gt;&gt; model.calc_outuh_quh()
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">            outuh(4.2)
</span><span class="noop">            &gt;&gt;&gt; logs.quh
</span><span class="noop">            quh(2.0, 0.8, 0.0)
</span><span class="noop">
</span><span class="noop">            The next example demonstates the updating of non empty logging
</span><span class="noop">            sequence:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">            &gt;&gt;&gt; model.calc_outuh_quh()
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">            outuh(3.2)
</span><span class="noop">            &gt;&gt;&gt; logs.quh
</span><span class="noop">            quh(2.8, 0.8, 0.0)
</span><span class="noop">
</span><span class="noop">            A unit hydrograph with only one ordinate results in the direct
</span><span class="noop">            routing of the input:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh = 1
</span><span class="noop">            &gt;&gt;&gt; derived.uh.shape = derived.nmbuh
</span><span class="noop">            &gt;&gt;&gt; derived.uh = 1.
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuh = 0.
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape = 1
</span><span class="noop">            &gt;&gt;&gt; logs.quh = 0.
</span><span class="noop">            &gt;&gt;&gt; model.calc_outuh_quh()
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">            outuh(0.0)
</span><span class="noop">            &gt;&gt;&gt; logs.quh
</span><span class="noop">            quh(0.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">            &gt;&gt;&gt; model.calc_outuh_quh()
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">            outuh(4.0)
</span><span class="noop">            &gt;&gt;&gt; logs.quh
</span><span class="noop">            quh(0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        der = self.parameters.derived.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        log = self.sequences.logs.fastaccess
</span><span class="hit">        flu.outuh = der.uh[0]*flu.inuh+log.quh[0]
</span><span class="hit">        for jdx in range(1, der.nmbuh):
</span><span class="hit">            log.quh[jdx-1] = der.uh[jdx]*flu.inuh+log.quh[jdx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">    def calc_qt(self):
</span><span class="noop">        &#34;&#34;&#34;Calcutate the total discharge after possible abstractions.
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Abstr`
</span><span class="noop">
</span><span class="noop">        Required flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.OutUH`
</span><span class="noop">
</span><span class="noop">        Calculated flux sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_fluxes.QT`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">            :math:`QT = max(OutUH - Abstr, 0)`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            Trying to abstract less then available, as much as available and
</span><span class="noop">            less then available results in:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; abstr(2.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh = 2.
</span><span class="noop">            &gt;&gt;&gt; model.calc_qt()
</span><span class="noop">            &gt;&gt;&gt; fluxes.qt
</span><span class="noop">            qt(1.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_qt()
</span><span class="noop">            &gt;&gt;&gt; fluxes.qt
</span><span class="noop">            qt(0.0)
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh = .5
</span><span class="noop">            &gt;&gt;&gt; model.calc_qt()
</span><span class="noop">            &gt;&gt;&gt; fluxes.qt
</span><span class="noop">            qt(0.0)
</span><span class="noop">
</span><span class="noop">            Note that &#34;negative abstractions&#34; are allowed:
</span><span class="noop">            &gt;&gt;&gt; abstr(-2.)
</span><span class="noop">            &gt;&gt;&gt; fluxes.outuh = 1.
</span><span class="noop">            &gt;&gt;&gt; model.calc_qt()
</span><span class="noop">            &gt;&gt;&gt; fluxes.qt
</span><span class="noop">            qt(2.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.parameters.control.fastaccess
</span><span class="hit">        flu = self.sequences.fluxes.fastaccess
</span><span class="hit">        flu.qt = max(flu.outuh-con.abstr, 0.)
</span><span class="noop">
</span><span class="hit">    def updateoutlets(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Update the outlet link sequence.&#34;&#34;&#34;
</span><span class="miss">        der = self.parameters.derived.fastaccess
</span><span class="miss">        flu = self.sequences.fluxes.fastaccess
</span><span class="miss">        out = self.sequences.outlets.fastaccess
</span><span class="miss">        out.q[0] += der.qfactor*flu.qt
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, ILAKE, GLACIER, CONSTANTS
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(parametertools.ZipParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the HydPy-H-Land model
</span><span class="noop">    (potentially) handling multiple values.
</span><span class="noop">
</span><span class="noop">    Due to inheriting from :class:`~hydpy.core.parametertools.ZipParameter`,
</span><span class="noop">    additional keyword zipping functionality is offered.  The optional
</span><span class="noop">    `kwargs` are checked for the keywords `field`, `forest`, `glacier`,
</span><span class="noop">    `ilake,` and `default`.  If available, the respective values are used to
</span><span class="noop">    define the values of those 1-dimensional arrays, whose entries are related
</span><span class="noop">    to the different zone types. Also the method
</span><span class="noop">    :func:`~MultiParameter.compressrepr` tries to find compressed string
</span><span class="noop">    representations based on the mentioned zone types.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a :class:`MultiParameter` instance:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland.hland_parameters import MultiParameter
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; mp = MultiParameter()
</span><span class="noop">        &gt;&gt;&gt; mp.DIM, mp.TYPE, mp.TIME = 1, float, None
</span><span class="noop">        &gt;&gt;&gt; mp.subpars = model.parameters.control
</span><span class="noop">
</span><span class="noop">        Usually, one would indirectly define it shape through parameter
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.NmbZones`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.shape
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        RuntimeError: Shape information for parameter `multiparameter` can only be retrieved after it has been defined.  You can do this manually, but usually it is done automatically by defining the value of parameter `nmbzones` first in each parameter control file.
</span><span class="noop">
</span><span class="noop">        But here it is set manually to the value 5 for representing
</span><span class="noop">        five different zone types:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; zonetype.shape = 5
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, FIELD)
</span><span class="noop">        &gt;&gt;&gt; mp.shape = 5
</span><span class="noop">
</span><span class="noop">        Assign values to all four zone types explicitely:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1., glacier=4., ilake=3.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=4.0, ilake=3.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 2.,  1.,  4.,  3.,  2.])
</span><span class="noop">
</span><span class="noop">        Specify a default value for all zone types not included in the
</span><span class="noop">        keyword list:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1., default=9.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=9.0, ilake=9.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 2.,  1.,  9.,  9.,  2.])
</span><span class="noop">
</span><span class="noop">        If no default value is given, numpys `nan` is applied:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=nan, ilake=nan)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([  2.,   1.,  nan,  nan,   2.])
</span><span class="noop">
</span><span class="noop">        Of course, the usual value assignments remain unaffected:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.values = 5.
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(5.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 5.,  5.,  5.,  5.,  5.])
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.values = 5., 4., 3., 2., 1.
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(5.0, 4.0, 3.0, 2.0, 1.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 5.,  4.,  3.,  2.,  1.])
</span><span class="noop">
</span><span class="noop">    Another feature of :class:`MultiParameter` is that it relates the property
</span><span class="noop">    :func:`~MultiParameter.verifymask` to the defined zone types.
</span><span class="noop">    This requires the definition of the class attribute
</span><span class="noop">    :const:`~MultiParameter.REQUIRED_VALUES` for :class:`MultiParameter`
</span><span class="noop">    subclasses.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When values for all zone types are required, all entries of the
</span><span class="noop">        verification mask are `True`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.REQUIRED_VALUES = (FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; mp.verifymask
</span><span class="noop">        array([ True,  True,  True,  True,  True], dtype=bool)
</span><span class="noop">
</span><span class="noop">        When values for field and forest zones are required only, the
</span><span class="noop">        entries related to glacier and ilake zones are `False`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.REQUIRED_VALUES = (FIELD, FOREST)
</span><span class="noop">        &gt;&gt;&gt; mp.verifymask
</span><span class="noop">        array([ True,  True, False, False,  True], dtype=bool)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, GLACIER, ILAKE)
</span><span class="hit">    MODEL_CONSTANTS = CONSTANTS
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def refparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.ZoneType`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.zonetype
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;Return a tuple containing the lengths in all dimensions of the
</span><span class="noop">        parameter values.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return parametertools.ZipParameter._getshape(self)
</span><span class="hit">        except RuntimeError:
</span><span class="hit">            raise RuntimeError(&#39;Shape information for parameter `%s` can &#39;
</span><span class="noop">                               &#39;only be retrieved after it has been defined. &#39;
</span><span class="noop">                               &#39; You can do this manually, but usually it is &#39;
</span><span class="noop">                               &#39;done automatically by defining the value of &#39;
</span><span class="noop">                               &#39;parameter `nmbzones` first in each parameter &#39;
</span><span class="noop">                               &#39;control file.&#39; % self.name)
</span><span class="hit">    shape = property(_getshape, parametertools.ZipParameter._setshape)
</span><span class="noop">
</span><span class="hit">class MultiParameterSoil(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `soil zones` (and interception).
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST)
</span><span class="noop">
</span><span class="hit">class MultiParameterLand(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for all `land zones`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, GLACIER)
</span><span class="noop">
</span><span class="hit">class MultiParameterLake(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `lake zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (ILAKE,)
</span><span class="noop">
</span><span class="hit">class MultiParameterGlacier(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `glacier zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (GLACIER,)
</span><span class="noop">
</span><span class="hit">class MultiParameterNoGlacier(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `glacier free zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, ILAKE)
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the hland model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the values of the parameters handled by
</span><span class="noop">        :class:`DerivedParameters` based on the values of the parameters
</span><span class="noop">        handled by :class:`ControlParameters`.  The results of the different
</span><span class="noop">        methods are not interdependend, meaning their order could be changed.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.calc_relzonearea()
</span><span class="miss">        self.calc_landzonearea()
</span><span class="miss">        self.calc_soilarea()
</span><span class="miss">        self.calc_ttm()
</span><span class="miss">        self.calc_dt()
</span><span class="miss">        self.calc_nmbuh_uh()
</span><span class="miss">        self.calc_qfactor()
</span><span class="noop">
</span><span class="hit">    def calc_relzonearea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the relative areas of all zones within the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With one single zone, its relative area is one by definition:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(1)
</span><span class="noop">            &gt;&gt;&gt; zonearea(1111.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_relzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea
</span><span class="noop">            relzonearea(1.0)
</span><span class="noop">
</span><span class="noop">            An example for three zones of different sizes:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">            &gt;&gt;&gt; zonearea(1., 3., 2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_relzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea
</span><span class="noop">            relzonearea(0.166667, 0.5, 0.333333)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.relzonearea(con.zonearea/sum(con.zonearea))
</span><span class="noop">
</span><span class="hit">    def calc_landzonearea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the fraction of the summed area of all &#34;land zones&#34;
</span><span class="noop">        (of type FIELD, FOREST, or ILAKE) and the total subbasin area, and
</span><span class="noop">        calculate the fractions of all &#34;land zones&#34; and the total &#34;land area&#34;
</span><span class="noop">        of the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With all zones beeing &#34;land zones&#34;, the relative land area is
</span><span class="noop">            one by definition and the relative &#34;land zone&#34; areas are in
</span><span class="noop">            accordance with the original zone areas:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER)
</span><span class="noop">            &gt;&gt;&gt; area(100.)
</span><span class="noop">            &gt;&gt;&gt; zonearea(25., 25., 50.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(1.0)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(field=0.25, forest=0.25, glacier=0.5)
</span><span class="noop">
</span><span class="noop">            With one zone beeing a lake zone, the relative &#34;land area&#34; is
</span><span class="noop">            decreased and the relative &#34;land zone&#34; areas are increased ---
</span><span class="noop">            except the one related to the internal lake, which is set to zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(0.5)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(field=0.5, forest=0.5, ilake=0.0)
</span><span class="noop">
</span><span class="noop">            With all zones beeing lake zones, all relative areas are zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(0.0)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(0.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        landzonearea = con.zonearea.copy()
</span><span class="hit">        landzonearea[con.zonetype == ILAKE] = 0.
</span><span class="hit">        landarea = numpy.sum(landzonearea)
</span><span class="hit">        if landarea &gt; 0.:
</span><span class="hit">            der.rellandzonearea(landzonearea/landarea)
</span><span class="noop">        else:
</span><span class="hit">            der.rellandzonearea(0.)
</span><span class="hit">        der.rellandarea(landarea/con.area)
</span><span class="noop">
</span><span class="hit">    def calc_soilarea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the fraction of the summed area of all &#34;soil zones&#34;
</span><span class="noop">        (of type FIELD or FOREST) and the total subbasin area, and
</span><span class="noop">        calculate the fractions of all &#34;soil zones&#34; and the total &#34;soil area&#34;
</span><span class="noop">        of the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelSoilArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelSoilZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With all zones beeing &#34;soil zones&#34;, the relative land area is
</span><span class="noop">            one by definition and the relative &#34;soil zone&#34; areas are in
</span><span class="noop">            accordance with the original zone areas:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, FIELD, FOREST)
</span><span class="noop">            &gt;&gt;&gt; area(100.)
</span><span class="noop">            &gt;&gt;&gt; zonearea(25., 25., 25., 25.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(1.0)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(0.25)
</span><span class="noop">
</span><span class="noop">            With one zone beeing a lake zone one one zone beeing a glacier
</span><span class="noop">            zone, the relative &#34;soil area&#34; is decreased and the relative
</span><span class="noop">            &#34;soil zone&#34; areas are increased --- except the ones related to
</span><span class="noop">            the internal lake and the glacier, which are set to zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(0.5)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(field=0.5, forest=0.5, glacier=0.0, ilake=0.0)
</span><span class="noop">
</span><span class="noop">            With all zones beeing lake or glacier zones, all relative areas
</span><span class="noop">            are zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(GLACIER, GLACIER, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(0.0)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(0.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        soilzonearea = con.zonearea.copy()
</span><span class="hit">        soilzonearea[con.zonetype == GLACIER] = 0.
</span><span class="hit">        soilzonearea[con.zonetype == ILAKE] = 0.
</span><span class="hit">        soilarea = numpy.sum(soilzonearea)
</span><span class="hit">        if soilarea &gt; 0.:
</span><span class="hit">            der.relsoilzonearea(soilzonearea/soilarea)
</span><span class="noop">        else:
</span><span class="hit">            der.relsoilzonearea(0.)
</span><span class="hit">        der.relsoilarea(soilarea/con.area)
</span><span class="noop">
</span><span class="hit">    def calc_ttm(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the threshold temperature for melting and refreezing.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.TT`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.DTTM`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`TTM = TT+DTTM`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(1)
</span><span class="noop">            &gt;&gt;&gt; tt(1.)
</span><span class="noop">            &gt;&gt;&gt; dttm(-2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_ttm()
</span><span class="noop">            &gt;&gt;&gt; derived.ttm
</span><span class="noop">            ttm(-1.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.ttm(con.tt+con.dttm)
</span><span class="noop">
</span><span class="hit">    def calc_dt(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the relative time step size for solving the upper
</span><span class="noop">        zone layer routine.
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RecStep`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.DT`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`DT = \\frac{1}{RecStep}`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; recstep(2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_dt()
</span><span class="noop">            &gt;&gt;&gt; derived.dt
</span><span class="noop">            dt(1.0)
</span><span class="noop">            &gt;&gt;&gt; recstep(10.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_dt()
</span><span class="noop">            &gt;&gt;&gt; derived.dt
</span><span class="noop">            dt(0.2)
</span><span class="noop">
</span><span class="noop">            Note that the value assigned to recstep is related to the given
</span><span class="noop">            parameter step size of one day.  The actually applied recstep of
</span><span class="noop">            the last example is:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; recstep.value
</span><span class="noop">            5
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.dt(1./con.recstep)
</span><span class="noop">
</span><span class="hit">    def calc_qfactor(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the factor for converting values of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.QT` [mm/T] to values of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_links.Q` [m³/s].
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">
</span><span class="noop">        Required property of
</span><span class="noop">        :class:`~hydpy.core.parametertools.Parameter`:
</span><span class="noop">
</span><span class="noop">          :attr:`~hydpy.core.parametertools.Parameter.seconds`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.QFactor`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; area(50.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_qfactor()
</span><span class="noop">            &gt;&gt;&gt; derived.qfactor
</span><span class="noop">            qfactor(1.157407)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.qfactor(con.area*1000./der.qfactor.simulationstep.seconds)
</span><span class="noop">
</span><span class="hit">    def calc_nmbuh_uh(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the ordinates of the triangle unit hydrograph.
</span><span class="noop">
</span><span class="noop">        Note that also the shape of sequence
</span><span class="noop">        :class:`~hydpy.models.hland.hland_logs.QUH` is defined in accordance
</span><span class="noop">        with :class:`~hydpy.models.hland.hland_derived.NmbUH`.
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.MaxBaz`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.NmbUH`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.UH`
</span><span class="noop">
</span><span class="noop">        Prepared log sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_logs.QUH`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            MaxBaz determines the end point of the triangle.  A value of
</span><span class="noop">            MaxBaz beeing not larger than the simulation step size is
</span><span class="noop">            identical with applying no unit hydrograph at all:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;, warn=False)
</span><span class="noop">            &gt;&gt;&gt; maxbaz(0.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(1)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (1,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(1.0)
</span><span class="noop">
</span><span class="noop">            Note that, due to difference of the parameter and the simulation
</span><span class="noop">            step size in the given example, the largest assignement resulting
</span><span class="noop">            in a `inactive` unit hydrograph is 1/2:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(0.5)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(1)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (1,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(1.0)
</span><span class="noop">
</span><span class="noop">            When MaxBaz is in accordance with two simulation steps, both
</span><span class="noop">            unit hydrograph ordinats must be 1/2, due to symmetry of the
</span><span class="noop">            triangle:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(2)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (2,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.5)
</span><span class="noop">
</span><span class="noop">            A MaxBaz value in accordance with three simulation steps results
</span><span class="noop">            --- when expressed as fractions --- in the ordinate values 2/9,
</span><span class="noop">            5/9, and 2/9:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.5)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(3)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (3,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.222222, 0.555556, 0.222222)
</span><span class="noop">
</span><span class="noop">            And a final example, where the end of the triangle lies within
</span><span class="noop">            a simulation step, resulting in the fractions 8/49, 23/49, 16/49,
</span><span class="noop">            and 2/49:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.75)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(4)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (4,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.163265, 0.469388, 0.326531, 0.040816)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        log = self.model.sequences.logs
</span><span class="noop">        # Determine UH parameters...
</span><span class="hit">        if con.maxbaz &lt;= 1.:
</span><span class="noop">            # ...when MaxBaz smaller than or equal to the simulation time step.
</span><span class="hit">            der.nmbuh = 1
</span><span class="hit">            der.uh.shape = 1
</span><span class="hit">            der.uh(1.)
</span><span class="hit">            log.quh.shape = 1
</span><span class="noop">        else:
</span><span class="noop">            # ...when MaxBaz is greater than the simulation time step.
</span><span class="noop">            # Define some shortcuts for the following calculations.
</span><span class="hit">            full = con.maxbaz.value
</span><span class="noop">            # Now comes a terrible trick due to rounding problems coming from
</span><span class="noop">            # the conversation of the SMHI parameter set to the HydPy
</span><span class="noop">            # parameter set.  Time to get rid of it...
</span><span class="hit">            if (full % 1.) &lt; 1e-4:
</span><span class="hit">                full //= 1.
</span><span class="hit">            full_f = int(numpy.floor(full))
</span><span class="hit">            full_c = int(numpy.ceil(full))
</span><span class="hit">            half = full/2.
</span><span class="hit">            half_f = int(numpy.floor(half))
</span><span class="hit">            half_c = int(numpy.ceil(half))
</span><span class="hit">            full_2 = full**2.
</span><span class="noop">            # Calculate the triangle ordinate(s)...
</span><span class="hit">            der.nmbuh(full_c)
</span><span class="hit">            der.uh.shape = full_c
</span><span class="hit">            log.quh.shape = full_c
</span><span class="noop">            # ...of the rising limb.
</span><span class="hit">            points = numpy.arange(1, half_f+1)
</span><span class="hit">            der.uh[:half_f] = (2.*points-1.)/(2.*full_2)
</span><span class="noop">            # ...around the peak (if it exists).
</span><span class="hit">            if numpy.mod(half, 1.) != 0.:
</span><span class="hit">                der.uh[half_f] = \
</span><span class="noop">                    ((half_c-half)/full +
</span><span class="noop">                     (2*half**2.-half_f**2.-half_c**2.)/(2.*full_2))
</span><span class="noop">            # ...of the falling limb (eventually except the last one).
</span><span class="hit">            points = numpy.arange(half_c+1., full_f+1.)
</span><span class="hit">            der.uh[half_c:full_f] = 1./full-(2.*points-1.)/(2.*full_2)
</span><span class="noop">            # ...at the end (if not already done).
</span><span class="hit">            if numpy.mod(full, 1.) != 0.:
</span><span class="hit">                der.uh[full_f] = ((full-full_f)/full -
</span><span class="noop">                                  (full_2-full_f**2.)/(2.*full_2))
</span><span class="noop">            # Normalize the ordinates.
</span><span class="hit">            der.uh(der.uh/numpy.sum(der.uh))
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_sequences.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_sequences.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="hit">class Sequences(sequencetools.Sequences):
</span><span class="noop">    &#34;&#34;&#34;All sequences of the hland model.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.models.hland.hland_constants import ILAKE
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Ic(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Interception storage [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`IC \\leq ICMAX`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; icmax(2.)
</span><span class="noop">        &gt;&gt;&gt; states.ic(-1.,0., 1., 2., 3.)
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 1.0, 2.0, 2.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            control = self.subseqs.seqs.model.parameters.control
</span><span class="hit">            upper = control.icmax
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="hit">class SP(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">class WC(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Liquid water content of the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WC \\leq WHC \\cdot SP`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; whc(.1)
</span><span class="noop">        &gt;&gt;&gt; states.sp(0., 0., 0., 5., 5., 5., 5.)
</span><span class="noop">        &gt;&gt;&gt; states.wc(-1., 0., 1., -1., 0., .5, 1.)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            control = self.subseqs.seqs.model.parameters.control
</span><span class="hit">            states = self.subseqs
</span><span class="hit">            upper = control.whc*states.sp
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="hit">class SM(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Soil moisture [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`SM \\leq FC`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; states.sm(-100.,0., 100., 200., 300.)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 200.0, 200.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subseqs.seqs.model.parameters.control.fc
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="hit">class UZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage in the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="hit">class LZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage in the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (None, None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim negative value whenever there is no internal lake within
</span><span class="noop">        the respective subbasin.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; states.lz(-1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(-1.0)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST)
</span><span class="noop">        &gt;&gt;&gt; states.lz(-1.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz(1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(1.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            control = self.subseqs.seqs.model.parameters.control
</span><span class="hit">            if not any(control.zonetype==ILAKE):
</span><span class="hit">                lower = 0.
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the HydPy-H-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Ic, SP, WC, SM, UZ, LZ)
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
    </div>
  </body>
</html>